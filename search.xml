<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(二)]]></title>
    <url>%2Farchives%2Fb05dc691.html</url>
    <content type="text"><![CDATA[那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想再一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。——王小波《黄金时代》 前言 照例，如果只是需要监听iBeacon的demo代码，可以直接点击下载，不需要往下看了😂 如果想了解iBeacon相关信息，请参考iOS蓝牙开发之iBeacon篇(一) 虽然iBeacon也是基于Ble的，从硬件上看也是一套东西，但是Apple公司把他封装成了两套东西，所以在iOS移动端开发来说，这是两个完全不同的东西，调用完全不同框架的api. Apple公司为了省电和隐私限制只能监听指定UUID的iBeacon，无法像安卓一样搜索附近所有的iBeacon信息，虽然iBeacon扫描底层可以获取到附近的所有的iBeacon信息（底层就是获取附近所有的iBeacon然后和当前监听的iBeacon标识对比，然后回调给上层），如果你只是想在你自己的手机上测试下，可以参考AnyiBeacon-iOS这个项目，但是只能作为测试使用，因为涉及到Apple的私有api，是不允许上架App Store的。 想了解iBeacon底层数据协议格式的，可以参考What is the iBeacon Bluetooth Profile 这篇文章。 初始化 在 iOS8.0之后的时候如果想使用iBeacon，必须让用户授权 在info.plist文件里面配置下面的key 123NSLocationAlwaysAndWhenInUseUsageDescription // 推荐NSLocationWhenInUseUsageDescriptionNSLocationAlwaysUsageDescription 在capabilities里面开启Background Modes的 Location updates 由于iBeacon是基于CoreLocation框架的，所以先导入头文件并实例化位置管理者 12import CoreLocationlet locationManager = CLLocationManager() 请求授权并设置代理 12345678override func viewDidLoad()&#123; super.viewDidLoad() // Do any additional setup after loading the view. locationManager.requestAlwaysAuthorization() locationManager.delegate = self&#125; 添加需要监听的iBeacon 这个是添加iBeacon信息界面代理回调 123456789101112131415// MARK: AddBeaconextension ItemsViewController: AddBeacon &#123; func addBeacon(item: Item) &#123; items.append(item) tableView.beginUpdates() let newIndexPath = IndexPath(row: items.count - 1, section: 0) tableView.insertRows(at: [newIndexPath], with: .automatic) tableView.endUpdates() startMonitoring(item) // 开始监控 persistItems() // 持久化到本地 &#125;&#125; Item为一个iBeacon信息的数据模型, 即包含如下信息 12345let name: String // 非必须let icon: Int // 非必须let uuid: UUIDlet majorValue: CLBeaconMajorValue // 非必须let minorValue: CLBeaconMinorValue // 非必须 开始监听和停止监听 根据一个iBeacon的参数（iBeacon硬件提供或者自己用iPhone或者mac模拟）初始化一个CLBeaconRegion 两种监听模式 123456789101112func startMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.startMonitoring(for: region) // 低功耗，支持后台监听 locationManager.startRangingBeacons(in: region) // 大功耗，不支持后台监听&#125;// MARK: 根据模型数据初始化一个Beacon Regionfunc asBeaconRegion() -&gt; CLBeaconRegion &#123; return CLBeaconRegion(proximityUUID: uuid, major: majorValue, minor: minorValue, identifier: name)&#125; 如果想停止监听某个iBeacon 123456func stopMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.stopMonitoring(for: region) locationManager.stopRangingBeacons(in: region)&#125; 监听到iBeacon信息回调 开始监听某个Beacon 1234func locationManager(_ manager: CLLocationManager, didStartMonitoringFor region: CLRegion)&#123; print("didStartMonitoringFor\(region)")&#125; 监听到Beacons 12345678910111213141516171819202122232425// MARK: CLLocationManagerDelegateextension ItemsViewController: CLLocationManagerDelegate &#123; func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion) &#123; print("didRangeBeacons \(beacons.count)个") var indexPaths = [IndexPath]() for beacon in beacons &#123; for row in 0..&lt;items.count &#123; // 检测是否是需要监控的beacon if items[row] == beacon &#123; items[row].beacon = beacon indexPaths += [IndexPath(row: row, section: 0)] &#125; &#125; &#125; if let visiblaRows = tableView.indexPathsForVisibleRows &#123; let rowsToUpdate = visiblaRows.filter&#123; indexPaths.contains($0) &#125; for row in rowsToUpdate &#123; let cell = tableView.cellForRow(at: row) as? ItemCell cell?.refreshLocation() &#125; &#125; &#125; 其他的回调方法 注意： 如果需要监听进入某个区域或者从某个区域离开，则需要在初始化Beacon Region的时候订阅 不然进入和离开区域不回回调 12&gt; region.notifyOnEntry = YES; &gt; region.notifyOnExit = YES; 1234567891011121314151617181920212223// monitoring 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error)&#123; print("Failed monitoring region\(error.localizedDescription)")&#125;// 位置管理者出现错误信息 func locationManager(_ manager: CLLocationManager, didFailWithError error: Error)&#123; print("Location manager failed \(error.localizedDescription)")&#125;// ranging 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, rangingBeaconsDidFailFor region: CLBeaconRegion, withError error: Error)&#123; print("rangingBeaconsDidFailFor")&#125;// 已经进入到某个区域 func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; print("didEnterRegion")&#125;// 已经从某个区域离开 func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; print("didExitRegion")&#125; 关于推送 app现在能显示iBeacon设备，并且还能实时监控它们的距离。但是当app没有处于运行状态时，如iBeacon设备在宠物猫脖子上但是宠物猫跑丢了！ 此时app就需要在猫离开区域的时候通知用户。 在AppDelegate导入通知框架并初始化一个位置管理者 1234import CoreLocationimport UserNotificationsvar locationManager = CLLocationManager() 程序启动的时候，配置位置监听和设置通知 123456789101112func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. // 注册通知，请求权限 let center = UNUserNotificationCenter.current() center.requestAuthorization(options: [.alert, .sound]) &#123; (granted, error) in &#125; // 设置代理 locationManager.delegate = self return true&#125; 监听目标离开区域并发送本地通知 123456789101112131415extension AppDelegate: CLLocationManagerDelegate&#123; func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; guard region is CLBeaconRegion else &#123; return &#125; let content = UNMutableNotificationContent() content.title = "Forget Me Not" content.body = "Are you forgetting something?" content.sound = .default() let request = UNNotificationRequest(identifier: "iBeaconDemo", content: content, trigger: nil) UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125;&#125; 参考官方文档维基百科iOS 中 iBeacon 开发iBeacon Tutorial with iOS and SwiftHow to detect ibeacon device without knowing UUID in iOS?Detecting beacons via iBeacon Monitoring &amp; Ranging vs CoreBluetooth scanForPeripheralsWithServices]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(一)]]></title>
    <url>%2Farchives%2F1f6c5df3.html</url>
    <content type="text"><![CDATA[高山有崖,林木有枝。忧来无方, 人莫之知。——曹丕《善哉行》 什么是iBeacon 如果只是需要iPhone模拟iBeacon的demo代码，可以点击下载，不需要往下看了😂 你曾经想过用手机在一个大型建筑物中为自己定位吗，比如购物中心，或者博物馆。 当然，GPS可以让你得知自己身处哪一座建筑物里。但是如果想要在这些钢筋混凝土堆砌而成的建筑中获得精确的GPS信号，只能祝你好运了。你所需要的是内置在建筑物中一些设备，（通过它们）让手机获取确定你的位置。 iBeacon是Apple公司开发的一种近场通讯协议，于2013年的WWDC开发者大会推出。当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。因为是一种定位技术，苹果将iBeacon相关的接口放到了CoreLocation.framework。 其工作方式是: 配备有低功耗蓝牙（BLE）通信功能的设备(iBeacon)使用BLE技术向周围发送自己特有的UUID，使用iBeacon的App接收到该UUID的应用软件会根据该UUID采取一些行动。 iBeacon的应用场景 当使用者走进某个博物馆时，会扫描到一个 beacon。这个 beacon 有三个标志符 proximityUUID 是一个整个博物馆统一的值，可以用来标识这个博物馆 major 值用来标识特定的展馆，比如唐代展馆，汉代展馆等等 minor 值标识了特定的一个位置的 beacon，例如定位到使用者正在唐代展馆的唐三彩展品的位置。 这时博物馆的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到使用者的地理位置（通过查询服务器或者本地数据） 例如在唐代展馆的唐三彩展品位置，之后就可以通过一个 local notification 推送这件展品的简介。用户可以点击这次 local notification 来查看更详细的信息，这样一次导览行为就完成了。 可以充当iBeacon的iOS的设备 iPhone4s 或者 之后的iPhone设备 第三代iPad或者 之后iPad设备 iPad mini 或者 之后iPad mini设备 第五代iPod touch 或者之后iPod touch设备 iMac 或者 MacBookPro iBeacon监听方式 Monitoring：低功耗监听，用来判断设备进出ibeacon围栏，支持后台或app进程杀掉后监听。 Ranging：大功率监听，监听当前设备所在区域内的ibeacon信息，包括rssi，距离，不支持后台监听。 基于这两个特性，我们在使用时就分为前台和后台两个场景来实现ibeacon的检测。 iBeacon监听 你的设备当然不会自动监测iBeacon的，所以首先你得告知它。CLBeaconRegion类代表一个iBeacon。 iBeacon与Core Location关联在一起看上去有点奇怪，因为它就是一个蓝牙设备而已，但是也可以这么认为，那就是iBeacon提供小范围定位功能，而GPS提供的是大范围定位功能。 CLBeaconRegion参数介绍 参数 必要字段 作用 identifier 是 标识字符串 proximityUUID 是 一级标识（eg.标识公司） major 否 二级标识（eg.标识店铺） minor 否 三级标识（eg.标识位置） 手机模拟iBeacon 当想让iOS设备充当iBeacon时，你还需要引入Core Bluetooth框架，但只想检测iBeacon设备，你只需要Core Location就行了。 初始化 初始化配置一个iBeacon的参数 beaconUUID 是一个128位的值，可以使用uuidgen生成，但是生成的某些值不可用，推荐使用我提供的这个 初始化一个蓝牙外设管理者， 12345678910111213private let beaconIdentity = "kitty"private let beaconUUID = "B0702880-A295-A8AB-F734-031A98A512DE"private let beaconMajorValue = UInt16(2)private let beaconMinorValue = UInt16(7)private var peripheraManager: CBPeripheralManager?override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. peripheraManager = CBPeripheralManager(delegate: self, queue: .main)&#125; 监听蓝牙状态改变 在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description请求蓝牙授权 遵守CBPeripheralManagerDelegate协议 123456789101112131415161718192021extension ViewController: CBPeripheralManagerDelegate&#123; func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) &#123; switch peripheral.state &#123; case .unknown: print("蓝牙未知的") case .resetting: print("蓝牙重置中") case .unsupported: print("蓝牙不支持") case .unauthorized: print("蓝牙未验证") case .poweredOff: print("蓝牙未启动") case .poweredOn: print("蓝牙可用") beaconAdvertising() &#125; &#125;&#125; 配置模拟iBeacon广播数据1234567891011func beaconAdvertising() &#123; guard let uuid = UUID(uuidString: beaconUUID) else &#123; return &#125; let region = CLBeaconRegion(proximityUUID: uuid, major: beaconMajorValue, minor: beaconMinorValue, identifier: beaconIdentity) let regionData = region.peripheralData(withMeasuredPower: nil) let regionAdvertising = regionData as? [String : Any] peripheraManager?.startAdvertising(regionAdvertising) print("开始模拟Beacon广播数据\(regionData)")&#125; 监听是否广播成功 若广播成功，则可作为iBeacon使用 需要监听iBeacon可参考iOS蓝牙开发之iBeacon篇(二) 12345func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) &#123; print("正在模拟Beacon广播数据: \(peripheral.isAdvertising) --- 错误信息: \(String(error?.localizedDescription ?? "无"))") stateLbl.text = "正在模拟Beacon广播数据: \n\(peripheral.isAdvertising) \n错误信息: \n\(String(error?.localizedDescription ?? "无"))" stateLbl.textAlignment = .center&#125; 参考官方文档维基百科iOS 中 iBeacon 开发]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(三):历史轨迹记录]]></title>
    <url>%2Farchives%2Fb47045de.html</url>
    <content type="text"><![CDATA[月落乌啼霜满天，江枫渔火对愁眠。姑苏城外寒山寺，夜半钟声到客船。 前言 思 考 要 怎 么 开 始 。。。 嗯 (过了一万年。。。) 最近一直在做一个宠物定位的项目，本来以为只需要参考官方文档接入地图实现功能就可以winner winner chicken dinner了，但是等到我掉以轻心的做到后面再加上历史轨迹疯狂改需求的时候，又双叒叕加上还要百度和谷歌同步实现功能，心中开始有一万只神兽在奔腾，于是、、就有了这篇文章的由来了。 关于历史轨迹 补一张效果图 历史轨迹历经了好几个版本的在几个方案之间来回拉锯，现在终于是。。。还没有定下来具体的方案了🤣 方案一：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以点击播放按钮回放历史轨迹并画线；或者拖动一个UISlideBar滑动条可以切换每一轨迹点并显示轨迹详细信息弹框。 方案二：选时间段查询历史轨迹数据后显示第一个点在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点画线并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案三：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案四五六七八九…待客户和老板定。 问题 方案一：查询轨迹过多导致获取数据比较耗时，显示点比较多画线乱。 方案二：筛选所选时间段的估计点（抽取平均10个点出来，后来又改为5个，在在后来改为服务器配置），画线功能由服务器配置，选择时间段间隔服务器配置。 方案三：在方案二的基础上，分页获取所有数据并全部显示 方案四五六七八九…未知 百度地图历史轨迹开始挖坑 历史古迹无非就是多个位置点构成，所以和上一篇的添加坐标点大头针一样，只是添加多个而已，考虑到控件的重用机制，所以有了下面的代码 1234567891011121314151617181920212223242526// ... 遍历历史古迹数据 创建地图大头针// ... 对每一个坐标反地理编码// ... 在反地理编码里面刷新对应的模型信息地址 并刷新自定义弹框paopaoView- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@"LocationAnnotation"]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@"LocationAnnotation"]; &#125; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@"_small"]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; self.petAnnotationView.isHiddenNoNeeds = YES; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; [annotationView setSelected:YES animated:NO]; // 选中当前的 &#125; return annotationView;&#125; 掉坑里了 如果所有的大头针都共用一个自定义的paopaoView（petAnnotationView）的话，就会导致selectAnnotation:animated:方法没有效果 并且只有最后添加的那一个轨迹带你点击才会调用selectAnnotation:animated: 其他大头针点击都会失效 如果要控制切换轨迹点刷新显示弹框信息，那就需要根据索引先移除当前点，再重新添加重新渲染，而且切换不流畅，会出现莫名的问题 怎么从坑里跳出来？ 1、找大牛 2、查资料 3、习惯有坑，顺其自然 但是 作为一个视这世界上只有两件事是真理：人都会死；程序永远有bug为座右铭的程序猿，当然是选择3啊，但是考虑到这样有可能会被打死，而求人又不如求己的理念，我就开始苦逼的查资料，看官方demo和官方论坛（屎一样的论坛，永远回复：在处理中、感谢你的反馈） 经过我的反复查询资料，不断尝试，最后终于在我的灵机一动下解决了，再次印证了爱迪生的话但那1％的灵感是最重要的，甚至比那99％的汗水都要重要。😂 既然一个轨迹点可以正常的点击显示和隐藏，是不是需要每一个轨迹点大头针都需要绑定一个paopaoView呢 本着实践是检验真理的唯一标准，于是有了以下代码 12345678910111213141516171819202122232425- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; &#125; XSLocationDetails *locationDetails = customAnnotation.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@&quot;_small&quot;]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; petAnnotationView.isHiddenNoNeeds = YES; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationDetails; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:petAnnotationView]; self.petAnnotationView = petAnnotationView; &#125; return annotationView;&#125; 是骡子是马拉出来溜溜，编译运行，轨迹点都可以点击了，哇，开心的就像一个几十岁的孩子拍了拍肚皮，正准备去喝杯Coffee舒爽一下呢，发现地址信息没有 于是开始考虑现在是一个轨迹点对应一个自定义的paopaoView，那么在反地理编码的代理回调里面怎么把地址信息对应的轨迹点模型更新呢 根据代理回调里面location坐标和当前的所有历史轨迹数据坐标对比, 开心的打印一下，竟然和传递的转换前的坐标有误差； 仿谷歌地图反地理编码，改代理回调为block回调？直接动手 123456789// XSBaiduGeocoder.htypedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc self.reverseGeocodeHandler = handler; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; BMKGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc if (self.reverseGeocodeHandler) &#123; self.reverseGeocodeHandler(result); &#125;&#125;@end BMKGeoCodeSearch这个一定要调用一次创建一次，否则只会转换一次地址信息 但是此时虽然轨迹点地址信息都转换了，但是只有点击最后一个轨迹点有地址信息，其他都是空的，这个问题卡了好久脑子没转过来，一直在block捕获方向考虑，后来突然醒悟 self.reverseGeocodeHandler = handlerblock是每次都进来赋值，而地址转换完成的代理回调方法又调用延迟，那在代理回调方法里面回调临时保存的self.reverseGeocodeHandler肯定是最后一个，所以就只会更新最后一个轨迹坐标的模型地址数据 既然BMKGeoCodeSearch是每一个坐标对应一个，那个完全可以自定义XSGeoCodeSearch继承BMKGeoCodeSearch添加对应的回调handler，等地址转换完成的代理回调时候，根据XSGeoCodeSearch保存的handler回调回去，于是代码修改如下 12345678910// XSGeoCodeSearch.h@class BMKReverseGeoCodeResult;typedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSGeoCodeSearch : BMKGeoCodeSearch@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end 1234567// XSBaiduGeocoder.h@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; XSGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.reverseGeocodeHandler = handler; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc // 查询searcher 对应的block 然后回调 XSGeoCodeSearch *codeSearcher = (XSGeoCodeSearch *)searcher; if (codeSearcher.reverseGeocodeHandler) &#123; codeSearcher.reverseGeocodeHandler(result); &#125;&#125;@end 再运行，点击切换轨迹点，世界都美好了，操作轨迹点的切换也可以直接使用selectAnnotation:animated:弹出详情自定义弹框了 轨迹点区域控制 如果想控制所有的估计点都在屏幕范围内显示，最早使用的上一篇里面的方法，后来查资料看这一种也可以 1234567891011121314151617181920212223- (void)baiduMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; //创建两个数组，用来存所有的经度和纬度 if (count &lt; 2) return; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@"@max.floatValue"];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@"@min.floatValue"];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@"@max.floatValue"];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@"@min.floatValue"];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES];&#125; 当然还有更简单的方法,所以一定要多看各种SDK的头文件，看都有哪些功能 12345/** *设置地图使显示区域显示所有annotations,如果数组中只有一个则直接设置地图中心为annotation的位置 *@param annotations 指定的标注 *@param animated 是否启动动画 */- (void)showAnnotations:(NSArray *)annotations animated:(BOOL)animated; 谷歌地图历史轨迹 关于谷歌地图历史轨迹，基本上就没什么说的了，接口相比百度更规范和清晰 谷歌地图添加Marker(相当于百度地图Annotation)直接配置大头针各种属性然后marker.map = self.googleMapView就等于添加了一个大头针，没有回调 谷歌地图触发paopaoView的时候，调用 12345678910111213141516171819- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSMarker *myMarker = (XSMarker *)marker; XSLocationDetails *locationModel = myMarker.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; petAnnotationView.isHiddenNoNeeds = YES; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:locationModel.locationCoordinate2D completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@"%@, %@", firstString, lastString]; locationModel.deviceAddress = address; petAnnotationView.locationDetails = locationModel; // 地址转换处理重新刷新界面 &#125;]; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationModel; return petAnnotationView;&#125; 谷歌地图貌似没有可以获取地图上所有Marker的方法（可能我没找到），需要添加的时候自己维护一个数组 谷歌地图的反地理编码本来就是block回调 谷歌地图控制所有轨迹点范围的实现 12345678- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; bounds = [bounds includingCoordinate:locationDetails.locationCoordinate2D]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Farchives%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[之前在学习编程和开始工作的时候，也都有整理和写笔记的习惯，笔记一直是使用Gitbook编辑整理和同步的，也有想搭建一个自己的博客但是又因为自己太懒散，而且感觉搭建博客比较复杂，所以就一直没有付诸行动；直到最近偶然看到介绍使用Hexo + GitHubPages搭建博客的文章，就查了下相关的资料和介绍，搭建了一个简单的博客（GitHubPages + Hexo + Next主题）。 关于博客 常见的博客搭建方法（查到资料的） WordPress：一般需要独立域名（收费），传统的博客搭建方法，但是对MarkDown支持不是很好 GitHubPages + Jekell：免费，稍微比较麻烦 GitHubPages + Hexo：免费，使用简单，适合新手入门 关于Hexo Hexo 是一个基于 Nodejs 的静态博客网站生成器，作者是来自中国台湾的Tommy Chen。 作者网站 特点 部署方便且速度快 支持Markdown语法 已移植 Octopress 插件 高扩展性、自订性 兼容Windows, Mac &amp; Linux Hexo实现原理 1、Hexo是一个静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。 2、Hexo还有把生成好的站点上传到 Github Pages 的功能。 GitHubPages + Hexo搭建方法 关于使用可参考下面这两篇文章，写的非常详细，而且是针对Windows/Mac两个平台方法，就不在浪费时间码字了。 Mac搭建Hexo博客及NexT主题配置优化 博客搭建包含windows 常用的指令 12345hexo clean // 清空本地缓存，解决由于本地缓存导致部署无效hexo g // == hexo generate #生成静态网页gulp // 压缩生成的静态资料（如果安装gulp插件，具体安装方法见下面）hexo d // == hexo deploy #开始部署hexo s // == hexo server #启动服务器 本地调试使用 插件安装RSS订阅插件 执行如下指令 1npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20hub:content: 本地搜索插件 执行如下指令 1npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search:path: search.xmlfield: postformat: htmllimit: 10000 静态资源压缩插件 安装gulp 1npm install gulp -g // 如果报npm WARN deprecated警告 可使用npm install -g npm 安装gulp插件： 12345npm install gulp-minify-css --save // 如果报npm WARN deprecated警告则使用sudo npm install gulp-clean-css执行npm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 主题配置设置网站标签页favicon图标 图标格式：32 * 32 的ico格式图标，重命名为favicon.ico 把设计好的图标放在/themes/next/source/images里 修改主题配置文件medium 1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 更多配置可参考Hexo+Next个人博客主题优化 关于多电脑同步 使用电脑搭建好博客后可能面临如下问题 1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章 2、换了一台新的电脑（挣钱了要换装备😂） 3、电脑系统崩了😭 关于多电脑同步解决方案1 gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支） 每个电脑每次更新文章前需要正常的git同步操作 每个电脑每次更新文章后需要正常的git同步操作 但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂） 具体分支实现可参考利用分支同步 关于多电脑同步解决方案2 每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦） 通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的 目标电脑获取到最新的博客文件后 如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下 GitHub添加配置新电脑的SSH key 和搭建时一样参考Mac搭建Hexo博客及NexT主题配置优化 配置运行环境，执行如下指令 12brew install node // 安装Node.jsnpm install -g hexo // 安装hexo 切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件) 12345678910111213npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save npm install hexo-generator-searchdb --save npm install -g gulp npm install gulp-minify-css --save npm install gulp-uglify --save npm install gulp-htmlmin --save npm install gulp-htmlclean --save npm install gulp-imagemin --save 又可以愉快的随时随地写文章了😂 参考Mac搭建Hexo博客及NexT主题配置优化免费个人博客搭建详解Hexo+Next个人博客主题优化利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>整理</category>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>Hexo博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Farchives%2Fed2e9abb.html</url>
    <content type="text"><![CDATA[春日游，杏花吹满头。陌上谁家年少足风流？ 传统的软件开发模式需要经历问题评估、计划解决方案、设计系统架构、开发代码、测试、部署和使用系统、维护解决方案等过程。 如瀑布流模式: 它是以文档为驱动，在整个开发过程中，开发人员根据需求文档进行开发，一切以文档为依据。 缺点 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 各个软件生命周期衔接花费时间较长，团队人员交流成本大。 在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 软件开发的11种模式 敏捷开发(Agile Development) 什么是敏捷开发 1、敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方式。2、在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。3、它并不是一门技术，而是一种开发方式，是一种软件开发的流程。4、作用指导我们用规定的环节去一步一步完成项目的开发。因为它采用的是迭代式开发，所以这种开发方式的主要驱动核心是人。 敏捷开发适用于 客户不知道自己要啥的情况，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进； 竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要； 快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付； 适用于在一个地方办公的小团队，一般 10 个人以内。这样能使敏捷中主要的沟通方式「Face to Face」是可行的。 敏捷开发流程 敏捷开发实现方式 Scrum XP Scrum 项目角色 产品负责人（Product Owner）：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员（Scrum Master）：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队（Scrum Team）：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 XP（Extreme Programming）什么是XP 极限编程（eXtreme Programming），是一种全新的、轻量级的、灵巧的软件开发方法，是一种软件工程方法学。它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP的核心是沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）四大价值观，它们是XP的基础，也是XP的灵魂。敏捷开发之XP 敏捷开发中XP与SCRUM的区别 1、迭代长度的不同 XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周. 2、在迭代中, 是否允许修改需求 XP在一个迭代中，如果一个User Story(一个用户需求)还没有实现， 则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰 在迭代中，User Story是否严格按照优先级别来实现 XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做 Scrum这样处理的理由是：如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10. 3、软件的实施过程中，是否采用严格的工程方法，保证进度或者质量 Scrum没有对软件的整个实施过程开出个工程实践的处方，要求开发者自觉保证。 但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。]]></content>
      <categories>
        <category>整理</category>
        <category>敏捷开发</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编初识（Mac)]]></title>
    <url>%2Farchives%2F24e561e5.html</url>
    <content type="text"><![CDATA[Decompile class-dump安装方法当Mac升级了OSX 10.11后，配置class-dump的时候，会发现推荐的class-dump无法放入目录/usr/bin 原因是 OSX10.11的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限 其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。 关闭方法：开机的时候按住option出现选择磁盘的界面按command + R进入RecoveryMode，选择实用工具终端，输入csrutil disable回车搞定 class-dump下载地址 http://stevenygard.com/projects/class-dump/ 1、打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录。 2、把下载下来的dmg打开，复制文件文件里面的class-dump到创建的bin目录下。赋权限:chmod +x ~/bin/class-dump 3、打开bash_profile文件配置环境变量： * vim ~/.bash\_profile * 按下 i 键进入编辑状态，在最下方加一行`export PATH=$HOME/bin/:$PATH` * 按下esc键, 再按shift+: 输入 wq! 进行保存退出编辑 4、在Terminal中执行source ~/.bash_profile 5、执行class-dump测试是否成功，成功如下： 12345678910111213141516171819202122MelodydeMBP:~ melody$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt;where options are:-a show instance variable offsets-A show implementation addresses--arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)-C &lt;regex&gt; only display classes matching regular expression-f &lt;str&gt; find string in method name-H generate header files in current directory, or directory specified with -o-I sort classes, categories, and protocols by inheritance (overrides -s)-o &lt;dir&gt; output directory used for -H-r recursively expand frameworks and fixed VM shared libraries-s sort classes and categories by name-S sort methods by name-t suppress header in output, for testing--list-arches list the arches in the file, then exit--sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk--sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk--sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)MelodydeMBP:~ melody$ class-dump使用命令如下：1class-dump -H /Users/sevencho/Desktop/KYRemoteUnit.app -o /Users/sevencho/Desktop/headers -H 代表着要解析的文件 /Users/sevencho/Desktop/KYRemoteUnit.app 需要反编译的应用路径（解压.ipa包获得） -o 表示解析完成保存的目录 /Users/sevencho/Desktop/headers 反编译出的头文件存放路径 利用 class-dump 可以导出 AppKit，UIKitAppKit :1class-dump /System/Library/Frameworks/AppKit.framework UIKit :1class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework]]></content>
      <categories>
        <category>汇编</category>
        <category>汇编工具</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(二)]]></title>
    <url>%2Farchives%2Fb3b6a999.html</url>
    <content type="text"><![CDATA[绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 百度地图1、注册地图api key1234567// 在程序启动代理方法注册baidu map api key 百度开发者平台获取_mapManager = [[BMKMapManager alloc]init];// 如果要关注网络及授权验证事件，请设定 generalDelegate参数BOOL ret = [_mapManager start:XSBaiduMapApiKey generalDelegate:nil];if (!ret) &#123; XSLog(@&quot;BMKMapManager start failed!&quot;);&#125; 2、初始化地图 添加地图的初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)setupBaiduMapView&#123; BMKMapView *mapView = [[BMKMapView alloc] initWithFrame:self.view.bounds]; mapView.mapType = BMKMapTypeStandard; // 设定为标准地图 mapView.showsUserLocation = YES; mapView.userTrackingMode = BMKUserTrackingModeNone; // 设置用户位置图标类型 mapView.showMapScaleBar = YES; BMKLocationViewDisplayParam *displayParam = [[BMKLocationViewDisplayParam alloc] init]; displayParam.locationViewImgName = @&quot;icon_center_point&quot;; displayParam.isAccuracyCircleShow = NO; [mapView updateLocationViewWithParam:displayParam];// 配置用户位置信息如精度圈、图标 mapView.zoomLevel = kMapsZoomLevel; mapView.minZoomLevel = kMapsMinZoomLevel; mapView.maxZoomLevel = kMapsMaxZoomLevel; [self.view insertSubview:mapView atIndex:0]; self.baiduMapView = mapView; // 定位服务 BMKLocationService *locService = [[BMKLocationService alloc] init]; locService.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; [locService startUserLocationService]; self.locService = locService; // 反地理编码 BMKGeoCodeSearch *geoCodeSearch = [[BMKGeoCodeSearch alloc] init]; self.geoCodeSearch = geoCodeSearch; // 针对切换地图类型后设置代理 （如果有做地图切换功能） self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillAppear:(BOOL)animated&#123; [self.baiduMapView viewWillAppear]; self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [self.baiduMapView viewWillDisappear]; self.baiduMapView.delegate = nil; // 不用时，置nil self.locService.delegate = nil; self.geoCodeSearch.delegate = nil;&#125; 开启定位服务回调，更新用户位置信息 1234567891011-(void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123; XSLog(@&quot;didUpdateBMKUserLocation位置 : %f,%f&quot;, userLocation.location.coordinate.latitude, userLocation.location.coordinate.longitude); [self.baiduMapView updateLocationData:userLocation]; self.userBaiduLocation = userLocation;&#125;- (void)didFailToLocateUserWithError:(NSError *)error&#123; XSLog(@&quot;error:%@&quot;, error);&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupBaiduMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728- (void)setupBaiduMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.baiduMapView setCenterCoordinate:coordinate animated:YES]; // 添加大头针模型数据 self.pointAnnotation.annotationType = XSAnnotationTypeLocationPoint; self.pointAnnotation.locationDetailsModel = self.locationDetails; self.pointAnnotation.coordinate = coordinate; [self.baiduMapView addAnnotation:self.pointAnnotation]; // 添加精度圈 !self.baiduAccuracyCircle ? : [self.baiduMapView removeOverlay:self.baiduAccuracyCircle]; // 移除添加的精度圈 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs || self.locationDetails.GpsType == XSLocationModeLbs) &#123; // wifi 显示精度圈 self.baiduAccuracyCircle = [BMKCircle circleWithCenterCoordinate:coordinate radius:self.locationDetails.Radius]; [self.baiduMapView addOverlay:self.baiduAccuracyCircle]; &#125; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; if (![self.geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@&quot;百度反地理编码获取地址失败&quot;); &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.baiduMapView.zoomLevel &lt;= kMapsMinZoomLevel) &#123; return; &#125; BMKCoordinateRegion region = BMKCoordinateRegionMakeWithDistance(coordinate, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2); [self.baiduMapView setRegion:region animated:YES];&#125; 自定义大头针模型XSPointAnnotation继承自BMKPointAnnotation 扩充两个属性： annotationType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 12345CLLocationCoordinate2D leftCoor = [self.baiduMapView convertPoint:CGPointMake(0, XSScreenH) toCoordinateFromView:self.view];CLLocationCoordinate2D rightCoor = [self.baiduMapView convertPoint:CGPointMake(XSScreenW, XSScreenH) toCoordinateFromView:self.view];BMKMapPoint pointLeft = BMKMapPointForCoordinate(leftCoor);BMKMapPoint pointRight = BMKMapPointForCoordinate(rightCoor);return BMKMetersBetweenMapPoints(pointLeft, pointRight); 3.4、配置信息的回调（真正开始处理显示位置大头针、精度圈、点击显示的弹框泡泡） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 大头针及大头针弹框- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; XSLogFunc if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;LocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;LocationAnnotation&quot;]; &#125; annotationView.image = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; annotationView.draggable = NO; annotationView.canShowCallout = YES; // 自定义的点击大头针显示的气泡View 根据公司需求自定义 self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; // 需要显示的设备信息模型 self.petAnnotationView.isHiddenNoNeeds = NO; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; &#125; return annotationView;&#125;// 精度圈- (BMKOverlayView *)mapView:(BMKMapView *)mapView viewForOverlay:(id &lt;BMKOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[BMKCircle class]])&#123; BMKCircleView *circleView = [[BMKCircleView alloc] initWithOverlay:overlay]; if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; circleView.lineWidth = 1; return circleView; &#125; return nil;&#125;// 百度反地理编码解析地址回调，需要重新刷新大头针的气泡模型数据- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLog(@&quot;address:%@----%@&quot;, result.addressDetail, result.address); self.locationDetails.deviceAddress = result.address; self.petAnnotationView.locationDetails = self.locationDetails;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)baiduMapViewFitAnnotationsWithCoordinates:(CLLocationCoordinate2D *)coords count:(NSUInteger)count&#123; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES]; // if (count &lt; 2) return;// CLLocationCoordinate2D coor = [coordsModels.firstObject coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// CGFloat ltX, ltY, rbX, rbY;// ltX = pt.x, ltY = pt.y;// rbX = pt.x, rbY = pt.y;//// for (int i = 1; i &lt; count; i++) &#123;// CLLocationCoordinate2D coor = [coordsModels[i] coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// if (pt.x &lt; ltX) ltX = pt.x;// if (pt.x &gt; rbX) rbX = pt.x;// if (pt.y &gt; ltY) ltY = pt.y;// if (pt.y &lt; rbY) rbY = pt.y;// &#125;// BMKMapRect rect;// rect.origin = BMKMapPointMake(ltX , ltY);// rect.size = BMKMapSizeMake(rbX - ltX, rbY - ltY);// [self.baiduMapView setVisibleMapRect:rect];// self.baiduMapView.zoomLevel = self.baiduMapView.zoomLevel - 0.3;&#125; 谷歌地图1、注册地图api key12// 在程序启动代理方法注册google map api key 谷歌开发者平台获取[GMSServices provideAPIKey:kGoogleMapApiKey]; 2、初始化地图123456789101112- (void)setupGoogleMapView&#123; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:0 longitude:0 zoom:kMapsZoomLevel]; GMSMapView *mapView = [GMSMapView mapWithFrame:CGRectMake(0, 0, XSScreenW, XSScreenH) camera:camera]; mapView.delegate = self; mapView.myLocationEnabled = YES; [mapView setMinZoom:kMapsMinZoomLevel maxZoom:kMapsMaxZoomLevel]; mapView.settings.compassButton = YES; mapView.settings.consumesGesturesInView = NO; [self.view insertSubview:mapView atIndex:0]; self.googleMapView = mapView;&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupGoogleMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)setupGoogleMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.googleMapView animateToLocation:coordinate]; // Creates a marker in the center of the map. self.marker.markerType = XSMarkerTypeDefaultLocation; self.marker.position = coordinate; self.marker.appearAnimation = YES; self.marker.tracksInfoWindowChanges = YES; self.marker.icon = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; self.marker.map = self.googleMapView; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 // 点击大头针显示的自定义气泡控件 懒加载 self.petAnnotationView.locationDetails = self.locationDetails; self.petAnnotationView.isHiddenNoNeeds = NO; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:coordinate completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; //FIXME: 错误信息处理 // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@&quot;%@, %@&quot;, firstString, lastString]; self.locationDetails.deviceAddress = address; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 self.petAnnotationView.locationDetails = self.locationDetails; &#125;]; // 添加精度圈 self.googleAccuracycircle.map = nil; // 清空已存在的 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; // wifi 显示精度圈 self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.googleMapView.camera.zoom &lt;= kMapsMinZoomLevel) &#123; return; &#125; int zoomLevel = self.googleMapView.camera.zoom;// double radius = self.locationDetails.Radius + self.locationDetails.Radius / 2; double radius = self.locationDetails.Radius / 2; double scale = radius / 500; zoomLevel = (int) (16 - log(scale) / log(2)); zoomLevel--; [CATransaction begin]; [CATransaction setValue:[NSNumber numberWithFloat:XSAnimationDuration] forKey:kCATransactionAnimationDuration]; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:coordinate.latitude longitude:coordinate.longitude zoom:zoomLevel]; [self.googleMapView animateToCameraPosition:camera]; [CATransaction commit];&#125; 自定义大头针模型XSMarker继承自GMSMarker 扩充两个属性： markerType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 123CLLocationCoordinate2D leftCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(0, XSScreenH)];CLLocationCoordinate2D rightCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(XSScreenW, XSScreenH)];return GMSGeometryDistance(leftCoor, rightCoor); 3.4、点击大头针显示气泡view的回调 1234567- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSLogFunc self.petAnnotationView.width = 270; self.petAnnotationView.locationDetails = self.locationDetails; // 刷新显示的信息 return self.petAnnotationView;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (int i = 1; i &lt; count; i++) &#123; CLLocationCoordinate2D coor = [coordsModels[i] locationCoordinate2D]; bounds = [bounds includingCoordinate:coor]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125; Maps 导航 检测是否安装对应的地图 常用的4个地图的 URL Scheme: 1.苹果自带地图（不需要检测，所以不需要URL Scheme）2.百度地图 ：baidumap://3.高德地图 ：iosamap://4.谷歌地图 ：comgooglemaps:// 在IOS9之后，苹果进一步完善了安全机制，必须在plist里面设置url scheme白名单，不然无法打开对应的应用 添加白名单： 在 info.plist 文件里面，添加一个字段：LSApplicationQueriesSchemes，类型为数组 然后在这个数组里面再添加我们所需要的地图 URL Scheme : 1234&gt; baidumap // 百度&gt; iosamap // 高德&gt; comgooglemaps // 谷歌&gt; 应用内部调用google maps地图发起导航功能 1、x-source=%@&amp;x-success=%@跟高德一样 这里分别代表APP的名称和URL Scheme 2、saddr=这里留空则表示从当前位置触发。 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;comgooglemaps://&quot;]]) &#123; NSMutableDictionary *googleMapDic = [NSMutableDictionary dictionary]; googleMapDic[@&quot;title&quot;] = @&quot;谷歌地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;comgooglemaps://?x-source=%@&amp;x-success=%@&amp;saddr=&amp;daddr=%f,%f&amp;directionsmode=driving&quot;,@&quot;导航测试&quot;,@&quot;nav123456&quot;,endLocation.latitude, endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; googleMapDic[@&quot;url&quot;] = urlString; [maps addObject:googleMapDic];&#125; 应用内部调用百度地图发起导航功能 1，origin=, 这个是不能被修改的，不然无法把出发位置设置为当前位置 2，destination = latlng:%f,%f|name = 目的地这里面的 name 的字段不能省略，否则导航会失败，而后面的文字则可以随意，赋个你的目的地的值给他就可以了。 3，coord_type = gcj02coord_type 允许的值为 bd09ll、gcj02、wgs84，如果你 APP 的地图 SDK 用的是百度地图 SDK，请填 bd09ll，否则就填gcj02，wgs84的话基本是用不上了 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;baidumap://&quot;]]) &#123; NSMutableDictionary *baiduMapDic = [NSMutableDictionary dictionary]; baiduMapDic[@&quot;title&quot;] = @&quot;百度地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=北京&amp;mode=driving&amp;coord_type=gcj02&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; baiduMapDic[@&quot;url&quot;] = urlString; [maps addObject:baiduMapDic];&#125; 应用内部调用高德地图发起导航功能 1、sourceApplication=%@&amp;backScheme=%@sourceApplication代表你自己APP的名称 会在之后跳回的时候显示出来 所以必须填写 backScheme是你APP的URL Scheme 不填是跳不回来的哟 2、dev=0这里填0就行了，跟上面的gcj02一个意思 1代表wgs84 也用不上 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;iosamap://&quot;]]) &#123; NSMutableDictionary *gaodeMapDic = [NSMutableDictionary dictionary]; gaodeMapDic[@&quot;title&quot;] = @&quot;高德地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;iosamap://navi?sourceApplication=%@&amp;backScheme=%@&amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2&quot;,@&quot;导航功能&quot;,@&quot;nav123456&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; gaodeMapDic[@&quot;url&quot;] = urlString; [maps addObject:gaodeMapDic];&#125; 应用内部调用苹果地图发起导航功能 123456CLLocationCoordinate2D loc = CLLocationCoordinate2DMake([self.model.latitude floatValue], [self.model.longitude floatValue]);MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:loc addressDictionary:nil]];[MKMapItem openMapsWithItems:@[currentLocation, toLocation]launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(一)]]></title>
    <url>%2Farchives%2F1c8732fb.html</url>
    <content type="text"><![CDATA[赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。 地图坐标体系1.WGS－84原始坐标系 一般用国际GPS纪录仪记录下来的经纬度 通过GPS定位拿到的原始经纬度 Google（国外）、高德地图（国外）、OSM地图定位的的经纬度。 但是在国内是不允许直接用WGS84坐标系标注的，必须经过加密后才能使用 注意：国内不允许直接使用，但是GPS设备上传的数据还是标准的数据，国内使用需要转为GCJ－02坐标 2.GCJ－02坐标系 GCJ－02坐标系又名“火星坐标系”，是我国国测局独创的坐标体系，由WGS－84加密而成。 在国内，必须至少使用GCJ－02坐标系，如高德和Google在国内。 或者使用在GCJ－02加密后再进行加密的坐标系，如百度坐标系。 3.百度坐标系:bd-09 百度坐标系是在GCJ－02坐标系的基础上再次加密偏移后形成的坐标系，只适用于百度地图。 国内地图偏移问题 地图偏移问题一般只有在国内才会出现 国内‘标准’GPS设备定位坐标为GCJ－02坐标系，显示地图为偏移过的地图，最终显示的为准确的位置国内非’标准’的设备定位坐标为WGS－84原始坐标系，显示地图为偏移过的地图，最终显示的位置出现偏移 Google MapsGoogle Maps注意点 自定义弹窗可以直接使用InfoWindow 调整地图上面的图标位置 没办法可以直接调整每一个图标的位置 可以设置地图的内容padding属性来调整 但是padding属性设置局限于调整和屏幕边缘的距离 刷新地图弹框内容可以设置自动刷新帧的间隔（对应有的不需要变化的控件可以关闭以节约性能） 添加手势会和地图的手势冲突，需要设置地图的consumesGesturesInView为false consumesGesturesInView手势控制是否用户设置的手势被谷歌地图接管处理默认设置为YES 定位点的自定义弹框 每一个定位点对象GMSMarker 如果想要自定义弹框可以在下面方法实现 (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker 如果想要刷新地图弹框的内容, 需要在设置Marker的方法里直接转换坐标，并且实时位置的自定义弹框需要全局是一个控件，否则无法刷新控件 markerInfoWindow：方法只需要初始化控件即可，在获取到数据设置GMSMarker的方法里传递数据 想要刷新数据要设置 tracksInfoWindowChanges = YES 在国内直接使用GPS原始坐标显示在地图上面会有偏移 可以使用网上别人c语言写的一些纠偏算法，纠偏后偏移不是很大（纠偏只针对国内，可以使用经纬度区分国内还是国外的区域，不是非常准确） 高德地图和百度地图SDK里面有提供国内外区域判断的Api，提供一个坐标点判断是在国内还是在国外 Google Maps 收费 The Google Maps Geolocation API 普通用户 每天可以调用2500次，每秒调用50次 超过后按每1000次/0.5美元收费（还是有调用限制：每天上限:100000次） 高级用户 高级用户需要和Google公司联系，可以按协议付费提高调用次数限制 但是只能针对国外的公司（不对国内公司提供服务），账单付费也必须是国外的公司 解决方法 （调用高德服务） 高德地图针对没有开发对应的iOS和Android的客户端的智能硬件产品的企业用户, 提供智能硬件定位服务，支持通过服务端上传WIFI和基站信息进行定位并获取经纬度。 需要开发者账号注册为企业用户 免费调用限制为3000000次/每天 同Google Maps Geolocation API 将设备GPS获取到的Wifi和Lb数据或者Cell Tower数据转换为对应的经纬度信息 高德转出来的为GCJ－02坐标体系（火星坐标） 有国外的数据支持，但是具体的精准的还需要再测试 地图坐标体系转换 地图的SDK一般会提供其他地图坐标体系到自身体系的转换接口 但是 均不提供从自身向其他坐标体系转换 google SDK没有坐标转换接口 别人写的转换方法、有误差 https://github.com/JackZhouCn/JZLocationConverter 别人写的服务器（C#版）坐标转换 https://www.jianshu.com/p/8975586a820e]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew介绍]]></title>
    <url>%2Farchives%2F4f2aa8f3.html</url>
    <content type="text"><![CDATA[iOS开发工具之Homebrew篇Homebrew官网 https://brew.sh/index_zh-cn.htmlHomebrew 是基于 OS X 的套件管理工具，是一个开源的 Ruby 脚本，专门用于快速下载软件 Homebrew 类似于一个软件中心，可以理解成 App Store 或者 Google Play 那样的软件商店, 且内容更加丰富; Homebrew Cask，它是一套建立在 Homebrew 基础之上的 OS X 软件安装命令行工具，是 Homebrew 的扩展;使用Homebrew有什么优势呢? 通过 Homebrew 下载安装的软件全部来自对应的软件官网，无需担心下载源的安全问题; 依存于系统既有的库，减少了空间占用和冗余; 使用 Git 进行管理和更新; 易于定制; Homebrew 使用： 安装软件 brew cask install 软件名 1brew cask install google-chrome 卸载软件 brew cask uninstall 软件名 1brew cask uninstall google-chrome 软件搜索 brew cask search 软件名 1brew cask search google 查看软件相关信息 brew cask info 软件名 1brew cask info google-chrome 删除 Homebrew Cask 下载的包 1brew cask cleanup 列出通过 Homebrew Cask 安装的包 1brew cask list 更新 Homebrew Cask 1brew cask update Homebrew 安装QuickLook常用的插件QuickLook插件http://www.quicklookplugins.com/ brew cask install qlmarkdown // 预览Markdown QLColorCode // 代码块高亮 QuickLook-JSON // JSON 文件 QLPrettyPatch // Patch 文件 qlvideo // 视频预览 QLStephen // 预览无拓展名的纯文本文件 BetterZipQL // 查看 Zip 压缩文件的信息以及文件目录 QLImageSize // 预览窗口的标题栏中显示图片分辨率及文件大小，并在 Finder 中显示图片的格式; 还支持 bpg、Portable Pixmap、WebP 格式 QuickLook-CSV // 预览 CSV 文件 qladdict // .srt (Subtitle)]]></content>
      <categories>
        <category>工具</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB介绍]]></title>
    <url>%2Farchives%2Fc9e6c86c.html</url>
    <content type="text"><![CDATA[iOS开发工具之LLDB介篇 LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。 安装Chisel Facebook 开源的 lldb 插件 Chisel. 1、Chisel 使用 homebrew 来安装，如果你没有安装homebrew 12brew updatebrew install chisel 2、安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下： 123==&gt; CaveatsAdd the following line to ~/.lldbinit to load chisel when Xcode launches:command script import /usr/local/opt/chisel/libexec/fblldb.py 3、然后重启Xcode 常用的调试指令pjson 打印json格式数据，调试服务器返回数据时候用。 p/x 打印16进制数据 p/t 打印2进制数据 e 修改属性和调用方法 pviews 这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription]。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。 pvc 个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy]同样的效果。 visualize 这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。 fv &amp; fvc fv和 fvc这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。 show &amp; hide 这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder 这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush 这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。 当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。 bmessage 这个命令就是用来打断点用的了，虽然大家断点可能都喜欢在图形界面里面打，但是考虑一种情况：我们想在[MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear:方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。 那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： (lldb) bmessage -[MyViewController viewWillAppear:]上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]] help 可以用帮助文档查看所有的指令或者单个指令的使用方法 常用的Debug快捷键1234567891011121314151617cmd + ctrl + Y // 暂停/继续cmd + Y // 断点失效/生效cmd + shift + Y // 控制台显示/隐藏cmd + shift + C // 光标切换到控制台cmd + K // 清空控制台continue \(c\) // 继续执行step over F6 （n） // 单步执行step into F7（s） // 跳入step out F8 （finish）// 跳出]]></content>
      <categories>
        <category>工具</category>
        <category>LLDB</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM介绍]]></title>
    <url>%2Farchives%2F1c40fe4d.html</url>
    <content type="text"><![CDATA[iOS开发工具之VIM篇VIM相关的指令 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 打开12345vim 直接启动vimvim filename 打开vim并创建名为filename的文件 // 打开单个文件vim file1 file2 file3 … // 打开多个文件:open file // 在vim窗口中打开一个新文件:split file // 在新窗口中打开文件 退出指令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi:q 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insertmode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式(command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile * 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： 12345: w filename // （输入 「w filename」将文章以指定的文件名filename保存）: wq // (输入「wq」，存盘并退出vi): q! // (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符 「dd」：删除光标所在行 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 6）. 替换 「r」：替换光标所在处的字符 「R」：替换光标所到之处的字符，直到按下「ESC」键为止 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作 、按多次“u”可以执行多次回复 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号 「#G」：例如，「15G」，表示移动光标至文章的第15行行首 4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件 5、vi命令列表 1、下表列出命令模式下的一些键的功能： 123456789101112131415161718192021222324252627282930h 左移光标一个字符h 左移光标一个字符k 光标上移一行j 光标下移一行^ 光标移动至行首0 数字“0”，光标移至文章的开头G 光标移至文章的最后$ 光标移动至行尾Ctrl+f 向前翻屏Ctrl+b 向后翻屏Ctrl+d 向前翻半屏Ctrl+u 向后翻半屏i 在光标位置前插入字符a 在光标所在位置的后一个字符开始增加o 插入新的一行，从行首开始输入ESC 从输入状态退至命令状态x 删除光标后面的字符#x 删除光标后的＃个字符X (大写X) 删除光标前面的字符#X 删除光标前面的#个字符dd 删除光标所在的行#dd 删除从光标所在行数的#行yw 复制光标所在位置的一个字# yw复制光标所在位置的#个字yy 复制光标所在位置的一行#yy 复制从光标所在行数的#行p 粘贴u 取消操作cw 更改光标所在位置的一个字#cw 更改光标所在位置的#个字 2、下表列出行命令模式下的一些指令 123456w filename 储存正在编辑的文件为filenamewq filename 储存正在编辑的文件为filename，并退出viq! 放弃所有修改，退出viset nu 显示行号/或? 查找，在/后输入要查找的内容n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。 切换放方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之AppStore篇]]></title>
    <url>%2Farchives%2F9b9b2c59.html</url>
    <content type="text"><![CDATA[iOS开发之AppStore篇– 上架图片尺寸 需要一张通用的1024 x 1024 在App Store里面用 （xcode9 之前在App Store里面上传；xcode9之后在开发工具里面配置） 其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间 不能包含图层或圆角 不能有透明像素和alpha通道 桌面图标 (app icon) for iPhone6 plus(@3x) : 180 x 180 // 命名规范：App-60@3x for iPhone 6/5s/5/4s/4(@2x) : 120 x 120 // 命名规范：App-60@2x 系统搜索框图标 (Spotlight search results icon) for iPhone6 plus(@3x) : 120 x 120 // 命名规范：Spotlight-40@3x for iPhone6/5s/5/4s/4(@2x) : 80 x 80 // 命名规范：Spotlight-40@2x 系统设置图标 (Settings icon) for iPhone6 plus(@3x) : 87 x 87 // 命名规范：Settings-29@3x for iPhone6/5s/5/4s/4(@2x) : 58 x 58 // 命名规范：Settings-29@2x 启动图片 (launch image) for iPhoen5s/5(@2x) : 640 x 1136 // 命名规范：LaunchImage-568h@2x for iPhone 6(@2x) : 750 x 1334 // 命名规范： LaunchImage-667h@2x for iPhone 6 plus (@3x) : 1242 x 2208 // 命名规范： LaunchImage-736h@3x for iPhoneX (@3x) : 1125 x 2436 // 命名规范： LaunchImage-812h@3x 预览和屏幕快照关于App Store上架电脑系统是测试版或者Xcode是测试版 打包上传出错报如下错误代码，最后通过重装系统（正式版）解决 注意即使用测试版系统或者Xcode打包的程序上传成功、最后上传到AppStore审核的时候也有可能被拒 1ERROR ITMS-90167: &quot;No .app bundles found in the package&quot; 项目中有静态库不支持bitcode上架打包错误1‘xxx/lib**SDK.a(**ForSDK.o)’does not contain bitcode. You must rebuild it with bitcode enabled (Xcodesetting ENABLE_BITCODE), obtain an updated library from the vendor, or disablebitcode for this target. for architecture arm64 解决方法 重新打包静态库，使之支持bitcode 如果静态库比较老，没法重新编译，就需要关闭xcode的bitcode功能 Target -&gt; Build Settings -&gt; Bulid option : Enable Bitcode 设置为NO 项目中有设置URL Schemes1error itms-90158: &quot;the following url schemes found in your app are not in the current format:[mqq://]. 可能是跳转的app id 不正确 app审核通过后AppStore依然搜索不到解决办法 偶尔审核通过但是搜索不到，一般是DNS缓存问题 需要等待苹果服务器刷新 可以通过下面的方法加速刷新 在价格与销售范围里面修改：价格 —&gt; 等级1（收费即可）、销售地区 全部取消只选择 -&gt; 中国, 保存，此时刷新app审核状态就会变为 pending contract（协商价格） 然后再在价格与销售范围里面修改：价格 —&gt; 等级0（app原来的价格 我这里是免费）、销售地区 全部选择 -&gt; 所有地区, 保存，此时刷新app审核状态就会变为 Ready for sale（可供销售） 等待大概半个到一个小时就可以在AppStore里面搜索到了 打包上传后再iTunes connect后台一直看不到上传的包文件 可能是info.plist里面需要配置的申请权限没有配置，这时会收到APPle发送的邮件解释的很清楚，但是有时可能appleID账号是老板的私人邮箱，老板收到又没有及时转发给你，这时候就要找老板问下是否有接收到邮件。 关于游客账户 除社交、和财产挂钩等app可以只提供注册后登录，其他app应视情况提供游客登录模式，在应用内限制游客账户的功能 如果不提供游客账号登录功能一般不会出问题，但是主要看人品，不能确定哪一版本就给拒了App Store 审核指南（中文） 关于和硬件相关的app 我们公司大部分都是和单片机等通讯的硬件产品，关于这类app，上架后需要录制软件和硬件的操作交互视频上传YouTube（建议）或者youku等平台，然后在iTunes connect 里面提供上传视频连接以供审核。]]></content>
      <categories>
        <category>iOS</category>
        <category>App Store</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Store</tag>
      </tags>
  </entry>
</search>
