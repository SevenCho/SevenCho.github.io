<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Farchives%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[之前在学习编程和开始工作的时候，也都有整理和写笔记的习惯，笔记一直是使用Gitbook编辑整理和同步的，也有想搭建一个自己的博客但是又因为自己太懒散，而且感觉搭建博客比较复杂，所以就一直没有付诸行动；直到最近偶然看到介绍使用Hexo + GitHubPages搭建博客的文章，就查了下相关的资料和介绍，搭建了一个简单的博客（GitHubPages + Hexo + Next主题）。 关于博客 常见的博客搭建方法（查到资料的） WordPress：一般需要独立域名（收费），传统的博客搭建方法，但是对MarkDown支持不是很好 GitHubPages + Jekell：免费，稍微比较麻烦 GitHubPages + Hexo：免费，使用简单，适合新手入门 关于Hexo Hexo 是一个基于 Nodejs 的静态博客网站生成器，作者是来自中国台湾的Tommy Chen。 作者网站 特点 部署方便且速度快 支持Markdown语法 已移植 Octopress 插件 高扩展性、自订性 兼容Windows, Mac &amp; Linux Hexo实现原理 1、Hexo是一个静态博客生成器，根据给定的主题，负责把写好的 Markdown 文章转换成一堆 HTML + CSS + Javascript 页面。 2、Hexo还有把生成好的站点上传到 Github Pages 的功能。 GitHubPages + Hexo搭建方法 关于使用可参考下面这两篇文章，写的非常详细，而且是针对Windows/Mac两个平台方法，就不在浪费时间码字了。 Mac搭建Hexo博客及NexT主题配置优化 博客搭建包含windows 常用的指令 12345hexo clean // 清空本地缓存，解决由于本地缓存导致部署无效hexo g // == hexo generate #生成静态网页gulp // 压缩生成的静态资料（如果安装gulp插件，具体安装方法见下面）hexo d // == hexo deploy #开始部署hexo s // == hexo server #启动服务器 本地调试使用 插件安装RSS订阅插件 执行如下指令 1npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20hub:content: 本地搜索插件 执行如下指令 1npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search:path: search.xmlfield: postformat: htmllimit: 10000 静态资源压缩插件 安装gulp 1npm install gulp -g // 如果报npm WARN deprecated警告 可使用npm install -g npm 安装gulp插件： 12345npm install gulp-minify-css --save // 如果报npm WARN deprecated警告则使用sudo npm install gulp-clean-css执行npm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 主题配置设置网站标签页favicon图标 图标格式：32 * 32 的ico格式图标，重命名为favicon.ico 把设计好的图标放在/themes/next/source/images里 修改主题配置文件medium 1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 更多配置可参考Hexo+Next个人博客主题优化 关于多电脑同步 使用电脑搭建好博客后可能面临如下问题 1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章 2、换了一台新的电脑（挣钱了要换装备😂） 3、电脑系统崩了😭 关于多电脑同步解决方案1 gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支） 每个电脑每次更新文章前需要正常的git同步操作 每个电脑每次更新文章后需要正常的git同步操作 但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂） 具体分支实现可参考利用分支同步 关于多电脑同步解决方案2 每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦） 通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的 目标电脑获取到最新的博客文件后 如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下 GitHub添加配置新电脑的SSH key 和搭建时一样参考Mac搭建Hexo博客及NexT主题配置优化 配置运行环境，执行如下指令 12brew install node // 安装Node.jsnpm install -g hexo // 安装hexo 切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件) 12345678910111213npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save npm install hexo-generator-searchdb --save npm install -g gulp npm install gulp-minify-css --save npm install gulp-uglify --save npm install gulp-htmlmin --save npm install gulp-htmlclean --save npm install gulp-imagemin --save 又可以愉快的随时随地写文章了😂 参考Mac搭建Hexo博客及NexT主题配置优化免费个人博客搭建详解Hexo+Next个人博客主题优化利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>整理</category>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>Hexo博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2Farchives%2Fed2e9abb.html</url>
    <content type="text"><![CDATA[春日游，杏花吹满头。陌上谁家年少足风流？ 传统的软件开发模式需要经历问题评估、计划解决方案、设计系统架构、开发代码、测试、部署和使用系统、维护解决方案等过程。 如瀑布流模式: 它是以文档为驱动，在整个开发过程中，开发人员根据需求文档进行开发，一切以文档为依据。 缺点 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 各个软件生命周期衔接花费时间较长，团队人员交流成本大。 在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 软件开发的11种模式 敏捷开发(Agile Development) 什么是敏捷开发 1、敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方式。2、在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。3、它并不是一门技术，而是一种开发方式，是一种软件开发的流程。4、作用指导我们用规定的环节去一步一步完成项目的开发。因为它采用的是迭代式开发，所以这种开发方式的主要驱动核心是人。 敏捷开发适用于 客户不知道自己要啥的情况，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进； 竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要； 快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付； 适用于在一个地方办公的小团队，一般 10 个人以内。这样能使敏捷中主要的沟通方式「Face to Face」是可行的。 敏捷开发流程 敏捷开发实现方式 Scrum XP Scrum 项目角色 产品负责人（Product Owner）：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员（Scrum Master）：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队（Scrum Team）：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 XP（Extreme Programming）什么是XP 极限编程（eXtreme Programming），是一种全新的、轻量级的、灵巧的软件开发方法，是一种软件工程方法学。它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP的核心是沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）四大价值观，它们是XP的基础，也是XP的灵魂。敏捷开发之XP 敏捷开发中XP与SCRUM的区别 1、迭代长度的不同 XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周. 2、在迭代中, 是否允许修改需求 XP在一个迭代中，如果一个User Story(一个用户需求)还没有实现， 则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰 在迭代中，User Story是否严格按照优先级别来实现 XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做 Scrum这样处理的理由是：如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10. 3、软件的实施过程中，是否采用严格的工程方法，保证进度或者质量 Scrum没有对软件的整个实施过程开出个工程实践的处方，要求开发者自觉保证。 但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。]]></content>
      <categories>
        <category>整理</category>
        <category>敏捷开发</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编初识（Mac)]]></title>
    <url>%2Farchives%2F24e561e5.html</url>
    <content type="text"><![CDATA[Decompile class-dump安装方法当Mac升级了OSX 10.11后，配置class-dump的时候，会发现推荐的class-dump无法放入目录/usr/bin 原因是 OSX10.11的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限 其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。 关闭方法：开机的时候按住option出现选择磁盘的界面按command + R进入RecoveryMode，选择实用工具终端，输入csrutil disable回车搞定 class-dump下载地址 http://stevenygard.com/projects/class-dump/ 1、打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录。 2、把下载下来的dmg打开，复制文件文件里面的class-dump到创建的bin目录下。赋权限:chmod +x ~/bin/class-dump 3、打开bash_profile文件配置环境变量： * vim ~/.bash\_profile * 按下 i 键进入编辑状态，在最下方加一行`export PATH=$HOME/bin/:$PATH` * 按下esc键, 再按shift+: 输入 wq! 进行保存退出编辑 4、在Terminal中执行source ~/.bash_profile 5、执行class-dump测试是否成功，成功如下： 12345678910111213141516171819202122MelodydeMBP:~ melody$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt;where options are:-a show instance variable offsets-A show implementation addresses--arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)-C &lt;regex&gt; only display classes matching regular expression-f &lt;str&gt; find string in method name-H generate header files in current directory, or directory specified with -o-I sort classes, categories, and protocols by inheritance (overrides -s)-o &lt;dir&gt; output directory used for -H-r recursively expand frameworks and fixed VM shared libraries-s sort classes and categories by name-S sort methods by name-t suppress header in output, for testing--list-arches list the arches in the file, then exit--sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk--sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk--sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)MelodydeMBP:~ melody$ class-dump使用命令如下：1class-dump -H /Users/sevencho/Desktop/KYRemoteUnit.app -o /Users/sevencho/Desktop/headers -H 代表着要解析的文件 /Users/sevencho/Desktop/KYRemoteUnit.app 需要反编译的应用路径（解压.ipa包获得） -o 表示解析完成保存的目录 /Users/sevencho/Desktop/headers 反编译出的头文件存放路径 利用 class-dump 可以导出 AppKit，UIKitAppKit :1class-dump /System/Library/Frameworks/AppKit.framework UIKit :1class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework]]></content>
      <categories>
        <category>汇编</category>
        <category>汇编工具</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(二)]]></title>
    <url>%2Farchives%2Fb3b6a999.html</url>
    <content type="text"><![CDATA[绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 百度地图1、注册地图api key1234567// 在程序启动代理方法注册baidu map api key 百度开发者平台获取_mapManager = [[BMKMapManager alloc]init];// 如果要关注网络及授权验证事件，请设定 generalDelegate参数BOOL ret = [_mapManager start:XSBaiduMapApiKey generalDelegate:nil];if (!ret) &#123; XSLog(@&quot;BMKMapManager start failed!&quot;);&#125; 2、初始化地图 添加地图的初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)setupBaiduMapView&#123; BMKMapView *mapView = [[BMKMapView alloc] initWithFrame:self.view.bounds]; mapView.mapType = BMKMapTypeStandard; // 设定为标准地图 mapView.showsUserLocation = YES; mapView.userTrackingMode = BMKUserTrackingModeNone; // 设置用户位置图标类型 mapView.showMapScaleBar = YES; BMKLocationViewDisplayParam *displayParam = [[BMKLocationViewDisplayParam alloc] init]; displayParam.locationViewImgName = @&quot;icon_center_point&quot;; displayParam.isAccuracyCircleShow = NO; [mapView updateLocationViewWithParam:displayParam];// 配置用户位置信息如精度圈、图标 mapView.zoomLevel = kMapsZoomLevel; mapView.minZoomLevel = kMapsMinZoomLevel; mapView.maxZoomLevel = kMapsMaxZoomLevel; [self.view insertSubview:mapView atIndex:0]; self.baiduMapView = mapView; // 定位服务 BMKLocationService *locService = [[BMKLocationService alloc] init]; locService.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; [locService startUserLocationService]; self.locService = locService; // 反地理编码 BMKGeoCodeSearch *geoCodeSearch = [[BMKGeoCodeSearch alloc] init]; self.geoCodeSearch = geoCodeSearch; // 针对切换地图类型后设置代理 （如果有做地图切换功能） self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillAppear:(BOOL)animated&#123; [self.baiduMapView viewWillAppear]; self.baiduMapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放 self.locService.delegate = self; self.geoCodeSearch.delegate = self;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [self.baiduMapView viewWillDisappear]; self.baiduMapView.delegate = nil; // 不用时，置nil self.locService.delegate = nil; self.geoCodeSearch.delegate = nil;&#125; 开启定位服务回调，更新用户位置信息 1234567891011-(void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123; XSLog(@&quot;didUpdateBMKUserLocation位置 : %f,%f&quot;, userLocation.location.coordinate.latitude, userLocation.location.coordinate.longitude); [self.baiduMapView updateLocationData:userLocation]; self.userBaiduLocation = userLocation;&#125;- (void)didFailToLocateUserWithError:(NSError *)error&#123; XSLog(@&quot;error:%@&quot;, error);&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupBaiduMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728- (void)setupBaiduMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.baiduMapView setCenterCoordinate:coordinate animated:YES]; // 添加大头针模型数据 self.pointAnnotation.annotationType = XSAnnotationTypeLocationPoint; self.pointAnnotation.locationDetailsModel = self.locationDetails; self.pointAnnotation.coordinate = coordinate; [self.baiduMapView addAnnotation:self.pointAnnotation]; // 添加精度圈 !self.baiduAccuracyCircle ? : [self.baiduMapView removeOverlay:self.baiduAccuracyCircle]; // 移除添加的精度圈 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs || self.locationDetails.GpsType == XSLocationModeLbs) &#123; // wifi 显示精度圈 self.baiduAccuracyCircle = [BMKCircle circleWithCenterCoordinate:coordinate radius:self.locationDetails.Radius]; [self.baiduMapView addOverlay:self.baiduAccuracyCircle]; &#125; // 解析地址 BMKReverseGeoCodeOption *reverseGeocodeSearchOption = [[BMKReverseGeoCodeOption alloc] init]; reverseGeocodeSearchOption.reverseGeoPoint = coordinate; if (![self.geoCodeSearch reverseGeoCode:reverseGeocodeSearchOption]) &#123; XSLog(@&quot;百度反地理编码获取地址失败&quot;); &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.baiduMapView.zoomLevel &lt;= kMapsMinZoomLevel) &#123; return; &#125; BMKCoordinateRegion region = BMKCoordinateRegionMakeWithDistance(coordinate, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2, self.locationDetails.Radius * 2 + self.locationDetails.Radius / 2); [self.baiduMapView setRegion:region animated:YES];&#125; 自定义大头针模型XSPointAnnotation继承自BMKPointAnnotation 扩充两个属性： annotationType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 12345CLLocationCoordinate2D leftCoor = [self.baiduMapView convertPoint:CGPointMake(0, XSScreenH) toCoordinateFromView:self.view];CLLocationCoordinate2D rightCoor = [self.baiduMapView convertPoint:CGPointMake(XSScreenW, XSScreenH) toCoordinateFromView:self.view];BMKMapPoint pointLeft = BMKMapPointForCoordinate(leftCoor);BMKMapPoint pointRight = BMKMapPointForCoordinate(rightCoor);return BMKMetersBetweenMapPoints(pointLeft, pointRight); 3.4、配置信息的回调（真正开始处理显示位置大头针、精度圈、点击显示的弹框泡泡） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 大头针及大头针弹框- (BMKAnnotationView *)mapView:(BMKMapView *)mapView viewForAnnotation:(id &lt;BMKAnnotation&gt;)annotation&#123; XSLogFunc if (![annotation isKindOfClass:[XSPointAnnotation class]]) &#123; // 不是自定义大头针模型 return nil; &#125; BMKAnnotationView *annotationView = nil; XSPointAnnotation *customAnnotation = (XSPointAnnotation *)annotation; if (customAnnotation.annotationType == XSAnnotationTypeLocationPoint) &#123; // 当前位置点类型 annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;LocationAnnotation&quot;]; if (annotationView == nil) &#123; annotationView = [[BMKPinAnnotationView alloc] initWithAnnotation:customAnnotation reuseIdentifier:@&quot;LocationAnnotation&quot;]; &#125; annotationView.image = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; annotationView.draggable = NO; annotationView.canShowCallout = YES; // 自定义的点击大头针显示的气泡View 根据公司需求自定义 self.petAnnotationView.locationDetails = customAnnotation.locationDetailsModel; // 需要显示的设备信息模型 self.petAnnotationView.isHiddenNoNeeds = NO; self.petAnnotationView.width = 270; annotationView.paopaoView = [[BMKActionPaopaoView alloc] initWithCustomView:self.petAnnotationView]; &#125; return annotationView;&#125;// 精度圈- (BMKOverlayView *)mapView:(BMKMapView *)mapView viewForOverlay:(id &lt;BMKOverlay&gt;)overlay&#123; if ([overlay isKindOfClass:[BMKCircle class]])&#123; BMKCircleView *circleView = [[BMKCircleView alloc] initWithOverlay:overlay]; if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; circleView.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; circleView.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.05]; &#125; circleView.lineWidth = 1; return circleView; &#125; return nil;&#125;// 百度反地理编码解析地址回调，需要重新刷新大头针的气泡模型数据- (void)onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; XSLog(@&quot;address:%@----%@&quot;, result.addressDetail, result.address); self.locationDetails.deviceAddress = result.address; self.petAnnotationView.locationDetails = self.locationDetails;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 1234567891011121314151617181920212223- (void)baiduMapViewFitAnnotationsWithCoordinates:(CLLocationCoordinate2D *)coords count:(NSUInteger)count&#123; if (count &lt; 2) return; CLLocationCoordinate2D coor = coords[0]; BMKMapPoint pt = BMKMapPointForCoordinate(coor); CGFloat ltX, ltY, rbX, rbY; ltX = pt.x, ltY = pt.y; rbX = pt.x, rbY = pt.y; for (int i = 1; i &lt; count; i++) &#123; CLLocationCoordinate2D coor = coords[i]; BMKMapPoint pt = BMKMapPointForCoordinate(coor); if (pt.x &lt; ltX) ltX = pt.x; if (pt.x &gt; rbX) rbX = pt.x; if (pt.y &gt; ltY) ltY = pt.y; if (pt.y &lt; rbY) rbY = pt.y; &#125; BMKMapRect rect; rect.origin = BMKMapPointMake(ltX , ltY); rect.size = BMKMapSizeMake(rbX - ltX, rbY - ltY); [self.baiduMapView setVisibleMapRect:rect]; self.baiduMapView.zoomLevel = self.baiduMapView.zoomLevel - 0.3;&#125; 谷歌地图1、注册地图api key12// 在程序启动代理方法注册google map api key 谷歌开发者平台获取[GMSServices provideAPIKey:kGoogleMapApiKey]; 2、初始化地图123456789101112- (void)setupGoogleMapView&#123; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:0 longitude:0 zoom:kMapsZoomLevel]; GMSMapView *mapView = [GMSMapView mapWithFrame:CGRectMake(0, 0, XSScreenW, XSScreenH) camera:camera]; mapView.delegate = self; mapView.myLocationEnabled = YES; [mapView setMinZoom:kMapsMinZoomLevel maxZoom:kMapsMaxZoomLevel]; mapView.settings.compassButton = YES; mapView.settings.consumesGesturesInView = NO; [self.view insertSubview:mapView atIndex:0]; self.googleMapView = mapView;&#125; 3、显示自定义大头针 3.1、从服务器获取当前设备的相关信息转为模型数据(XSDeviceLocation *locationDetails) 3.2、根据当前显示的地图类型设置对应的坐标信息大头针 我的做法在XSDeviceLocation模型里面提供了对应地图的获取属性，在属性getter方法中进行服务器的坐标转换(处理国内返回火星坐标、国外返回标准坐标) 如获取百度坐标locationCoordinateBaidu、获取谷歌坐标locationCoordinateGoogle 根据类型设置坐标数据 123456- (void)setupPetLocationCoordinate:(CLLocationCoordinate2D)coordinate mapType:(XSDisplayMapType)mapType&#123; // 坐标过滤等其他操作 // ... [self setupGoogleMapCoordinate:coordinate];&#125; 3.3、根据设备坐标的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)setupGoogleMapCoordinate:(CLLocationCoordinate2D)coordinate&#123; [self.googleMapView animateToLocation:coordinate]; // Creates a marker in the center of the map. self.marker.markerType = XSMarkerTypeDefaultLocation; self.marker.position = coordinate; self.marker.appearAnimation = YES; self.marker.tracksInfoWindowChanges = YES; self.marker.icon = [UIImage imageNamed:self.locationDetails.deviceBindingTypeImageName]; self.marker.map = self.googleMapView; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 // 点击大头针显示的自定义气泡控件 懒加载 self.petAnnotationView.locationDetails = self.locationDetails; self.petAnnotationView.isHiddenNoNeeds = NO; [[GMSGeocoder geocoder] reverseGeocodeCoordinate:coordinate completionHandler:^(GMSReverseGeocodeResponse * _Nullable response, NSError * _Nullable error) &#123; //FIXME: 错误信息处理 // 获取第一个位置信息 GMSAddress *addressModel = response.firstResult; NSString *firstString = addressModel.lines.firstObject; NSString *lastString = addressModel.lines.lastObject; NSString *address = [NSString stringWithFormat:@&quot;%@, %@&quot;, firstString, lastString]; self.locationDetails.deviceAddress = address; self.marker.locationDetailsModel = self.locationDetails; // 传递模型数据 self.petAnnotationView.locationDetails = self.locationDetails; &#125;]; // 添加精度圈 self.googleAccuracycircle.map = nil; // 清空已存在的 if (self.locationDetails.GpsType == XSLocationModeWifiAndLbs) &#123; // wifi 显示精度圈 self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleWifiAndLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; else if (self.locationDetails.GpsType == XSLocationModeLbs) &#123; self.googleAccuracycircle = [GMSCircle circleWithPosition:coordinate radius:self.locationDetails.Radius]; self.googleAccuracycircle.fillColor = [[UIColor colorWithHexString:kAccuracyCircleLbsFillColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeColor = [[UIColor colorWithHexString:kAccuracyCircleLbsStrokeColor] colorWithAlphaComponent:0.15]; self.googleAccuracycircle.strokeWidth = 1; self.googleAccuracycircle.map = self.googleMapView; &#125; // 计算地图区域缩放 CLLocationDistance horizontalScreenDistance = [self horizontalScreenDistance]; if (self.locationDetails.Radius * 2 &lt; horizontalScreenDistance || self.googleMapView.camera.zoom &lt;= kMapsMinZoomLevel) &#123; return; &#125; int zoomLevel = self.googleMapView.camera.zoom;// double radius = self.locationDetails.Radius + self.locationDetails.Radius / 2; double radius = self.locationDetails.Radius / 2; double scale = radius / 500; zoomLevel = (int) (16 - log(scale) / log(2)); zoomLevel--; [CATransaction begin]; [CATransaction setValue:[NSNumber numberWithFloat:XSAnimationDuration] forKey:kCATransactionAnimationDuration]; GMSCameraPosition *camera = [GMSCameraPosition cameraWithLatitude:coordinate.latitude longitude:coordinate.longitude zoom:zoomLevel]; [self.googleMapView animateToCameraPosition:camera]; [CATransaction commit];&#125; 自定义大头针模型XSMarker继承自GMSMarker 扩充两个属性： markerType ：枚举，显示的大头针类型（切换图标） locationDetailsModel ：当前大头针的模型数据，点击显示气泡详情的数据 添加精度圈后精度半径过大可能超出屏幕影响用户体验，解决方法如下： 根据屏幕最左和最后两个点，转换出地图上对应的坐标点并计算出距离d 根据当前精度圈半径 * 2 和 d 比较，如果超出屏幕就重新设置地图显示区域 计算屏幕距离核心代码 123CLLocationCoordinate2D leftCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(0, XSScreenH)];CLLocationCoordinate2D rightCoor = [self.googleMapView.projection coordinateForPoint:CGPointMake(XSScreenW, XSScreenH)];return GMSGeometryDistance(leftCoor, rightCoor); 3.4、点击大头针显示气泡view的回调 1234567- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker&#123; XSLogFunc self.petAnnotationView.width = 270; self.petAnnotationView.locationDetails = self.locationDetails; // 刷新显示的信息 return self.petAnnotationView;&#125; 4、多个坐标线显示在屏幕范围内 绘制多个轨迹点和绘制线比较简单，直接参考官方文档 在历史轨迹界面，可能希望显示的所有轨迹点都在屏幕范围内 123456789- (void)googleMapViewFitAnnotationsWithCoordinates:(NSArray *)coordsModels count:(NSUInteger)count&#123; GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] init]; for (int i = 1; i &lt; count; i++) &#123; CLLocationCoordinate2D coor = [coordsModels[i] locationCoordinate2D]; bounds = [bounds includingCoordinate:coor]; &#125; [self.googleMapView animateWithCameraUpdate:[GMSCameraUpdate fitBounds:bounds withPadding:30.0f]];&#125; Maps 导航 检测是否安装对应的地图 常用的4个地图的 URL Scheme: 1.苹果自带地图（不需要检测，所以不需要URL Scheme）2.百度地图 ：baidumap://3.高德地图 ：iosamap://4.谷歌地图 ：comgooglemaps:// 在IOS9之后，苹果进一步完善了安全机制，必须在plist里面设置url scheme白名单，不然无法打开对应的应用 添加白名单： 在 info.plist 文件里面，添加一个字段：LSApplicationQueriesSchemes，类型为数组 然后在这个数组里面再添加我们所需要的地图 URL Scheme : 1234&gt; baidumap // 百度&gt; iosamap // 高德&gt; comgooglemaps // 谷歌&gt; 应用内部调用google maps地图发起导航功能 1、x-source=%@&amp;x-success=%@跟高德一样 这里分别代表APP的名称和URL Scheme 2、saddr=这里留空则表示从当前位置触发。 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;comgooglemaps://&quot;]]) &#123; NSMutableDictionary *googleMapDic = [NSMutableDictionary dictionary]; googleMapDic[@&quot;title&quot;] = @&quot;谷歌地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;comgooglemaps://?x-source=%@&amp;x-success=%@&amp;saddr=&amp;daddr=%f,%f&amp;directionsmode=driving&quot;,@&quot;导航测试&quot;,@&quot;nav123456&quot;,endLocation.latitude, endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; googleMapDic[@&quot;url&quot;] = urlString; [maps addObject:googleMapDic];&#125; 应用内部调用百度地图发起导航功能 1，origin=, 这个是不能被修改的，不然无法把出发位置设置为当前位置 2，destination = latlng:%f,%f|name = 目的地这里面的 name 的字段不能省略，否则导航会失败，而后面的文字则可以随意，赋个你的目的地的值给他就可以了。 3，coord_type = gcj02coord_type 允许的值为 bd09ll、gcj02、wgs84，如果你 APP 的地图 SDK 用的是百度地图 SDK，请填 bd09ll，否则就填gcj02，wgs84的话基本是用不上了 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;baidumap://&quot;]]) &#123; NSMutableDictionary *baiduMapDic = [NSMutableDictionary dictionary]; baiduMapDic[@&quot;title&quot;] = @&quot;百度地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;baidumap://map/direction?origin=&#123;&#123;我的位置&#125;&#125;&amp;destination=latlng:%f,%f|name=北京&amp;mode=driving&amp;coord_type=gcj02&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; baiduMapDic[@&quot;url&quot;] = urlString; [maps addObject:baiduMapDic];&#125; 应用内部调用高德地图发起导航功能 1、sourceApplication=%@&amp;backScheme=%@sourceApplication代表你自己APP的名称 会在之后跳回的时候显示出来 所以必须填写 backScheme是你APP的URL Scheme 不填是跳不回来的哟 2、dev=0这里填0就行了，跟上面的gcj02一个意思 1代表wgs84 也用不上 1234567if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;iosamap://&quot;]]) &#123; NSMutableDictionary *gaodeMapDic = [NSMutableDictionary dictionary]; gaodeMapDic[@&quot;title&quot;] = @&quot;高德地图&quot;; NSString *urlString = [[NSString stringWithFormat:@&quot;iosamap://navi?sourceApplication=%@&amp;backScheme=%@&amp;lat=%f&amp;lon=%f&amp;dev=0&amp;style=2&quot;,@&quot;导航功能&quot;,@&quot;nav123456&quot;,endLocation.latitude,endLocation.longitude] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; gaodeMapDic[@&quot;url&quot;] = urlString; [maps addObject:gaodeMapDic];&#125; 应用内部调用苹果地图发起导航功能 123456CLLocationCoordinate2D loc = CLLocationCoordinate2DMake([self.model.latitude floatValue], [self.model.longitude floatValue]);MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:loc addressDictionary:nil]];[MKMapItem openMapsWithItems:@[currentLocation, toLocation]launchOptions:@&#123;MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:YES]&#125;];]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之地图篇(一)]]></title>
    <url>%2Farchives%2F1c8732fb.html</url>
    <content type="text"><![CDATA[赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。 地图坐标体系1.WGS－84原始坐标系 一般用国际GPS纪录仪记录下来的经纬度 通过GPS定位拿到的原始经纬度 Google（国外）、高德地图（国外）、OSM地图定位的的经纬度。 但是在国内是不允许直接用WGS84坐标系标注的，必须经过加密后才能使用 注意：国内不允许直接使用，但是GPS设备上传的数据还是标准的数据，国内使用需要转为GCJ－02坐标 2.GCJ－02坐标系 GCJ－02坐标系又名“火星坐标系”，是我国国测局独创的坐标体系，由WGS－84加密而成。 在国内，必须至少使用GCJ－02坐标系，如高德和Google在国内。 或者使用在GCJ－02加密后再进行加密的坐标系，如百度坐标系。 3.百度坐标系:bd-09 百度坐标系是在GCJ－02坐标系的基础上再次加密偏移后形成的坐标系，只适用于百度地图。 国内地图偏移问题 地图偏移问题一般只有在国内才会出现 国内‘标准’GPS设备定位坐标为GCJ－02坐标系，显示地图为偏移过的地图，最终显示的为准确的位置国内非’标准’的设备定位坐标为WGS－84原始坐标系，显示地图为偏移过的地图，最终显示的位置出现偏移 Google MapsGoogle Maps注意点 自定义弹窗可以直接使用InfoWindow 调整地图上面的图标位置 没办法可以直接调整每一个图标的位置 可以设置地图的内容padding属性来调整 但是padding属性设置局限于调整和屏幕边缘的距离 刷新地图弹框内容可以设置自动刷新帧的间隔（对应有的不需要变化的控件可以关闭以节约性能） 添加手势会和地图的手势冲突，需要设置地图的consumesGesturesInView为false consumesGesturesInView手势控制是否用户设置的手势被谷歌地图接管处理默认设置为YES 定位点的自定义弹框 每一个定位点对象GMSMarker 如果想要自定义弹框可以在下面方法实现 (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker 如果想要刷新地图弹框的内容, 需要在设置Marker的方法里直接转换坐标，并且实时位置的自定义弹框需要全局是一个控件，否则无法刷新控件 markerInfoWindow：方法只需要初始化控件即可，在获取到数据设置GMSMarker的方法里传递数据 想要刷新数据要设置 tracksInfoWindowChanges = YES 在国内直接使用GPS原始坐标显示在地图上面会有偏移 可以使用网上别人c语言写的一些纠偏算法，纠偏后偏移不是很大（纠偏只针对国内，可以使用经纬度区分国内还是国外的区域，不是非常准确） 高德地图和百度地图SDK里面有提供国内外区域判断的Api，提供一个坐标点判断是在国内还是在国外 Google Maps 收费 The Google Maps Geolocation API 普通用户 每天可以调用2500次，每秒调用50次 超过后按每1000次/0.5美元收费（还是有调用限制：每天上限:100000次） 高级用户 高级用户需要和Google公司联系，可以按协议付费提高调用次数限制 但是只能针对国外的公司（不对国内公司提供服务），账单付费也必须是国外的公司 解决方法 （调用高德服务） 高德地图针对没有开发对应的iOS和Android的客户端的只能硬件产品的企业用户, 提供智能硬件定位服务，支持通过服务端上传WIFI和基站信息进行定位并获取经纬度。 需要开发者账号注册为企业用户 免费调用限制为3000000次/每天 同Google Maps Geolocation API 将设备GPS获取到的Wifi和Lb数据或者Cell Tower数据转换为对应的经纬度信息 高德转出来的为GCJ－02坐标体系（火星坐标） 有国外的数据支持，但是具体的精准的还需要再测试 地图坐标体系转换 地图的SDK一般会提供其他地图坐标体系到自身体系的转换接口 但是 均不提供从自身向其他坐标体系转换 google SDK没有坐标转换接口 别人写的转换方法、有误差 https://github.com/JackZhouCn/JZLocationConverter 别人写的服务器（C#版）坐标转换 https://www.jianshu.com/p/8975586a820e]]></content>
      <categories>
        <category>iOS</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew介绍]]></title>
    <url>%2Farchives%2F4f2aa8f3.html</url>
    <content type="text"><![CDATA[iOS开发工具之Homebrew篇Homebrew官网 https://brew.sh/index_zh-cn.htmlHomebrew 是基于 OS X 的套件管理工具，是一个开源的 Ruby 脚本，专门用于快速下载软件 Homebrew 类似于一个软件中心，可以理解成 App Store 或者 Google Play 那样的软件商店, 且内容更加丰富; Homebrew Cask，它是一套建立在 Homebrew 基础之上的 OS X 软件安装命令行工具，是 Homebrew 的扩展;使用Homebrew有什么优势呢? 通过 Homebrew 下载安装的软件全部来自对应的软件官网，无需担心下载源的安全问题; 依存于系统既有的库，减少了空间占用和冗余; 使用 Git 进行管理和更新; 易于定制; Homebrew 使用： 安装软件 brew cask install 软件名 1brew cask install google-chrome 卸载软件 brew cask uninstall 软件名 1brew cask uninstall google-chrome 软件搜索 brew cask search 软件名 1brew cask search google 查看软件相关信息 brew cask info 软件名 1brew cask info google-chrome 删除 Homebrew Cask 下载的包 1brew cask cleanup 列出通过 Homebrew Cask 安装的包 1brew cask list 更新 Homebrew Cask 1brew cask update Homebrew 安装QuickLook常用的插件QuickLook插件http://www.quicklookplugins.com/ brew cask install qlmarkdown // 预览Markdown QLColorCode // 代码块高亮 QuickLook-JSON // JSON 文件 QLPrettyPatch // Patch 文件 qlvideo // 视频预览 QLStephen // 预览无拓展名的纯文本文件 BetterZipQL // 查看 Zip 压缩文件的信息以及文件目录 QLImageSize // 预览窗口的标题栏中显示图片分辨率及文件大小，并在 Finder 中显示图片的格式; 还支持 bpg、Portable Pixmap、WebP 格式 QuickLook-CSV // 预览 CSV 文件 qladdict // .srt (Subtitle)]]></content>
      <categories>
        <category>工具</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB介绍]]></title>
    <url>%2Farchives%2Fc9e6c86c.html</url>
    <content type="text"><![CDATA[iOS开发工具之LLDB介篇 LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。 安装Chisel Facebook 开源的 lldb 插件 Chisel. 1、Chisel 使用 homebrew 来安装，如果你没有安装homebrew 12brew updatebrew install chisel 2、安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下： 123==&gt; CaveatsAdd the following line to ~/.lldbinit to load chisel when Xcode launches:command script import /usr/local/opt/chisel/libexec/fblldb.py 3、然后重启Xcode 常用的调试指令pjson 打印json格式数据，调试服务器返回数据时候用。 p/x 打印16进制数据 p/t 打印2进制数据 e 修改属性和调用方法 pviews 这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription]。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。 pvc 个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy]同样的效果。 visualize 这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。 fv &amp; fvc fv和 fvc这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。 show &amp; hide 这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder 这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush 这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。 当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。 bmessage 这个命令就是用来打断点用的了，虽然大家断点可能都喜欢在图形界面里面打，但是考虑一种情况：我们想在[MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear:方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。 那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： (lldb) bmessage -[MyViewController viewWillAppear:]上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]] help 可以用帮助文档查看所有的指令或者单个指令的使用方法 常用的Debug快捷键1234567891011121314151617cmd + ctrl + Y // 暂停/继续cmd + Y // 断点失效/生效cmd + shift + Y // 控制台显示/隐藏cmd + shift + C // 光标切换到控制台cmd + K // 清空控制台continue \(c\) // 继续执行step over F6 （n） // 单步执行step into F7（s） // 跳入step out F8 （finish）// 跳出]]></content>
      <categories>
        <category>工具</category>
        <category>LLDB</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM介绍]]></title>
    <url>%2Farchives%2F1c40fe4d.html</url>
    <content type="text"><![CDATA[iOS开发工具之VIM篇VIM相关的指令 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 打开12345vim 直接启动vimvim filename 打开vim并创建名为filename的文件 // 打开单个文件vim file1 file2 file3 … // 打开多个文件:open file // 在vim窗口中打开一个新文件:split file // 在新窗口中打开文件 退出指令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi:q 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insertmode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式(command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile * 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： 12345: w filename // （输入 「w filename」将文章以指定的文件名filename保存）: wq // (输入「wq」，存盘并退出vi): q! // (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符 「dd」：删除光标所在行 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 6）. 替换 「r」：替换光标所在处的字符 「R」：替换光标所到之处的字符，直到按下「ESC」键为止 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作 、按多次“u”可以执行多次回复 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号 「#G」：例如，「15G」，表示移动光标至文章的第15行行首 4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件 5、vi命令列表 1、下表列出命令模式下的一些键的功能： 123456789101112131415161718192021222324252627282930h 左移光标一个字符h 左移光标一个字符k 光标上移一行j 光标下移一行^ 光标移动至行首0 数字“0”，光标移至文章的开头G 光标移至文章的最后$ 光标移动至行尾Ctrl+f 向前翻屏Ctrl+b 向后翻屏Ctrl+d 向前翻半屏Ctrl+u 向后翻半屏i 在光标位置前插入字符a 在光标所在位置的后一个字符开始增加o 插入新的一行，从行首开始输入ESC 从输入状态退至命令状态x 删除光标后面的字符#x 删除光标后的＃个字符X (大写X) 删除光标前面的字符#X 删除光标前面的#个字符dd 删除光标所在的行#dd 删除从光标所在行数的#行yw 复制光标所在位置的一个字# yw复制光标所在位置的#个字yy 复制光标所在位置的一行#yy 复制从光标所在行数的#行p 粘贴u 取消操作cw 更改光标所在位置的一个字#cw 更改光标所在位置的#个字 2、下表列出行命令模式下的一些指令 123456w filename 储存正在编辑的文件为filenamewq filename 储存正在编辑的文件为filename，并退出viq! 放弃所有修改，退出viset nu 显示行号/或? 查找，在/后输入要查找的内容n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。 切换放方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）]]></content>
      <categories>
        <category>工具</category>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之AppStore篇]]></title>
    <url>%2Farchives%2F9b9b2c59.html</url>
    <content type="text"><![CDATA[iOS开发之AppStore篇– 上架图片尺寸 需要一张通用的1024 x 1024 在App Store里面用 （xcode9 之前在App Store里面上传；xcode9之后在开发工具里面配置） 其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间 不能包含图层或圆角 不能有透明像素和alpha通道 桌面图标 (app icon) for iPhone6 plus(@3x) : 180 x 180 // 命名规范：App-60@3x for iPhone 6/5s/5/4s/4(@2x) : 120 x 120 // 命名规范：App-60@2x 系统搜索框图标 (Spotlight search results icon) for iPhone6 plus(@3x) : 120 x 120 // 命名规范：Spotlight-40@3x for iPhone6/5s/5/4s/4(@2x) : 80 x 80 // 命名规范：Spotlight-40@2x 系统设置图标 (Settings icon) for iPhone6 plus(@3x) : 87 x 87 // 命名规范：Settings-29@3x for iPhone6/5s/5/4s/4(@2x) : 58 x 58 // 命名规范：Settings-29@2x 启动图片 (launch image) for iPhoen5s/5(@2x) : 640 x 1136 // 命名规范：LaunchImage-568h@2x for iPhone 6(@2x) : 750 x 1334 // 命名规范： LaunchImage-667h@2x for iPhone 6 plus (@3x) : 1242 x 2208 // 命名规范： LaunchImage-736h@3x for iPhoneX (@3x) : 1125 x 2436 // 命名规范： LaunchImage-812h@3x 预览和屏幕快照关于App Store上架电脑系统是测试版或者Xcode是测试版 打包上传出错报如下错误代码，最后通过重装系统（正式版）解决 注意即使用测试版系统或者Xcode打包的程序上传成功、最后上传到AppStore审核的时候也有可能被拒 1ERROR ITMS-90167: &quot;No .app bundles found in the package&quot; 项目中有静态库不支持bitcode上架打包错误1‘xxx/lib**SDK.a(**ForSDK.o)’does not contain bitcode. You must rebuild it with bitcode enabled (Xcodesetting ENABLE_BITCODE), obtain an updated library from the vendor, or disablebitcode for this target. for architecture arm64 解决方法 重新打包静态库，使之支持bitcode 如果静态库比较老，没法重新编译，就需要关闭xcode的bitcode功能 Target -&gt; Build Settings -&gt; Bulid option : Enable Bitcode 设置为NO 项目中有设置URL Schemes1error itms-90158: &quot;the following url schemes found in your app are not in the current format:[mqq://]. 可能是跳转的app id 不正确 app审核通过后AppStore依然搜索不到解决办法 偶尔审核通过但是搜索不到，一般是DNS缓存问题 需要等待苹果服务器刷新 可以通过下面的方法加速刷新 在价格与销售范围里面修改：价格 —&gt; 等级1（收费即可）、销售地区 全部取消只选择 -&gt; 中国, 保存，此时刷新app审核状态就会变为 pending contract（协商价格） 然后再在价格与销售范围里面修改：价格 —&gt; 等级0（app原来的价格 我这里是免费）、销售地区 全部选择 -&gt; 所有地区, 保存，此时刷新app审核状态就会变为 Ready for sale（可供销售） 等待大概半个到一个小时就可以在AppStore里面搜索到了 打包上传后再iTunes connect后台一直看不到上传的包文件 可能是info.plist里面需要配置的申请权限没有配置，这时会收到APPle发送的邮件解释的很清楚，但是有时可能appleID账号是老板的私人邮箱，老板收到又没有及时转发给你，这时候就要找老板问下是否有接收到邮件。 关于游客账户 除社交、和财产挂钩等app可以只提供注册后登录，其他app应视情况提供游客登录模式，在应用内限制游客账户的功能 如果不提供游客账号登录功能一般不会出问题，但是主要看人品，不能确定哪一版本就给拒了App Store 审核指南（中文） 关于和硬件相关的app 我们公司大部分都是和单片机等通讯的硬件产品，关于这类app，上架后需要录制软件和硬件的操作交互视频上传YouTube（建议）或者youku等平台，然后在iTunes connect 里面提供上传视频连接以供审核。]]></content>
      <categories>
        <category>iOS</category>
        <category>App Store</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App Store</tag>
      </tags>
  </entry>
</search>
